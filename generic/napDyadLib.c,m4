m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (napDyad.c) */
/* It was produced from source file napDyad.c,m4 */

/* 
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napDyadLib.c,m4,v 1.103 2006/11/30 03:09:55 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"

/*
 *  Nap_InnerProd --
 *	Operator ".".
 *	For vectors this is dot (scalar) product.
 *	For matrices this is matrix product.
 *	If one arg is matrix & other is vector then result is vector.
 *	Treat scalar arg as vector.
 */

m4begin

m4define(`m4NAME', `Nap_InnerProd')

#       scalar product of two vectors: m4innerProd1(dataTypeResult)
m4define(`m4innerProd1', `
	case m4DataTypeEnum($1):
	    naoResult->data.$1[0] = 0;
	    for (i = 0; i < nao1->nels; i++) {
		if (!IsMissing(nao1, i) && !IsMissing(nao2, i)) {
		    naoResult->data.$1[0] += nao1->data.$1[i] * nao2->data.$1[i];
		}
	    }
	    break;')

#       matrix product : m4innerProd2(dataTypeResult)
m4define(`m4innerProd2', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < shape[0]; i++) {
		for (j = 0; j < shape[1]; j++) {
		    naoResult->data.$1[i*shape[1]+j] = 0;
		    for (k = 0; k < n; k++) {
			if (!IsMissing(nao1, i*n+k) && !IsMissing(nao2, k*shape[1]+j)) {
			    naoResult->data.$1[i*shape[1]+j] +=
				    nao1->data.$1[i*n+k] * nao2->data.$1[k*shape[1]+j];
			}
		    }
		}
	    }
	    break;')

m4end

EXTERN char *
Nap_InnerProd(
    NapClientData	*nap_cd,
    char		*str1,
    char		*str2)
{
    Nap_NAO		*coordNaoPtr;
    Nap_dataType	dataType;
    size_t		i;
    size_t		j;
    size_t		k;
    size_t		n;
    size_t		n1;
    Nap_NAO		*nao1;
    Nap_NAO		*nao2;
    Nap_NAO		*naoArg1;
    Nap_NAO		*naoArg2;
    Nap_NAO		*naoResult;
    int			rank;
    size_t		shape[2];
    int                 status;

    naoArg1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK1NULL(naoArg1);
    Nap_IncrRefCount(nap_cd, naoArg1);
    naoArg2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    CHECK1NULL(naoArg2);
    Nap_IncrRefCount(nap_cd, naoArg2);
    dataType = Nap_DataType2(naoArg1->dataType , naoArg2->dataType);
    nao1 = Nap_CastNAO(nap_cd, naoArg1, dataType);
    Nap_IncrRefCount(nap_cd, nao1);
    Nap_DecrRefCount(nap_cd, naoArg1);
    nao2 = Nap_CastNAO(nap_cd, naoArg2, dataType);
    Nap_IncrRefCount(nap_cd, nao2);
    Nap_DecrRefCount(nap_cd, naoArg2);
    switch (Max(nao1->rank, nao2->rank)) {
    case 0:
    case 1:
	CHECK2NULL(nao1->nels == nao2->nels, "m4NAME: args have incompatible shapes");
	naoResult = Nap_NewNAO(nap_cd, dataType, 0, shape);
	switch (dataType) {
	m4ForAllNumericDataType(`m4innerProd1(', `)')
	default:            /* error */
	    assert(FALSE);
	}
	break;
    case 2:
	n1 = nao1->rank > 0 ? nao1->shape[nao1->rank - 1] : 1;
	n  = nao2->rank > 0 ? nao2->shape[0] : 1;
	CHECK2NULL(n1 == n, "m4NAME: args have incompatible shapes");
	rank = Max(1, Min(nao1->rank, nao2->rank));
	if (nao1->rank == 2) {
	    shape[0] = nao1->shape[0];
	}
	if (nao2->rank == 2) {
	    shape[rank-1] = nao2->shape[1];
	}
	naoResult = Nap_NewNAO(nap_cd, dataType, rank, shape);
	if (nao1->rank == 2) {
	    coordNaoPtr = Nap_GetCoordVar(nap_cd, nao1, 0);
	    status = Nap_AttachCoordVar(nap_cd, naoResult, coordNaoPtr, nao1->dimName[0], 0);
	    CHECK1NULL(status == TCL_OK);
	}
	if (nao2->rank == 2) {
	    coordNaoPtr = Nap_GetCoordVar(nap_cd, nao2, 1);
	    status = Nap_AttachCoordVar(nap_cd, naoResult, coordNaoPtr, nao2->dimName[1], rank-1);
	    CHECK1NULL(status == TCL_OK);
	}
	shape[0] = nao1->nels / n;
	shape[1] = nao2->nels / n;
	switch (dataType) {
	m4ForAllNumericDataType(`m4innerProd2(', `)')
	default:            /* error */
	    assert(FALSE);
	}
	break;
    default:
	CHECK2NULL(0, "m4NAME: args have rank > 2");
    }
    Nap_DecrRefCount(nap_cd, nao1);
    Nap_DecrRefCount(nap_cd, nao2);
    return naoResult->id;
}

/*
 *  SubscriptType --
 *	Argument is subscript (part of index corresponding to a dimension)
 *	Result is:
 *	    0 for normal subscript
 *	    1 for NULL, indicating full dimension (in normal order)
 *	   -1 for scalar F32 (-infinity), indicating full dimension reversed
 *	Note that niladic operator '-' generates such a (-infinity). E.g. "vector(-)"
 */

m4define(`m4NAME', `SubscriptType')

static int
SubscriptType(
    Nap_NAO		*naoPtr)	/* subscript */
{
    if (naoPtr) {
	if (naoPtr->dataType == NAP_F32  &&  naoPtr->rank == 0
		&&  naoPtr->data.F32[0] == -napF32Inf) {
	    return -1;
	} else {
	    return 0;
	}
    } else {
	return 1;
    }
}

/*
 *  Nap_SubscriptCopy --
 *	Copy elements defined by cross-product of subscripts.
 *	Called by Nap_SubscriptCrossProduct, then recursively by Nap_SubscriptCopy.
 *	*dst is incremented to point to next undefined byte.
 */

m4define(`m4NAME', `Nap_SubscriptCopy')

static int
Nap_SubscriptCopy(
    NapClientData       *nap_cd,
    int			n,		/* # remaining dimensions */
    size_t              prodShape[],	/* # bytes in slab at each level */
    Nap_NAO		*naoSubEl[],	/* remaining subscripts */
    char                *mv,		/* missing value source */
    int			is_missing,	/* TRUE if any subscript element so far is missing */
    char                *src,		/* source */
    char                **dst)		/* destination (in/out) */
{
    int			i;		/* source offset */
    long		j;		/* scalar value of subscript */
    int			k;		/* subscript of high-order subscript */
    long		shape0;		/* divisor for subscripts */
    int			status;

    assert(n > 0);
    if (prodShape[0] > 0) {
	shape0 = prodShape[0] / prodShape[1];
	switch (SubscriptType(naoSubEl[0])) {
	case -1:
	    if (n == 1) {
		for (k = shape0-1; k >= 0; k--) {
		    if (is_missing) {
			memcpy(*dst, mv, prodShape[1]);
		    } else {
			i = prodShape[1] * k;
			memcpy(*dst, src+i, prodShape[1]);
		    }
		    *dst += prodShape[1];
		}
	    } else {
		for (k = shape0-1; k >= 0; k--) {
		    i = prodShape[1] * k;
		    status = Nap_SubscriptCopy(nap_cd, n-1, prodShape+1, naoSubEl+1, mv,
			    is_missing, src+i, dst);
		    CHECK2(status == TCL_OK, "m4NAME: Error calling m4NAME");
		}
	    }
	    break;
	case 0:
	    assert(naoSubEl[0]->dataType == NAP_I32);
	    if (n == 1) {
		for (k = 0; k < naoSubEl[0]->nels; k++) {
		    if (is_missing || IsMissing(naoSubEl[0], k)) {
			memcpy(*dst, mv, prodShape[1]);
		    } else {
			j = Nap_lmod(naoSubEl[0]->data.I32[k], shape0);
			i = prodShape[1] * j;
			memcpy(*dst, src+i, prodShape[1]);
		    }
		    *dst += prodShape[1];
		}
	    } else {
		for (k = 0; k < naoSubEl[0]->nels; k++) {
		    j = Nap_lmod(naoSubEl[0]->data.I32[k], shape0);
		    i = prodShape[1] * j;
		    status = Nap_SubscriptCopy(nap_cd, n-1, prodShape+1, naoSubEl+1, mv,
			    is_missing || IsMissing(naoSubEl[0], k), src+i, dst);
		    CHECK2(status == TCL_OK, "m4NAME: Error calling m4NAME");
		}
	    }
	    break;
	case 1:
	    if (n == 1) {
		for (k = 0; k < shape0; k++) {
		    if (is_missing) {
			memcpy(*dst, mv, prodShape[1]);
		    } else {
			i = prodShape[1] * k;
			memcpy(*dst, src+i, prodShape[1]);
		    }
		    *dst += prodShape[1];
		}
	    } else {
		for (k = 0; k < shape0; k++) {
		    i = prodShape[1] * k;
		    status = Nap_SubscriptCopy(nap_cd, n-1, prodShape+1, naoSubEl+1, mv,
			    is_missing, src+i, dst);
		    CHECK2(status == TCL_OK, "m4NAME: Error calling m4NAME");
		}
	    }
	    break;
	default:
	    assert(0);
	}
    }
    return TCL_OK;
}

/*
 *  Nap_MultiLinearInterp --
 *	Define an element using multi-linear interpolation.
 */

m4define(`m4NAME', `Nap_MultiLinearInterp')

/*
 *  Microsoft C++ seems to think all values == NaN!!
 *  So define mv_is_nan as work-around.
 */

#define ADD_PROD(weight, value) \
    if (weight) { \
        if (IsNaN32(value)  ||  (!mv_is_nan  &&  value == mv)) { \
            return TCL_OK; \
        } \
        result += (weight) * (value); \
    }

static int
Nap_MultiLinearInterp(
    NapClientData       *nap_cd,
    float		src[],		/* source */
    int			rank,		/* of source */
    size_t              shape[],	/* of source */
    float		subscript[],	/* subscript vector */
    float		mv,		/* missing value */
    float		*z)		/* result (out) */
{
    int			b;			/* bit */
    float               fs;		 	/* float subscript */
    size_t		i[2][NAP_MAX_RANK]; 	/* lower/higher index */
    unsigned long	j;			/* subscript */
    int			k;			/* subscript */
    int			mv_is_nan = IsNaN32(mv);
    unsigned long	nterms;			/* # terms in formula */
    size_t              p[NAP_MAX_RANK];	/* cum. products of shape */
    double		power;			/* 2**rank */
    float               pw;		 	/* product of weights */
    register float	result = 0.0;	 	/* set *z to this */
    size_t		s;			/* subscript */
    float               w[2][NAP_MAX_RANK]; 	/* lower/higher weights */

    *z = mv;
    for (k = 0; k < rank; k++) {
	if (shape[k] == 0  ||  IsNaN32(subscript[k])) {
	    return TCL_OK;
	}
    }
    for (k = 0; k < rank; k++) {
	fs = Nap_fmod_f32(subscript[k], shape[k]);
	assert(fs >= 0.0  &&  fs < shape[k]);
	i[0][k] = fs;
	i[1][k] = (i[0][k] + 1) % shape[k];
	assert(i[0][k] < shape[k]);
	assert(i[1][k] < shape[k]);
	w[1][k] = fs - i[0][k];
	w[0][k] = 1.0 - w[1][k];
	assert(w[0][k] >= 0.0  &&  w[0][k] <= 1.0);
	assert(w[1][k] >= 0.0  &&  w[1][k] <= 1.0);
    }
    p[rank-1] = 1;
    for (k = rank-1; k > 0; k--) {
	p[k-1] = shape[k] * p[k];
    }

    /*
     *  Following explicit formulae for ranks 0, 1, 2, 3 are for efficiency.
     */

    switch (rank) {
    case 0:
	result = src[0]; 
	break;
    case 1:
	ADD_PROD(w[0][0], src[i[0][0]]);
	ADD_PROD(w[1][0], src[i[1][0]]);
	break;
    case 2:
	ADD_PROD(w[0][0] * w[0][1], src[p[0] * i[0][0] + i[0][1]]);
	ADD_PROD(w[0][0] * w[1][1], src[p[0] * i[0][0] + i[1][1]]);
	ADD_PROD(w[1][0] * w[0][1], src[p[0] * i[1][0] + i[0][1]]);
	ADD_PROD(w[1][0] * w[1][1], src[p[0] * i[1][0] + i[1][1]]);
	break;
    case 3:
	ADD_PROD(w[0][0] * w[0][1] * w[0][2], src[p[0] * i[0][0] + p[1] * i[0][1] + i[0][2]]);
	ADD_PROD(w[0][0] * w[0][1] * w[1][2], src[p[0] * i[0][0] + p[1] * i[0][1] + i[1][2]]);
	ADD_PROD(w[0][0] * w[1][1] * w[0][2], src[p[0] * i[0][0] + p[1] * i[1][1] + i[0][2]]);
	ADD_PROD(w[0][0] * w[1][1] * w[1][2], src[p[0] * i[0][0] + p[1] * i[1][1] + i[1][2]]);
	ADD_PROD(w[1][0] * w[0][1] * w[0][2], src[p[0] * i[1][0] + p[1] * i[0][1] + i[0][2]]);
	ADD_PROD(w[1][0] * w[0][1] * w[1][2], src[p[0] * i[1][0] + p[1] * i[0][1] + i[1][2]]);
	ADD_PROD(w[1][0] * w[1][1] * w[0][2], src[p[0] * i[1][0] + p[1] * i[1][1] + i[0][2]]);
	ADD_PROD(w[1][0] * w[1][1] * w[1][2], src[p[0] * i[1][0] + p[1] * i[1][1] + i[1][2]]);
	break;
    default:
	power = pow(2.0, rank);
	CHECK3(power <= ULONG_MAX, "m4NAME: Unable to cope with rank = %d", rank);
	nterms = 1UL << (unsigned long) rank;
	for (j = 0; j < nterms; j++) {
	    s = 0;
	    pw = 1;
	    for (k = 0; k < rank; k++) {
		b = (j >> k) & 1;
		pw *= w[b][k];
		s += p[k] * i[b][k];
	    }
	    ADD_PROD(pw, src[s]);
	}
    }
    *z = result;
    return TCL_OK;
}

/*
 *  Nap_SubscriptInterp --
 *	Define elements defined by cross-product of float subscripts.
 *	Called by Nap_SubscriptCrossProduct, then recursively by Nap_SubscriptInterp.
 *	*dst is incremented to point to next undefined element.
 */

m4define(`m4NAME', `Nap_SubscriptInterp')

static int
Nap_SubscriptInterp(
    NapClientData       *nap_cd,
    int			rank,			/* of source */
    size_t              shape[],		/* of source */
    int			dimNum,			/* dimension number */
    Nap_NAO		*naoSubEl[],		/* all subscripts */
    float		subscript[],		/* subscript vector */
    int			is_missing,		/* TRUE if any subscript element so far missing */
    float		src[],			/* source */
    float		mv,			/* missing value */
    float		**dst)			/* destination (in/out) */
{
    int			k;			/* subscript */
    float		modulus;		/* divisor for subscripts */
    int			status;

    assert(rank > 0  &&  rank <= NAP_MAX_RANK);
    assert(dimNum <= rank);
    if (dimNum < rank) {
	switch (SubscriptType(naoSubEl[dimNum])) {
	case -1:
	    for (k = shape[dimNum] - 1; k >= 0; k--) {
		subscript[dimNum] = k;
		status = Nap_SubscriptInterp(nap_cd, rank, shape, dimNum+1, naoSubEl, subscript,
			is_missing, src, mv, dst);
		CHECK2(status == TCL_OK, "m4NAME: Error calling m4NAME");
	    }
	    break;
	case 0:
	    modulus = shape[dimNum];
	    assert(naoSubEl[dimNum]->dataType == NAP_F32);
	    for (k = 0; k < naoSubEl[dimNum]->nels; k++) {
		subscript[dimNum] = Nap_fmod_f32(naoSubEl[dimNum]->data.F32[k], modulus);
		status = Nap_SubscriptInterp(nap_cd, rank, shape, dimNum+1, naoSubEl, subscript,
			is_missing || IsMissing(naoSubEl[dimNum], k), src, mv, dst);
		CHECK2(status == TCL_OK, "m4NAME: Error calling m4NAME");
	    }
	    break;
	case 1:
	    for (k = 0; k < shape[dimNum]; k++) {
		subscript[dimNum] = k;
		status = Nap_SubscriptInterp(nap_cd, rank, shape, dimNum+1, naoSubEl, subscript,
			is_missing, src, mv, dst);
		CHECK2(status == TCL_OK, "m4NAME: Error calling m4NAME");
	    }
	    break;
	default:            /* error */
	    assert(0);
	}
    } else {
	if (is_missing) {
	    **dst = mv;
	} else {
	    status = Nap_MultiLinearInterp(nap_cd, src, rank, shape, subscript, mv, *dst);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_MultiLinearInterp");
	}
	++(*dst);
    }
    return TCL_OK;
}

/*
 *  Nap_SubscriptIndirect --
 *
 *  Handle indirect subscripting
 *  Result is new subscript of type i32 or f32
 *
 *  If code[d] == 0 (direct) then result has datatype i32 if naoSub is integer, else f32
 *  If code[d] == 1 (@)   then result has datatype f32
 *  If code[d] == 2 (@@)  then result has datatype i32
 *  If code[d] == 3 (@@@) then result has datatype i32
 *  Coord var must exist if code[d] > 0
 *  If any dimension has result of type f32 then all others are cast to f32
 *
 *  Each result nao has ref. count of 1.
 */

m4define(`m4NAME', `Nap_SubscriptIndirect')

static int
Nap_SubscriptIndirect(
    NapClientData       *nap_cd,
    int			n,			/* rank */
    Nap_NAO		*cv[],			/* coordinate variable */
    Nap_NAO		*naoSub[],		/* subscript (can be NULL) */
    Nap_i8		code[],			/* 0 = direct, 1 = "@", 2 = "@@", 3 = "@@@" */
    Nap_NAO		*naoResult[],		/* for result */
    Nap_dataType        *dataType)		/* type of naoResult */
{
    int			d;            		/* subscript (dimension number) */
    Nap_dataType	dataTypeTmp;		/* temporary data type */
    Nap_NAO		*naoTmp;		/* temporary NAO */
    char		*str;

    assert(n >= 0  &&  n <= NAP_MAX_RANK);
    *dataType = NAP_I32;
    for (d = 0; d < n; d++) {
	switch (SubscriptType(naoSub[d])) {
	case -1:
	    naoResult[d] = naoSub[d];
	    break;
	case 0:
	    CHECK2(Nap_TypeIsNumeric(naoSub[d]->dataType),
		     "m4NAME: Subscript has illegal data-type");
	    if (code[d] == 0) {
		dataTypeTmp = Nap_TypeIsInteger(naoSub[d]->dataType) ? NAP_I32 : NAP_F32;
		naoResult[d] = Nap_CastNAO(nap_cd, naoSub[d], dataTypeTmp);
	    } else {
		CHECK3(cv[d], "m4NAME: no coordinate variable for dimension %d", d);
		assert(Nap_IsNAO(nap_cd, cv[d]));
		switch (code[d]) {
		    case 1:
			str = Nap_IndexOf2(nap_cd, cv[d]->id, naoSub[d]->id);
			CHECK2(str, "m4NAME: Unary @ error");
			break;
		    case 2:
			str = Nap_Closest(nap_cd, cv[d]->id, naoSub[d]->id);
			CHECK2(str, "m4NAME: Unary @@ error");
			break;
		    case 3:
			str = Nap_Match(nap_cd, cv[d]->id, naoSub[d]->id);
			CHECK2(str, "m4NAME: Unary @@@ error");
			break;
		    default:            /* error */
			CHECK2(FALSE, "m4NAME: NAO linked to subscript has illegal value");
			assert(FALSE);
		}
		naoResult[d] = Nap_GetNumericNaoFromId(nap_cd, str);
	    }
	    CHECK(naoResult[d]);
	    Nap_IncrRefCount(nap_cd, naoResult[d]);
	    if (naoResult[d]->dataType == NAP_F32) {
		*dataType = NAP_F32;
	    }
	    break;
	case 1:
	    naoResult[d] = NULL;
	    break;
	default:	/* error */
	    assert(0);
	}
    }
    for (d = 0; d < n; d++) {
	switch (SubscriptType(naoSub[d])) {
	case 0:
	    naoTmp = naoResult[d];
	    if (naoTmp) {
		naoResult[d] = Nap_CastNAO(nap_cd, naoTmp, *dataType);
		assert(naoResult[d]);
		Nap_IncrRefCount(nap_cd, naoResult[d]);
		Nap_DecrRefCount(nap_cd, naoTmp);
	    }
	}
    }
    assert(*dataType == NAP_I32  ||  *dataType == NAP_F32);
    return TCL_OK;
}

/*
 *  Nap_ReverseVector --
 */

m4begin

m4define(`m4NAME', `Nap_ReverseVector')

#       reverse vector: m4rv(dataType)
m4define(`m4rv', `
	    case m4DataTypeEnum($1):
		for (i = 0; i < n; i++) {
		    naoResult->data.$1[i] = naoArray->data.$1[n-i-1];
		}
		break;')

m4end

static int
Nap_ReverseVector(
    NapClientData       *nap_cd,
    Nap_NAO		*naoArray,		/* vector array (left operand) */
    Nap_NAO		**naoResultPtr)		/* for final result */
{
    size_t              i;			/* subscript (element number) */
    size_t              n;			/* # elements */
    Nap_NAO		*naoResult;		/* for final result */
    Nap_NAO		*newCV; 		/* new coordinate variable */
    Nap_NAO		*oldCV; 		/* old coordinate variable */
    int			status;

    if (naoArray) {
	assert(naoArray->rank == 1);
	n = naoArray->nels;
	naoResult = Nap_DupNAO(nap_cd, naoArray);
	naoResult->step = NAP_STEP_UNKNOWN;
	oldCV = Nap_GetCoordVar(nap_cd, naoArray, 0);
	if (oldCV) {
	    status = Nap_ReverseVector(nap_cd, oldCV, &newCV);
	    CHECK(status == TCL_OK);
	    status = Nap_AttachCV(nap_cd, naoResult, newCV, 0);
	    CHECK(status == TCL_OK);
	}
	switch (naoResult->dataType) {
	m4ForAllDataType(`m4rv(', `)')
	default:            /* error */
	    assert(FALSE);
	}
    } else {
	naoResult = NULL;
    }
    *naoResultPtr = naoResult;
    return TCL_OK;
}

/*
 *  Nap_SubscriptCrossProduct --
 *
 *  Subscript which is boxed
 *  This is normally created using one or more ',' operators
 *  i.e expression with form (vs, vs, ...) where each vs is vector or scalar
 *
 *  Effective subscript is cross-product of these vs values
 *  E.g. matrix({1 3},{5 2}) is equivalent to matrix({{{1 5}{1 2}}{{3 5}{3 2}}})
 */

m4begin

m4define(`m4NAME', `Nap_SubscriptCrossProduct')

#       set result elements to missing value: m4missing(dataTypeResult)
m4define(`m4missing', `
	    case m4DataTypeEnum($1):
		for (i = 0; i < naoResult->nels; i++) {
		    naoResult->data.$1[i] = mv_nao->data.$1[0];
		}
		break;')

m4end

static int
Nap_SubscriptCrossProduct(
    NapClientData       *nap_cd,
    Nap_NAO		*naoArray,		/* array (left operand) */
    Nap_NAO		*naoSub,		/* boxed subscript (right operand) */
    Nap_NAO		**naoResultPtr)		/* for final result */
{
    Nap_i8		code[NAP_MAX_RANK];	/* 0 = direct, 1 = "@", 2 = "@@", 3 = "@@@" */
    int			d;            		/* subscript (dimension number) */
    Nap_dataType	dataType;
    char		*dimName[NAP_MAX_RANK]; /* new dimension names */
    int			i;            		/* subscript of result data */
    Nap_NAO		*linkNao=NULL;		/* Used to indicate indirect indexing */
    float		mv;			/* missing value */
    Nap_NAO		*mv_nao;		/* missing value NAO */
    int			n;			/* naoSub->nels (= naoArray->rank) */
    Nap_NAO		*naoResult;		/* for final result */
    Nap_NAO		*naoSubNewEl[NAP_MAX_RANK]; /* element of new subscript */
    Nap_NAO		*naoSubOldEl[NAP_MAX_RANK]; /* element of old subscript naoSub */
    Nap_NAO		*naoTmp;		/* temporary NAO */
    Nap_NAO		*newCV[NAP_MAX_RANK]; 	/* new coordinate variable */
    Nap_NAO		*oldCV[NAP_MAX_RANK]; 	/* old coordinate variable */
    float		*pF32;			/* temporary pointer */
    size_t              prodShape[NAP_MAX_RANK+1]; /* # bytes in each slab */
    int			rank;
    size_t              shape[NAP_MAX_RANK];
    int			status;
    char                *str;            	/* temporary pointer to string */
    float		subscript[NAP_MAX_RANK]; /* subscript vector */

    n = naoSub->nels;
    CHECK2(n == naoArray->rank,
	    "m4NAME: # boxed subscripts differs from rank of array operand");
    for (d = 0; d < n; d++) {
	newCV[d] = NULL;
	code[d] = 0;
	oldCV[d] = Nap_GetCoordVar(nap_cd, naoArray, d);
	subscript[d] = -1.0;
	naoSubOldEl[d] = Nap_GetNaoFromSlot(naoSub->data.Boxed[d]);
	if (naoSubOldEl[d]) {
	    linkNao = Nap_GetNaoFromSlot(naoSubOldEl[d]->linkSlot);
	    if (linkNao) {
		switch (linkNao->rank) {
		    case 0:
			naoTmp = Nap_CastNAO(nap_cd, linkNao, NAP_I8);
			Nap_IncrRefCount(nap_cd, naoTmp);
			code[d] = naoTmp->data.I8[0];
			Nap_DecrRefCount(nap_cd, naoTmp);
			break;
		    case 1:
			newCV[d] = linkNao;
			if (oldCV[d]  &&  oldCV[d]->unit  &&  !newCV[d]->unit) {
			    newCV[d]->unit = Nap_StrDup(nap_cd, oldCV[d]->unit);
			}
			break;
		}
	    }
	}
    }
    status = Nap_SubscriptIndirect(nap_cd, n, oldCV, naoSubOldEl, code, naoSubNewEl, &dataType);
    CHECK(status == TCL_OK);
    if (naoArray->dataType == NAP_C8  &&  dataType == NAP_F32) {
	dataType = NAP_I32;
	for (d = 0; d < n; d++) {
	    if (naoSubNewEl[d]) {
		naoTmp = naoSubNewEl[d];
		naoSubNewEl[d] = Nap_CastNAO(nap_cd, naoTmp, dataType);
		CHECK2(naoSubNewEl[d], "m4NAME: Error calling Nap_CastNAO");
		Nap_IncrRefCount(nap_cd, naoSubNewEl[d]);
		Nap_DecrRefCount(nap_cd, naoTmp);
	    }
	}
    }
    rank = 0;
    for (d = 0; d < n; d++) {
	switch (SubscriptType(naoSubNewEl[d])) {
	case -1:
	    shape[rank] = naoArray->shape[d];
	    dimName[rank] = naoArray->dimName[d];
	    status = Nap_ReverseVector(nap_cd, oldCV[d], newCV+rank);
	    CHECK(status == TCL_OK);
	    ++rank;
	    break;
	case 0:
	    CHECK2(naoSubNewEl[d]->rank < 2, "m4NAME: Rank of boxed subscript > 1");
	    if (naoSubNewEl[d]->rank > 0) {
		shape[rank] = naoSubNewEl[d]->nels;
		dimName[rank] = naoArray->dimName[d];
		if (!newCV[rank]) {
		    if (naoSubOldEl[d]  &&  naoSubOldEl[d]->rank == 1  &&  code[d] > 0) {
			newCV[rank] = Nap_DupNAO(nap_cd, naoSubOldEl[d]);
			naoTmp = Nap_GetCoordVar(nap_cd, naoArray, d);
			NAP_FREE(nap_cd, newCV[rank]->unit);
			newCV[rank]->unit = Nap_StrDup(nap_cd, naoTmp ? naoTmp->unit : NULL);
		    } else if (naoArray->boxedCV) {
			naoTmp = Nap_GetCoordVar(nap_cd, naoArray, d);
			if (naoTmp) {
			    str = Nap_Index(nap_cd, naoTmp->id, naoSubNewEl[d]->id);
			    CHECK2(str, "m4NAME: Error calling Nap_Index");
			    newCV[rank] = Nap_GetNumericNaoFromId(nap_cd, str);
			} else {
			    newCV[rank] = NULL;
			}
		    }
		}
		++rank;
	    }
	    break;
	case 1:
	    shape[rank] = naoArray->shape[d];
	    dimName[rank] = naoArray->dimName[d];
	    newCV[rank] = oldCV[d];
	    ++rank;
	    break;
	default:	/* error */
	    assert(0);
	}
    }
    if (dataType == NAP_I32) {
	naoResult = Nap_NewNAO(nap_cd, naoArray->dataType, rank, shape);
	CHECK2(naoResult, "m4NAME: Error calling Nap_NewNAO");
	status = Nap_SetMissing(nap_cd, naoResult, naoArray->missingValueSlot);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	mv_nao = Nap_GetMissingValueNAO(nap_cd, naoResult);
	CHECK2(mv_nao, "m4NAME: Error calling Nap_GetMissingValueNAO");
	d = n;
	prodShape[d] = Nap_SizeOf(naoArray->dataType);
	while (--d >= 0) {
	    prodShape[d] = naoArray->shape[d] * prodShape[d+1];
	}
	if (prodShape[0] == 0) {
	    switch (naoResult->dataType) {
	    m4ForAllNumericDataType(`m4missing(', `)')
	    default:            /* error */
		assert(FALSE);
	    }
	} else {
	    str = naoResult->data.c;
	    status = Nap_SubscriptCopy(nap_cd, n, prodShape, naoSubNewEl, mv_nao->data.c,
		    FALSE, naoArray->data.c, &str);
	    CHECK(status == TCL_OK);
	}
    } else {
	naoResult = Nap_NewNAO(nap_cd, NAP_F32, rank, shape);
	CHECK2(naoResult, "m4NAME: Error calling Nap_NewNAO");
	if (naoResult->dataType == naoArray->dataType) {
	    status = Nap_SetMissing(nap_cd, naoResult, naoArray->missingValueSlot);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	}
	naoTmp = Nap_CastNAO(nap_cd, naoArray, NAP_F32);
	CHECK2(naoTmp, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, naoTmp);
	mv = Nap_GetF64MissingValue(nap_cd, naoResult->slot);
	pF32 = naoResult->data.F32;
	status = Nap_SubscriptInterp(nap_cd, n, naoTmp->shape, 0, naoSubNewEl,
		subscript, FALSE, naoTmp->data.F32, mv, &pF32);
	CHECK(status == TCL_OK);
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    for (d = 0; d < naoResult->rank; d++) {
	status = Nap_AttachCoordVar(nap_cd, naoResult, newCV[d], dimName[d], d);
	CHECK(status == TCL_OK);
    }
    for (d = 0; d < n; d++) {
	Nap_DecrRefCount(nap_cd, naoSubNewEl[d]);
    }
    NAP_FREE(nap_cd, naoResult->unit);
    naoResult->unit = Nap_StrDup(nap_cd, naoArray->unit);
    *naoResultPtr = naoResult;
    return TCL_OK;
}

/*
 *  Nap_SubscriptFull --
 *
 *  Subscript (not boxed) with separate indices for every element of result
 *  rank(array) > 1
 */

m4begin

m4define(`m4NAME', `Nap_SubscriptFull')

#       array (rank > 1) subscripted by i32 array: m4a_ia(dataTypeResult)
m4define(`m4a_ia', `
	    case m4DataTypeEnum($1):
		if (prodShape[0] == 0) {
		    for (i = 0; i < naoResult->nels; i++) {
			naoResult->data.$1[i] = mv_nao->data.$1[0];
		    }
		} else {
		    for (i = 0; i < naoResult->nels; i++) {
			for (j = d = 0; d < naoArray->rank; d++) {
			    if (IsMissing(naoIndex[d], i)) {
				j = -1;
				break;
			    } else {
				j += prodShape[d] * Nap_lmod(naoIndex[d]->data.I32[i],
					naoArray->shape[d]);
			    }
			}
			naoResult->data.$1[i] = j < 0 ? mv_nao->data.$1[0] : naoArray->data.$1[j];
		    }
		}
		break;')

m4end

static int
Nap_SubscriptFull(
    NapClientData       *nap_cd,
    Nap_NAO		*naoArray,		/* array (left operand) */
    Nap_NAO		*naoSub,		/* subscript (right operand) */
    Nap_NAO		**naoResultPtr)		/* for final result */
{
    Nap_i8		code[NAP_MAX_RANK];	/* 0 = direct, 1 = "@", 2 = "@@", 3 = "@@@" */
    int			d;            		/* subscript (dimension number) */
    Nap_dataType        dataType;
    size_t              i;			/* subscript (element number) */
    int			j;			/* subscript */
    Nap_NAO		*linkNao=NULL;		/* Used to indicate indirect indexing */
    float		mv;			/* missing value */
    Nap_NAO		*mv_nao;		/* missing value NAO */
    int			n;			/* naoArray->rank */
    Nap_NAO		*naoCol[NAP_MAX_RANK];	/* column of naoSub (treated as matrix) */
    Nap_NAO		*naoIndex[NAP_MAX_RANK]; /* subscript values for each dimension */
    Nap_NAO		*naoResult;		/* for final result */
    Nap_NAO		*naoTmp;		/* temporary NAO */
    Nap_NAO		*oldCV[NAP_MAX_RANK]; 	/* old coordinate variable */
    size_t              prodShape[NAP_MAX_RANK+1]; /* # bytes in each slab */
    int			s;			/* size of data type */
    size_t              shape[1];
    int			status;
    float		subscript[NAP_MAX_RANK]; /* subscript vector */

    assert(naoArray);
    assert(naoSub);
    n = naoArray->rank;
    assert(n > 1);
    CHECK2(naoSub->rank > 0, "m4NAME: Scalar subscript");
    for (j = 0; j < n; j++) {
	oldCV[j] = Nap_GetCoordVar(nap_cd, naoArray, j);
    }
    linkNao = Nap_GetNaoFromSlot(naoSub->linkSlot);
    if (linkNao) {
	naoTmp = Nap_CastNAO(nap_cd, linkNao, NAP_I8);
	Nap_IncrRefCount(nap_cd, naoTmp);
	CHECK2(naoTmp->rank <= 1, "m4NAME: Subscript link-nao has rank > 1");
	CHECK2(naoTmp->nels > 0, "m4NAME: Subscript link-nao is empty");
	for (d = 0; d < n; d++) {
	    code[d] = naoTmp->data.I8[d % naoTmp->nels];
	}
	Nap_DecrRefCount(nap_cd, naoTmp);
    } else {
	for (d = 0; d < n; d++) {
	    code[d] = 0;
	}
    }
    s = Nap_SizeOf(naoSub->dataType);
    shape[0] = naoSub->nels / n;
    for (d = 0; d < n; d++) {
	naoCol[d] = Nap_NewNAO(nap_cd, naoSub->dataType, 1, shape);
	CHECK2(naoCol[d], "m4NAME: Error calling Nap_NewNAO");
	Nap_IncrRefCount(nap_cd, naoCol[d]);
	for (j = 0; j < naoCol[d]->nels; j++) {
	    memcpy(naoCol[d]->data.c+s*j, naoSub->data.c+s*(d+n*j), s);
	}
    }
    status = Nap_SubscriptIndirect(nap_cd, n, oldCV, naoCol, code, naoIndex, &dataType);
    CHECK(status == TCL_OK);
    for (d = 0; d < n; d++) {
	Nap_DecrRefCount(nap_cd, naoCol[d]);
    }
    dataType = Nap_TypeIsInteger(dataType) ? naoArray->dataType : NAP_F32;
    naoResult = Nap_NewNAO(nap_cd, dataType, naoSub->rank - 1, naoSub->shape);
    CHECK2(naoResult, "m4NAME: Error calling Nap_NewNAO");
    status = Nap_CopyDims(nap_cd, naoSub, naoResult);
    CHECK(status == TCL_OK);
    if (dataType == naoArray->dataType) {
	status = Nap_SetMissing(nap_cd, naoResult, naoArray->missingValueSlot);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
    }
    NAP_FREE(nap_cd, naoResult->unit);
    naoResult->unit = Nap_StrDup(nap_cd, naoArray->unit);
    if (Nap_TypeIsInteger(naoIndex[0]->dataType)) {
	mv_nao = Nap_GetMissingValueNAO(nap_cd, naoResult);
	CHECK2(mv_nao, "m4NAME: Error calling Nap_GetMissingValueNAO");
	j = n - 1;
	prodShape[j] = 1;
	while (--j >= 0) {
	    prodShape[j] = naoArray->shape[j+1] * prodShape[j+1];
	}
	switch (naoResult->dataType) {
	m4ForAllNumericDataType(`m4a_ia(', `)')
	default:            /* error */
	    assert(FALSE);
	}
    } else {
	naoTmp = Nap_CastNAO(nap_cd, naoArray, NAP_F32);
	CHECK2(naoTmp, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, naoTmp);
	mv = Nap_GetF64MissingValue(nap_cd, naoResult->slot);
	for (i = 0; i < naoResult->nels; i++) {
	    for (d = 0; d < n; d++) {
		subscript[d] = naoIndex[d]->data.F32[i];
	    }
	    status = Nap_MultiLinearInterp(
		    nap_cd,
		    naoTmp->data.F32,
		    naoTmp->rank,
		    naoTmp->shape,
		    subscript,
		    mv,
		    naoResult->data.F32 + i);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_MultiLinearInterp");
	}
	assert(naoTmp);
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    for (d = 0; d < n; d++) {
	Nap_DecrRefCount(nap_cd, naoIndex[d]);
    }
    *naoResultPtr = naoResult;
    return TCL_OK;
}

/*
 *  Nap_SubscriptOfVector --
 */

m4begin

m4define(`m4NAME', `Nap_SubscriptOfVector')

#       vector subscripted by int array: m4v_ia2(dataTypeResult,dataTypeSub)
m4define(`m4v_ia2', `
		case m4DataTypeEnum($2):
		    if (modulus == 0) {
			for (i = 0; i < naoResult->nels; i++) {
			    naoResult->data.$1[i] = mv_nao->data.$1[0];
			}
		    } else {
			for (i = 0; i < naoResult->nels; i++) {
			    if (IsMissing(naoSubNew, i)) {
				naoResult->data.$1[i] = mv_nao->data.$1[0];
			    } else {
				j = Nap_lmod(naoSubNew->data.$2[i], modulus);
				naoResult->data.$1[i] = naoArray->data.$1[j];
			    }
			}
		    }
		    break;')

#       vector subscripted by int array: m4v_ia(dataTypeResult)
m4define(`m4v_ia', `
	    case m4DataTypeEnum($1):
		switch (naoSubNew->dataType) {
		    m4ForAllIntegerDataType(`m4v_ia2($1,', `)')
		default:            /* error */
		    assert(FALSE);
		}
		break;')

m4end

static int
Nap_SubscriptOfVector(
    NapClientData       *nap_cd,
    Nap_NAO		*naoArray,		/* vector array (left operand) */
    Nap_NAO		*naoSub,		/* subscript (right operand) */
    Nap_NAO		**naoResultPtr)		/* for final result */
{
    Nap_i8		code[1];		/* 0 = direct, 1 = "@", 2 = "@@", 3 = "@@@" */
    Nap_dataType        dataType;
    size_t              i;			/* subscript (element number) */
    int			j;			/* subscript */
    size_t              k;			/* increment */
    Nap_NAO		*linkNao;		/* Used to indicate indirect indexing */
    long		modulus;		/* divisor for subscripts */
    float		mv;			/* missing value */
    Nap_NAO		*mv_nao;		/* missing value NAO */
    Nap_NAO		*naoResult;		/* for final result */
    Nap_NAO		*naoSubPtr[1];		/* = naoSub */
    Nap_NAO		*naoSubNew;		/* new subscript */
    Nap_NAO		*naoSubNewPtr[1];	/* = naoSubNew */
    Nap_NAO		*naoTmp;		/* temporary NAO */
    Nap_NAO		*newCV; 		/* new coordinate variable */
    Nap_NAO		*oldCV[1]; 		/* old coordinate variable */
    int			rank;
    int			status;
    char		*str;

    assert(naoArray);
    assert(naoSub);
    assert(naoArray->rank == 1);
    naoSubPtr[0] = naoSub;
    oldCV[0] = Nap_GetCoordVar(nap_cd, naoArray, 0);
    code[0] = 0;
    newCV = NULL;
    linkNao = Nap_GetNaoFromSlot(naoSub->linkSlot);
    if (linkNao) {
	switch (linkNao->rank) {
	    case 0:
		naoTmp = Nap_CastNAO(nap_cd, linkNao, NAP_I8);
		Nap_IncrRefCount(nap_cd, naoTmp);
		code[0] = naoTmp->data.I8[0];
		Nap_DecrRefCount(nap_cd, naoTmp);
		break;
	    case 1:
		newCV = linkNao;
		if (oldCV[0]  &&  oldCV[0]->unit  &&  !newCV->unit) {
		    newCV->unit = Nap_StrDup(nap_cd, oldCV[0]->unit);
		}
		break;
	}
    }
    if (code[0] > 0) {
	status = Nap_SubscriptIndirect(nap_cd, 1, oldCV, naoSubPtr, code, naoSubNewPtr,
		&dataType);
	CHECK(status == TCL_OK);
	naoSubNew = naoSubNewPtr[0];
    } else {
	naoSubNew = naoSub;
	Nap_IncrRefCount(nap_cd, naoSubNew);
    }
    rank = naoSubNew->rank;
    dataType = Nap_TypeIsInteger(naoSubNew->dataType) ? naoArray->dataType : NAP_F32;
    naoResult = Nap_NewNAO(nap_cd, dataType, rank, naoSub->shape);
    CHECK2(naoResult, "m4NAME: Error calling Nap_NewNAO");
    status = Nap_CopyDims(nap_cd, naoSub, naoResult);
    CHECK(status == TCL_OK);
    if (dataType == naoArray->dataType) {
	status = Nap_SetMissing(nap_cd, naoResult, naoArray->missingValueSlot);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
    }
    NAP_FREE(nap_cd, naoResult->unit);
    naoResult->unit = Nap_StrDup(nap_cd, naoArray->unit);
    if (naoSub->rank == 1) {
	if (!newCV) {
	    if (code[0] > 0) {
		newCV = Nap_DupNAO(nap_cd, naoSub);
		CHECK2(newCV, "m4NAME: Error calling Nap_DupNAO");
		status = Nap_AttachLink(nap_cd, newCV, NULL);
		CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
	    } else if (oldCV[0]) {
		naoTmp = Nap_DupNAO(nap_cd, naoSub);
		CHECK2(naoTmp, "m4NAME: Error calling Nap_DupNAO");
		Nap_IncrRefCount(nap_cd, naoTmp);
		str = Nap_Index(nap_cd, oldCV[0]->id, naoTmp->id);
		CHECK2(str, "m4NAME: Error defining new coord. var");
		newCV = Nap_GetNumericNaoFromId(nap_cd, str);
		CHECK2(newCV, "m4NAME: Error calling Nap_GetNumericNaoFromId");
		Nap_DecrRefCount(nap_cd, naoTmp);
	    }
	}
	if (newCV) {
	    status = Nap_AttachCoordVar(nap_cd, naoResult, newCV, NULL, 0);
	    CHECK(status == TCL_OK);
	}
    }
    if (Nap_TypeIsInteger(naoSubNew->dataType)) {
	mv_nao = Nap_GetMissingValueNAO(nap_cd, naoResult);
	CHECK2(mv_nao, "m4NAME: Error calling Nap_GetMissingValueNAO");
	modulus = naoArray->nels;
	switch (naoResult->dataType) {
	m4ForAllDataType(`m4v_ia(', `)')
	default:            /* error */
	    assert(FALSE);
	}
    } else {
	naoTmp = naoSubNew;
	naoSubNew = Nap_CastNAO(nap_cd, naoTmp, NAP_F32);
	CHECK2(naoSubNew, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, naoSubNew);
	Nap_DecrRefCount(nap_cd, naoTmp);
	naoTmp = Nap_CastNAO(nap_cd, naoArray, NAP_F32);
	CHECK2(naoTmp, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, naoTmp);
	mv = Nap_GetF64MissingValue(nap_cd, naoResult->slot);
	k = naoResult->nels == 0 ? 1 : naoSubNew->nels / naoResult->nels;
	for (i = 0; i < naoResult->nels; i++) {
	    status = Nap_MultiLinearInterp(
		    nap_cd,
		    naoTmp->data.F32,
		    naoTmp->rank,
		    naoTmp->shape,
		    naoSubNew->data.F32 + i * k,
		    mv,
		    naoResult->data.F32 + i);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_MultiLinearInterp");
	}
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    Nap_DecrRefCount(nap_cd, naoSubNew);
    *naoResultPtr = naoResult;
    return TCL_OK;
}

/*
 *  Nap_Subscript --
 *      Operation represented by nap notation '<array><subscript>'
 *	where <array> is <var_name>, <nao_ID>, {array_constant} or (<expr>)
 *	and <subscript> is (<expr>) or {array_constant}.
 *
 *	If <array>  & <subscript> both type character then treat as <array> // <subscript>.
 *	If <subscript> (but not <array>) is type character then treat <subscript> as unit.
 *
 *	Examples
 *	    <var_name>(<expr>):			abc(3)
 *	    <nao_ID>(<expr>):			nao.7(3,4)
 *	    {array_constant}{array_constant}	{2 9 -1}{0.5 -1 3 0}
 *	    (<expr>)(<expr>):			(abc+3)(3)
 *	    <string><string>:			'hello' ' world'
 *	    (<expr>)(<string>):			3 'metres'
 *
 *	Subscript origin is 0.
 *
 *	Data-type of result is same as that of array operand if either:
 *	- subscript has an integer or character data-type
 *	- subscript is boxed array containing only integer arrays
 *	- or array operand has a floating-point type.
 *	Otherwise data-type of result is min. floating-point type (f32).
 *
 *	Subscript values can be fractional, giving linear interpolation.
 *	E.g. {3 6}(0.5) gives 4.5.
 *	If S is size of dimension then subscript values are treated modulus S.
 *	In particular value(-1) is final value i.e. same as value(S-1).
 *      Subscript values between S-1 and S interpolate between value(S-1) and value(0).
 *	E.g. {3 6 5}(2.5) gives 4.
 *
 *	If V is vector & B is any numeric array then V(B) has shape of B.
 *
 *	If A is an array with rank > 1 & B is boxed vector of rank(A) numeric scalars/vectors
 *	then result A(B) has shape defined by concatenating shapes of these scalars/vectors.  
 *	This is called "cross-product subscripting".
 *	E.g. if M is matrix then:
 *	    M(5,1) defines a scalar
 *	    M({3 5},2) defines a vector with 2 elements
 *	    M({3 5},{2 0 1}) defines a matrix with 2 rows and 3 columns
 *
 *	If A is an array with rank > 1 & B is not boxed then final dimension of B must equal
 *	rank of A.  Shape of result A(B) is shape of B with final dimension omitted.  i.e.
 *	shape(B))(-1) == rank(A)
 *	shape(A(B)) == (shape(B))(0 .. (rank(B) - 2))
 *	This is called "full subscripting" because the subscript contains separate indices for
 *	every element of the result
 *	E.g. if M is matrix then:
 *	    M{5 1} defines a scalar (same as M(5,1))
 *	    M{{5 1}{0 0}} defines a 2-element vector (same as M(5,1) // M(0,0))
 *
 *	Indirect subscripting was previously indicated by link-nao attached to subscript
 *	(or subscript element in case of cross-product).
 *	This link-nao contained following integer values:
 *	0 = direct
 *	1 = @
 *	2 = @@
 *	3 = @@@
 *
 *	Note that the monadic (unary) operators "@", "@@" & "@@@" previousply generated such
 *	link-naos.
 *	Examples
 *	    vector(@3.5) which is equivalent to vector(coordinate_variable(vector,0)@3.5)
 *	    matrix(1,@@3.5) which is equivalent to matrix(1,coordinate_variable(matrix,1)@3.5)
 *
 *	The arguments of @, @@ & @@@ are used as new coordinate variables where relevant.
 *
 *	Function invert_grid() also generates result with link-nao. This result is 1D or 2D
 *	full subscript with corresponding 1D link-nao containing 1 or 2 elements respectively.
 *
 *	Only support single value for each dimension -- could allow each element of vector/full
 *	subscript to have separate value (with spreading to required rank)
 *
 *	Note that these three @ operators could previously only be used at the start of an
 *	index. Expressions such as "vector(1+(@3.5))" were illegal but are now allowed.
 */

m4define(`m4NAME', `Nap_Subscript')

EXTERN char *
Nap_Subscript(
    NapClientData	*nap_cd,
    char		*str1,		/* name of array */
    char		*str2)		/* boxed subscript */
{
    int			j;
    Nap_NAO		*naoArray;	/* array (left operand) */
    Nap_NAO		*naoSub;	/* boxed subscript (right operand) */
    Nap_NAO		*naoSubEl;	/* subscript */
    Nap_NAO		*naoResult;	/* for final result */
    Nap_NAO		*naoTmp;	/* temporary NAO */
    Nap_dataType        resultDataType;
    int			status;
    char		*str;

    naoArray = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoArray, "m4NAME: Undefined array operand");
    Nap_IncrRefCount(nap_cd, naoArray);
    naoSub = Nap_GetNaoFromId(nap_cd, str2);
    CHECK2NULL(naoSub, "m4NAME: Undefined subscript operand");
    CHECK2NULL(naoSub->dataType == NAP_BOXED, "m4NAME: Subscript operand should be boxed");
    CHECK2NULL(naoSub->rank == 1, "m4NAME: Rank of boxed subscript operand not 1");
    Nap_IncrRefCount(nap_cd, naoSub);
    CHECK2NULL(naoSub->nels > 0, "m4NAME: empty subscript");
    if (naoSub->nels == 1) {
	naoSubEl = Nap_GetNaoFromSlot(naoSub->data.Boxed[0]);
	CHECK2NULL(naoSubEl, "m4NAME: Error calling Nap_GetNaoFromSlot");
	Nap_IncrRefCount(nap_cd, naoSubEl);
	CHECK2NULL(naoArray->rank > 0  ||  naoSubEl->dataType == NAP_C8,
		"m4NAME: array operand is scalar");
	if (naoSubEl->dataType == NAP_RAGGED) {
	    naoTmp = Nap_GetNumericNaoFromId(nap_cd, naoSubEl->id);
	    CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_GetNumericNaoFromId");
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoSubEl);
	    naoSubEl = naoTmp;
	}
	if (naoArray->dataType == NAP_C8  &&  Nap_IsReal(naoSubEl)) {
	    naoTmp = Nap_CastNAO(nap_cd, naoSubEl, NAP_I32);
	    CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoSubEl);
	    naoSubEl = naoTmp;
	}
	if (naoSubEl->dataType == NAP_C8) {
	    if (naoArray->dataType == NAP_C8) {
		str = Nap_Cat(nap_cd, naoArray->id, naoSubEl->id);
		naoResult = Nap_GetNumericNaoFromId(nap_cd, str);
		CHECK1NULL(naoResult);
	    } else {
		resultDataType = Nap_DataType2(naoArray->dataType, NAP_F32);
		if (resultDataType == naoArray->dataType) {
		    naoResult = Nap_DupNAO(nap_cd, naoArray);
		    CHECK2NULL(naoResult, "m4NAME: Error calling Nap_DupNAO");
		} else {
		    naoResult = Nap_CastNAO(nap_cd, naoArray, resultDataType);
		    CHECK2NULL(naoResult, "m4NAME: Error calling Nap_CastNAO");
		}
	    }
	} else if (naoArray->rank == 1) {
	    switch (SubscriptType(naoSubEl)) {
	    case -1:
		status = Nap_ReverseVector(nap_cd, naoArray, &naoResult);
		CHECK1NULL(status == TCL_OK);
		break;
	    case 0:
		status = Nap_SubscriptOfVector(nap_cd, naoArray, naoSubEl, &naoResult);
		CHECK1NULL(status == TCL_OK);
		break;
	    case 1:
		naoResult = naoArray;
		break;
	    default:		/* error */
		assert(0);
	    }
	} else {
	    status = Nap_SubscriptFull(nap_cd, naoArray, naoSubEl, &naoResult);
	    CHECK1NULL(status == TCL_OK);
	}
	Nap_DecrRefCount(nap_cd, naoSubEl);
    } else {
	status = Nap_SubscriptCrossProduct(nap_cd, naoArray, naoSub, &naoResult);
	CHECK1NULL(status == TCL_OK);
    }
    assert(naoResult);
    if (naoResult->dataType == NAP_BOXED) {
	for (j = 0; j < naoResult->nels; j++) {
	    naoTmp = Nap_GetNaoFromSlot(naoResult->data.Boxed[j]);
	    if (naoTmp) {
		Nap_IncrRefCount(nap_cd, naoTmp);
	    }
	}
    }
    assert(naoArray);
    assert(naoSub);
    Nap_DecrRefCount(nap_cd, naoSub);
    if (naoResult == naoArray) {
	--(naoArray->count);
    } else {
	Nap_DecrRefCount(nap_cd, naoArray);
    }
    assert(naoResult->id);
    assert(Nap_IsNAO(nap_cd, naoResult));
    return naoResult->id;
}

/*
 * Nap_Index --
 *
 * Indexing (subscripting)
 */

m4define(`m4NAME', `Nap_Index')

EXTERN char *
Nap_Index(
    NapClientData	*nap_cd, 
    char		*str1,		/* base array */
    char		*str2)		/* name/nao-ID of subscript/argument */
{
    Nap_NAO		*boxed;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    char		*result = NULL;	/* NAO ID to be returned */
    size_t		shape[] = {1};
    int			status;
    Nap_NAO		*result_NAO;

    naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
    if (naoPtr2) {
	if (naoPtr2->dataType == NAP_BOXED  &&  naoPtr2->rank == 1) {
	    boxed = naoPtr2;
	} else {
	    boxed = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
	    CHECK2NULL(boxed, "m4NAME: Error calling Nap_NewNAO");
	    boxed->data.Boxed[0] = naoPtr2->slot;
	    Nap_IncrRefCount(nap_cd, naoPtr2);
	}
	Nap_IncrRefCount(nap_cd, boxed);
    } else {
	boxed = NULL;
    }
    CHECK2NULL(str1, "m4NAME: Left argument is NULL");
    str1 = Nap_StrDup(nap_cd, str1);
    assert(str1);
    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK3NULL(naoPtr1, "m4NAME: Left argument is unknown NAO ID %s", str1);
    if (boxed) {
	result = Nap_Subscript(nap_cd, naoPtr1->id, boxed->id);
    } else {
	result = naoPtr1->id;
    }
    CHECK3NULL(result, "m4NAME: Undefined result for sub-array %s()", str1);
    assert(naoPtr1);
    NAP_FREE(nap_cd, str1);
    result_NAO = Nap_GetNaoFromId(nap_cd, result);
    CHECK2NULL(result_NAO, "m4NAME: Error calling Nap_GetNaoFromId");
    Nap_IncrRefCount(nap_cd, result_NAO);
    if (boxed) {
	Nap_DecrRefCount(nap_cd, boxed);
    }
    --result_NAO->count;
    return result;
}

/*
 *  Nap_Copy --
 *      Operation represented by nap notation 'x # y'
 */

m4define(`m4NAME', `Nap_Copy')

EXTERN char *
Nap_Copy(
    NapClientData	*nap_cd,
    char		*str1,		/* number of copies required */
    char		*str2)		/* array */
{
    Nap_NAO		*boxed;			/* boxed left operand */
    Nap_NAO		*boxedElement;		/* element of boxed */
    int			i;			/* subscript */
    char		*id;			/* nao id field */
    int			j;			/* subscript */
    int			k;			/* subscript */
    int			m;			/* subscript */
    int			n;			/* number of copies */
    Nap_NAO		*nao1;			/* raw left operand */
    Nap_NAO		*nao2;			/* right operand */
    Nap_NAO		*nao2old;		/* raw right operand */
    size_t              shape[1];
    Nap_NAO		*subscript;		/* arg for Nap_Subscript */
    Nap_NAO		*subscriptElement;	/* element of subscript */
    Nap_NAO		*tmpNAO;		/* temporary NAO */

    nao1 = Nap_GetNaoFromId(nap_cd, str1);
    CHECK2NULL(nao1, "m4NAME: Undefined left operand");
    Nap_IncrRefCount(nap_cd, nao1);
    nao2 = nao2old = Nap_GetNumericNaoFromId(nap_cd, str2);
    CHECK2NULL(nao2old, "m4NAME: Undefined right operand");
    Nap_IncrRefCount(nap_cd, nao2old);
    Nap_IncrRefCount(nap_cd, nao2);
    if (nao2->rank == 0) {
	tmpNAO = nao2;
	shape[0] = 1;
	nao2 = Nap_ReshapeNAO(nap_cd, tmpNAO, tmpNAO->dataType, 1, shape);
	Nap_IncrRefCount(nap_cd, nao2);
	Nap_DecrRefCount(nap_cd, tmpNAO);
    }
    if (nao1->dataType == NAP_BOXED) {
	boxed = nao1;
	assert(boxed);
	Nap_IncrRefCount(nap_cd, boxed);
    } else {
	shape[0] = nao2->rank;
	boxed = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
	CHECK2NULL(boxed, "m4NAME: Error calling Nap_NewNAO");
	Nap_IncrRefCount(nap_cd, boxed);
	boxed->data.Boxed[0] = nao1->slot;
	Nap_IncrRefCount(nap_cd, nao1);
	for (j = 1; j < boxed->nels; j++) {
	    boxed->data.Boxed[j] = NAP_BOXED_NULL;
	}
    }
    CHECK2NULL(boxed->rank == 1, "m4NAME: Illegal left operand");
    CHECK2NULL(boxed->nels <= nao2->rank, "m4NAME: Too many dimensions in left operand");
    shape[0] = boxed->nels;
    subscript = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
    Nap_IncrRefCount(nap_cd, subscript);
    for (i = 0; i < boxed->nels; i++) {
	boxedElement = Nap_GetNaoFromSlot(boxed->data.Boxed[i]);
	if (boxedElement) {
	    Nap_IncrRefCount(nap_cd, boxedElement);
	    CHECK2NULL(boxedElement->rank < 2, "m4NAME: Illegal left operand");
	    CHECK2NULL(boxedElement->nels <= nao2->shape[i], "m4NAME: Illegal left operand");
	    shape[0] = boxedElement->nels;
	    tmpNAO = Nap_ReshapeNAO(nap_cd, boxedElement, NAP_I32, 1, shape);
	    CHECK2NULL(tmpNAO, "m4NAME: Error calling Nap_ReshapeNAO");
	    Nap_IncrRefCount(nap_cd, tmpNAO);
	    shape[0] = 0;
	    for (j = 0; j < tmpNAO->nels; j++) {
		n = tmpNAO->data.I32[j];
		CHECK2NULL(n >= 0, "m4NAME: left operand < 0");
		shape[0] += n;
	    }
	    shape[0] += n * (nao2->shape[i] - tmpNAO->nels);
	    subscriptElement = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	    Nap_IncrRefCount(nap_cd, subscriptElement);
	    m = n = 0;
	    for (j = 0; j < nao2->shape[i]; j++) {
		if (j < tmpNAO->nels) {
		    n = tmpNAO->data.I32[j];
		}
		for (k = 0; k < n; k++) {
		    assert(m < subscriptElement->nels);
		    subscriptElement->data.I32[m++] = j;
		}
	    }
	    Nap_DecrRefCount(nap_cd, tmpNAO);
	    Nap_DecrRefCount(nap_cd, boxedElement);
	} else {
	    subscriptElement = NULL;
	}
	subscript->data.Boxed[i] = subscriptElement ? subscriptElement->slot : 0;
    }
    id = Nap_Subscript(nap_cd, nao2->id, subscript->id);
    CHECK2NULL(id, "m4NAME: Error calling Nap_Subscript");
    Nap_DecrRefCount(nap_cd, subscript);
    Nap_DecrRefCount(nap_cd, boxed);
    Nap_DecrRefCount(nap_cd, nao1);
    Nap_DecrRefCount(nap_cd, nao2);
    Nap_DecrRefCount(nap_cd, nao2old);
    return id;
}

/*
 *  Nap_Link2 --
 *	Result is boxed 2-element vector pointing to arg1 & arg2.
 */

m4define(`m4NAME', `Nap_Link2')

EXTERN char *
Nap_Link2(
    NapClientData	*nap_cd,
    char		*str1,
    char		*str2)
{
    size_t              shape[1];
    Nap_NAO		*result;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;

    shape[0] = 2;
    result = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
    naoPtr1 = Nap_GetNaoFromId(nap_cd, str1);
    naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
    result->data.Boxed[0] = naoPtr1 ? naoPtr1->slot : 0;
    result->data.Boxed[1] = naoPtr2 ? naoPtr2->slot : 0;
    Nap_IncrRefCount(nap_cd, naoPtr1);
    Nap_IncrRefCount(nap_cd, naoPtr2);
    return result->id;
}

/*
 *  Nap_Link --
 *	Link two (boxed or unboxed) arguments to produce boxed vector.
 *	Arg1 & arg2 can be NULL.
 *	Boxed argument must be scalar or vector.
 */

m4define(`m4NAME', `Nap_Link')

EXTERN char *
Nap_Link(
    NapClientData	*nap_cd,
    char		*str1,
    char		*str2)
{
    int			isBoxed1;			/* Is arg1 boxed? */
    int			isBoxed2;			/* Is arg2 boxed? */
    int			i;
    int			j;
    size_t              shape[1];
    Nap_NAO		*result;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoTmp;

    naoPtr1 = Nap_GetNaoFromId(nap_cd, str1);
    isBoxed1 = naoPtr1 && naoPtr1->dataType == NAP_BOXED;
    naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
    isBoxed2 = naoPtr2 && naoPtr2->dataType == NAP_BOXED;
    CHECK2NULL(!isBoxed1 || naoPtr1->rank <= 1,
	    "m4NAME: Illegal left-hand operand");
    CHECK2NULL(!isBoxed2 || naoPtr2->rank <= 1,
	    "m4NAME: Illegal right-hand operand");
    shape[0] = (isBoxed1 ? naoPtr1->nels : 1)
	     + (isBoxed2 ? naoPtr2->nels : 1);
    result = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
    i = 0;
    if (isBoxed1) {
	for (j = 0; j < naoPtr1->nels; j++) {
	    result->data.Boxed[i++] = naoPtr1->data.Boxed[j];
	}
    } else {
	result->data.Boxed[i++] = naoPtr1 ? naoPtr1->slot : 0;
    }
    if (isBoxed2) {
	for (j = 0; j < naoPtr2->nels; j++) {
	    result->data.Boxed[i++] = naoPtr2->data.Boxed[j];
	}
    } else {
	result->data.Boxed[i++] = naoPtr2 ? naoPtr2->slot : 0;
    }
    for (i = 0; i < result->nels; i++) {
	naoTmp = Nap_GetNaoFromSlot(result->data.Boxed[i]);
	if (naoTmp) {
	    ++(naoTmp->count);
	}
    }
    Nap_FreeNAO(nap_cd, naoPtr1);
    Nap_FreeNAO(nap_cd, naoPtr2);
    return result->id;
}

/*
 *  Nap_Cat --
 *	Concatenate two arguments (operator '//').
 */

m4define(`m4NAME', `Nap_Cat')

EXTERN char *
Nap_Cat(
    NapClientData	*nap_cd,
    char		*str1,
    char		*str2)
{
    Nap_NAO		*cv1;
    Nap_NAO		*cv2;
    Nap_dataType        dataType;
    int                 i;
    char		*id;			/* ID of new CV */
    Nap_NAO		*result;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoTmp;
    size_t		nbytes1;		/* # bytes in naoPtr1 */
    size_t		nbytes2;		/* # bytes in naoPtr2 */
    int                 rank;
    int                 reshape1;		/* Need to reshape *naoPtr1? */
    int                 reshape2;		/* Need to reshape *naoPtr2? */
    size_t              shape[NAP_MAX_RANK];
    int                 status;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Undefined left-hand operand");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    CHECK2NULL(naoPtr2, "m4NAME: Undefined right-hand operand");
    Nap_IncrRefCount(nap_cd, naoPtr2);
    dataType = Max(naoPtr1->dataType, naoPtr2->dataType);
    rank = Max(1, Max(naoPtr1->rank, naoPtr2->rank));
    reshape1 = naoPtr1->dataType < dataType  ||  naoPtr1->rank < rank;
    reshape2 = naoPtr2->dataType < dataType  ||  naoPtr2->rank < rank;
    for (i = 1; i < rank; i++) {
	shape[i] = Max(	naoPtr1->rank < rank ? 0 : naoPtr1->shape[i],
			naoPtr2->rank < rank ? 0 : naoPtr2->shape[i]);
	reshape1 = reshape1  ||  naoPtr1->shape[i] < shape[i];
	reshape2 = reshape2  ||  naoPtr2->shape[i] < shape[i];
    }
    if (reshape1) {
	shape[0] = naoPtr1->rank < rank ? 1 : naoPtr1->shape[0];
	naoTmp = naoPtr1;
	naoPtr1 = Nap_ReshapeNAO_trailing(nap_cd, naoTmp, dataType, rank, shape);
	CHECK2NULL(naoPtr1, "m4NAME: Error calling Nap_ReshapeNAO_trailing");
	Nap_IncrRefCount(nap_cd, naoPtr1);
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    if (reshape2) {
	shape[0] = naoPtr2->rank < rank ? 1 : naoPtr2->shape[0];
	naoTmp = naoPtr2;
	naoPtr2 = Nap_ReshapeNAO_trailing(nap_cd, naoTmp, dataType, rank, shape);
	CHECK2NULL(naoPtr2, "m4NAME: Error calling Nap_ReshapeNAO_trailing");
	Nap_IncrRefCount(nap_cd, naoPtr2);
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    shape[0] = naoPtr1->shape[0] + naoPtr2->shape[0];
    result = Nap_NewNAO(nap_cd, dataType, rank, shape);
    status = Nap_CopyDims(nap_cd, naoPtr1, result); /* for dims beyond 1st */
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
    status = Nap_CopyDims(nap_cd, naoPtr2, result); /* for dims beyond 1st */
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
    if (naoPtr1->boxedCV  && naoPtr2->boxedCV) {
	cv1 = Nap_GetCoordVar(nap_cd, naoPtr1, 0);
	cv2 = Nap_GetCoordVar(nap_cd, naoPtr2, 0);
	if (cv1 && cv2) {
	    CHECK2NULL(! cv1->boxedCV, "m4NAME: Coordinate variable has coordinate variable");
	    CHECK2NULL(! cv2->boxedCV, "m4NAME: Coordinate variable has coordinate variable");
	    id = Nap_Cat(nap_cd, cv1->id, cv2->id);
	    naoTmp = Nap_GetNumericNaoFromId(nap_cd, id);
	    status = Nap_AttachCoordVar(nap_cd, result, naoTmp, naoPtr1->dimName[0], 0);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	    status = Nap_AttachCoordVar(nap_cd, result, NULL, naoPtr2->dimName[0], 0);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	}
    }
    nbytes1 = Nap_SizeOf(dataType) * naoPtr1->nels;
    nbytes2 = Nap_SizeOf(dataType) * naoPtr2->nels;
    memcpy(result->data.c, naoPtr1->data.c, nbytes1);
    memcpy(result->data.c + nbytes1, naoPtr2->data.c, nbytes2);
    NAP_FREE(nap_cd, result->unit);
    if (naoPtr1->unit) {
	result->unit = Nap_StrDup(nap_cd, naoPtr1->unit);
    } else if (naoPtr2->unit) {
	result->unit = Nap_StrDup(nap_cd, naoPtr2->unit);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return result->id;
}

/*
 *  Nap_Laminate --
 *	Operator '///'
 *	If arguments have same shape then concatenate over new dimension, else
 *	treat as '//'
 */

m4define(`m4NAME', `Nap_Laminate')

EXTERN char *
Nap_Laminate(
    NapClientData	*nap_cd,
    char		*str1,
    char		*str2)
{
    Nap_dataType        dataType;
    int                 i;
    char		*id;
    Nap_NAO		*result;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoTmp;
    size_t		nb;			/* # bytes in naoPtr1 & naoPtr2 */
    int                 rank;
    int                 reshape1;		/* Need to reshape *naoPtr1? */
    int                 reshape2;		/* Need to reshape *naoPtr2? */
    size_t              shape[NAP_MAX_RANK];
    int                 status;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Undefined left-hand operand");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    CHECK2NULL(naoPtr2, "m4NAME: Undefined right-hand operand");
    Nap_IncrRefCount(nap_cd, naoPtr2);
    dataType = Max(naoPtr1->dataType, naoPtr2->dataType);
    rank = Max(naoPtr1->rank, naoPtr2->rank);
    reshape1 = naoPtr1->dataType < dataType  ||  naoPtr1->rank < rank;
    reshape2 = naoPtr2->dataType < dataType  ||  naoPtr2->rank < rank;
    for (i = 0; i < rank; i++) {
	shape[i] = Max(	naoPtr1->rank < rank ? 0 : naoPtr1->shape[i],
			naoPtr2->rank < rank ? 0 : naoPtr2->shape[i]);
	reshape1 = reshape1  ||  naoPtr1->shape[i] < shape[i];
	reshape2 = reshape2  ||  naoPtr2->shape[i] < shape[i];
    }
    if (reshape1) {
	naoTmp = naoPtr1;
	naoPtr1 = Nap_ReshapeNAO_trailing(nap_cd, naoTmp, dataType, rank, shape);
	CHECK2NULL(naoPtr1, "m4NAME: Error calling Nap_ReshapeNAO_trailing");
	Nap_IncrRefCount(nap_cd, naoPtr1);
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    if (reshape2) {
	naoTmp = naoPtr2;
	naoPtr2 = Nap_ReshapeNAO_trailing(nap_cd, naoTmp, dataType, rank, shape);
	CHECK2NULL(naoPtr2, "m4NAME: Error calling Nap_ReshapeNAO_trailing");
	Nap_IncrRefCount(nap_cd, naoPtr2);
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    for (i = rank; i > 0; i--) {
	shape[i] = shape[i-1];
    }
    shape[0] = 2;
    result = Nap_NewNAO(nap_cd, dataType, rank+1, shape);
    CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
    for (i = 0; i < rank; i++) {
	naoTmp = Nap_GetCoordVar(nap_cd, naoPtr1, i);
	status = Nap_AttachCoordVar(nap_cd, result, naoTmp, naoPtr1->dimName[i], i+1);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	naoTmp = Nap_GetCoordVar(nap_cd, naoPtr2, i);
	status = Nap_AttachCoordVar(nap_cd, result, naoTmp, naoPtr2->dimName[i], i+1);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
    }
    result->dimName[0] = NULL;
    status = Nap_AttachCV(nap_cd, result, NULL, 0);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
    nb = Nap_SizeOf(dataType) * naoPtr1->nels;
    assert(nb == Nap_SizeOf(dataType) * naoPtr2->nels);
    memcpy(result->data.c, naoPtr1->data.c, nb);
    memcpy(result->data.c + nb, naoPtr2->data.c, nb);
    id = result->id;
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return id;
}

/*
 *  Nap_IndexOf2 --
 *	This is binary operator '@', which gives interpolated index of arg1
 *	(along its 1st dimension) corresponding to arg2.  Result has type float.
 *	Let rank of arg1 be r.  r > 0.   Let shape of arg1 be s.
 *	Let rank of arg2 be R.  R >= 0.  Let shape of arg2 be S.
 *	s(0) corresponds to dimension to be searched along.
 *	Remaining dimensions s(1 .. (r-1)) are 'common dimensions'.
 *	If r-1 <= R then:
 *	- Must have s(1 .. s(r-1)) == S((R-r+1) .. (R-1)) i.e. matching trailing dims
 *	- Result has shape S.
 *	If r-1 > R then:
 *	- Must have s((r-R) .. s(r-1)) == S i.e. matching trailing dims
 *	- Treat right arg as having shape s(1 .. (r-1)).  This is also shape of result.
 *
 *	If right arg has rank 1 then attach it as link. This will be used as CV by indexing
 *	but will disappear if used for anything else.
 *
 *	Treat longitude arg1 (indicated by unit "degrees_east") as special cyclic case.
 *
 *	Treat latitude  arg1 (indicated by unit "degrees_north") as another special case:
 *	Modify result using: "result >>> 0 <<< (nels(arg1) - 1)"
 */

m4define(`m4NAME', `Nap_IndexOf2')

EXTERN char *
Nap_IndexOf2(
    NapClientData	*nap_cd,
    char                *str1,
    char                *str2)
{
    Nap_dataType        dataType;
    float		delta;
    float		guess;
    size_t		i;
    char		*id;
    int			is_latitude;
    size_t		j;
    size_t		k;
    size_t		m;		/* naoPtr1->nels / s[0] */
    size_t		n;		/* result->nels / m */
    Nap_NAO             *naoPtr1;
    Nap_NAO             *naoPtr2;
    Nap_NAO             *naoTmp;
    int			R;		/* rank of arg2 */
    int			r;		/* rank of arg1 */
    float		range;
    Nap_NAO		*result;
    size_t		S[NAP_MAX_RANK];/* shape of arg2 */
    size_t		s[NAP_MAX_RANK];/* shape of arg1 */
    size_t		sz;		/* sizeof dataType */
    size_t              shape[1];
    int			status;
    float		x;
    float		x0;		/* element 0 */
    float		xmax;
    float		xmin;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Undefined left-hand operand");
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    CHECK2NULL(naoPtr2, "m4NAME: Undefined right-hand operand");
    if (naoPtr1->dataType == NAP_C8  && naoPtr2->dataType == NAP_C8) {
	id = Nap_Match(nap_cd, str1, str2);
    } else {
	Nap_IncrRefCount(nap_cd, naoPtr1);
	Nap_IncrRefCount(nap_cd, naoPtr2);
	r = naoPtr1->rank;
	R = naoPtr2->rank;
	for (j = 0; j < r; j++) {
	    s[j] = naoPtr1->shape[j];
	}
	for (j = 0; j < R; j++) {
	    S[j] = naoPtr2->shape[j];
	}
	CHECK2NULL(r > 0, "m4NAME: Left argument is scalar");
	    /* cyclic (currently just longitude as indicated by unit "degrees_east")? */
	if (r == 1  &&  naoPtr1->unit  &&  !strcmp(naoPtr1->unit, "degrees_east")
		    &&  naoPtr1->nels > 0) {
	    naoTmp = Nap_CastNAO(nap_cd, naoPtr1, NAP_F32);
	    CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoPtr1);
	    naoPtr1 = naoTmp;
	    j = naoPtr1->nels - 1;
	    x0 = naoPtr1->data.F32[0];
	    range = naoPtr1->data.F32[j] - x0;
	    delta = 360.0f * Sign(range);
	    if (Abs(range) < 360.0f) {
		shape[0] = naoPtr1->nels + 1;
		naoTmp = Nap_ReshapeNAO(nap_cd, naoPtr1, NAP_F32, 1, shape);
		Nap_IncrRefCount(nap_cd, naoTmp);
		Nap_DecrRefCount(nap_cd, naoPtr1);
		naoPtr1 = naoTmp;
		++j;
		naoPtr1->data.F32[j] = x0 + delta;
	    }
	    naoTmp = Nap_CastNAO(nap_cd, naoPtr2, NAP_F32);
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoPtr2);
	    naoPtr2 = naoTmp;
	    result = Nap_NewNAO(nap_cd, NAP_F32, R, S);
	    status = Nap_CopyDims(nap_cd, naoPtr2, result);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
	    xmin = Min(x0, naoPtr1->data.F32[j]);
	    xmax = Max(x0, naoPtr1->data.F32[j]);
	    guess = -1;
	    for (j = 0; j < naoPtr2->nels; j++) {
		if (IsMissing(naoPtr2, j)) {
		    result->data.F32[j] = NAP_F32_NULL;
		} else {
		    x = naoPtr2->data.F32[j];
		    if (x < xmin  ||  x > xmax) {
			x = x0 + Nap_fmod_f32(x - x0, delta);
		    }
		    result->data.F32[j] = Nap_IndexOfNao(nap_cd, naoPtr1, &x, guess);
		}
	    }
	} else {
	    dataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
	    sz = Nap_SizeOf(dataType);
	    naoTmp = Nap_CastNAO(nap_cd, naoPtr1, dataType);
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoPtr1);
	    naoPtr1 = naoTmp;
	    naoTmp = Nap_CastNAO(nap_cd, naoPtr2, dataType);
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoPtr2);
	    naoPtr2 = naoTmp;
	    if (r == 1) {
		result = Nap_NewNAO(nap_cd, NAP_F32, R, S);
		CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
		status = Nap_CopyDims(nap_cd, naoPtr2, result);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
		xmin = 0;
		xmax = naoPtr1->nels - 1;
		is_latitude = naoPtr1->unit  &&  !strcmp(naoPtr1->unit, "degrees_north");
		guess = -1;
		for (j = 0; j < naoPtr2->nels; j++) {
		    if (IsMissing(naoPtr2, j)) {
			result->data.F32[j] = NAP_F32_NULL;
		    } else {
			result->data.F32[j] = Nap_IndexOfNao(nap_cd, naoPtr1,
				naoPtr2->data.c+sz*j, guess);
			if (is_latitude) {
			    result->data.F32[j] = Max(xmin, Min(xmax, result->data.F32[j]));
			}
		    }
		}
	    } else if (r-1 > R) {
		for (j = 0; j < R; j++) {
		    CHECK2NULL(s[r-R+j] == S[j], "m4NAME: Trailing dimensions do not match");
		}
		result = Nap_NewNAO(nap_cd, NAP_F32, r-1, s+1);
		CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
		status = Nap_CopyTrailingDims(nap_cd, naoPtr1, result);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyTrailingDims");
		naoTmp = Nap_NewNAO(nap_cd, dataType, 1, s);
		CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
		Nap_IncrRefCount(nap_cd, naoTmp);
		m = naoPtr1->nels / s[0];
		guess = -1;
		for (j = 0; j < result->nels; j++) {
		    i = j % naoPtr2->nels;
		    if (IsMissing(naoPtr2, i)) {
			result->data.F32[j] = NAP_F32_NULL;
		    } else {
			for (k = 0; k < s[0]; k++) {
			    memcpy(naoTmp->data.c + sz * k, naoPtr1->data.c + sz * (m*k+j), sz);
			}
			naoTmp->step = NAP_STEP_UNKNOWN;
			result->data.F32[j] = Nap_IndexOfNao(nap_cd, naoTmp,
				naoPtr2->data.c+sz*i, guess);
		    }
		}
		Nap_DecrRefCount(nap_cd, naoTmp);
	    } else {				/* r-1 <= R */
		for (j = 1; j < r; j++) {
		    CHECK2NULL(s[j] == S[R-r+j], "m4NAME: Trailing dimensions do not match");
		}
		result = Nap_NewNAO(nap_cd, NAP_F32, R, S);
		CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
		status = Nap_CopyDims(nap_cd, naoPtr2, result);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
		naoTmp = Nap_NewNAO(nap_cd, dataType, 1, s);
		CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_NewNAO");
		Nap_IncrRefCount(nap_cd, naoTmp);
		m = naoPtr1->nels / s[0];
		n = result->nels / m;
		for (i = 0; i < m; i++) {
		    for (k = 0; k < s[0]; k++) {
			memcpy(naoTmp->data.c + sz * k, naoPtr1->data.c + sz * (m*k+i), sz);
		    }
		    naoTmp->step = NAP_STEP_UNKNOWN;
		    guess = -1;
		    for (j = 0; j < n; j++) {
			k = j * m + i;
			if (IsMissing(naoPtr2, k)) {
			    result->data.F32[k] = NAP_F32_NULL;
			} else {
			    result->data.F32[k] = Nap_IndexOfNao(nap_cd, naoTmp,
				    naoPtr2->data.c+sz*k, guess);
			}
		    }
		}
		Nap_DecrRefCount(nap_cd, naoTmp);
	    }
	}
	if (naoPtr2->rank == 1) {
	    status = Nap_AttachLink(nap_cd, result, naoPtr2);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
	}
	Nap_DecrRefCount(nap_cd, naoPtr1);
	Nap_DecrRefCount(nap_cd, naoPtr2);
	id = result->id;
    }
    return id;
}

/*
 *  Nap_Match --
 *	Index of 1st value in arg1 exactly equal to arg2 (operator '@@@').
 *	arg1 is vector.
 *	Result has type NAP_I32 & shape of arg2.
 *
 *	If right arg has rank 1 then attach it as link. This will be used as CV by indexing
 *	but will disappear if used for anything else.
 */

m4begin

m4define(`m4NAME', `Nap_Match')

#       m4match(dataTypeResult)   e.g. m4match(F32)
m4define(`m4match', `
    case m4DataTypeEnum($1):
	switch (naoPtr1->step) {
	case NAP_STEP_EQUAL:
	    if (n == 2) {
		step = naoPtr1->data.$1[1] - naoPtr1->data.$1[0];
	    } else if (n > 2) {
		step = (naoPtr1->data.$1[n-2] - naoPtr1->data.$1[0]) / (n-2.0);
	    }
	    for (j = 0; j < naoPtr2->nels; j++) {
		if (n < 1  ||  IsMissing(naoPtr2, j)) {
		    r = m4MissingValue(I32);
		} else if (naoPtr2->data.$1[j] == naoPtr1->data.$1[0]) {
		    r = 0;
		} else if (n == 1) {
		    r = m4MissingValue(I32);
		} else if (naoPtr2->data.$1[j] == naoPtr1->data.$1[n-1]) {
		    r = n - 1;
		} else if (naoPtr2->data.$1[j] == naoPtr1->data.$1[n-2]) {
		    r = n - 2;
		} else {
		    fs = (naoPtr2->data.$1[j] - naoPtr1->data.$1[0])/step;
		    r = fs < 0.5 ? 0 : fs + 0.5;
		    if (r >= naoPtr1->nels  || naoPtr2->data.$1[j] != naoPtr1->data.$1[r]) {
			r = m4MissingValue(I32);
		    }
		}
		result->data.I32[j] = r;
	    }
	    break;
	case NAP_STEP_NON_NEGATIVE:
	case NAP_STEP_NON_POSITIVE:
	    g = n;
	    for (j = 0; j < naoPtr2->nels; j++) {
		r = Nap_HuntNao(nap_cd, naoPtr1, naoPtr2->data.$1+j, g);
		if (naoPtr2->data.$1[j] == naoPtr1->data.$1[r]) {
		    while (r > 0  &&  naoPtr2->data.$1[j] == naoPtr1->data.$1[r-1]) {
			--r;
		    }
		} else {
		    r = m4MissingValue(I32);
		}
		result->data.I32[j] = r;
	    }
	    break;
	case NAP_STEP_BOTH:
	case NAP_STEP_NULL:
	    for (j = 0; j < naoPtr2->nels; j++) {
		r = m4MissingValue(I32);
		if (! IsMissing(naoPtr2, j)) {
		    for (i = 0; i < n; i++) {
			if (naoPtr2->data.$1[j] == naoPtr1->data.$1[i]) {
			    r = i;
			    break;
			}
		    }
		}
		result->data.I32[j] = r;
	    }
	    break;
	default:
	    assert(FALSE);
	}
	break;')

m4end

EXTERN char *
Nap_Match(
    NapClientData	*nap_cd,
    char		*str1,
    char		*str2)
{
    Nap_dataType        dataType;
    double		fs;			/* fractional subscript */
    size_t		g;			/* guess */
    size_t		i;
    size_t		j;
    size_t		n;			/* naoPtr1->nels */
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoTmp;
    int			r;
    Nap_NAO		*result;
    int			status;
    double		step;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Undefined left-hand operand");
    CHECK2NULL(naoPtr1->rank == 1,
	    "m4NAME: left-hand operand should be vector");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    CHECK2NULL(naoPtr2, "m4NAME: Undefined right-hand operand");
    Nap_IncrRefCount(nap_cd, naoPtr2);
    if (naoPtr1->step == NAP_STEP_UNKNOWN) {
	status = Nap_OilNao(naoPtr1);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_OilNao");
    }
    n = naoPtr1->nels;
    dataType = Max(naoPtr1->dataType, naoPtr2->dataType);
    naoTmp = Nap_CastNAO(nap_cd, naoPtr1, dataType);
    CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, naoTmp);
    Nap_DecrRefCount(nap_cd, naoPtr1);
    naoPtr1 = naoTmp;
    naoTmp = Nap_CastNAO(nap_cd, naoPtr2, dataType);
    CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, naoTmp);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    naoPtr2 = naoTmp;
    result = Nap_NewNAO(nap_cd, NAP_I32, naoPtr2->rank, naoPtr2->shape);
    status = Nap_CopyDims(nap_cd, naoPtr2, result);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
    switch (dataType) {
    m4ForAllUnboxedDataType(`m4match(', `)')
    default:            /* error */
	CHECK2NULL(FALSE, "m4NAME: Illegal data-type");
    }
    if (naoPtr2->rank == 1) {
	status = Nap_AttachLink(nap_cd, result, naoPtr2);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return result->id;
}

/*
 *  Nap_Closest --
 *	Index of closest value to arg2 in arg1 (operator '@@').
 *	arg1 is vector.
 *	Result has type NAP_I32 & shape of arg2.
 *
 *	If right arg has rank 1 then attach it as link. This will be used as CV by indexing
 *	but will disappear if used for anything else.
 */

m4begin

m4define(`m4NAME', `Nap_Closest')

#       m4closest(dataType)   e.g. m4closest(F32)
m4define(`m4closest', `
    case m4DataTypeEnum($1):
	switch (naoPtr1->step) {
	case NAP_STEP_EQUAL:
	    if (n < 2) {
		step = 0.0;
	    } else if (n == 2) {
		step = naoPtr1->data.$1[1] - naoPtr1->data.$1[0];
	    } else {
		step = (naoPtr1->data.$1[n-2] - naoPtr1->data.$1[0]) / (n-2.0);
	    }
	    mid_final_step = 0.5 * (naoPtr1->data.$1[n-2] + naoPtr1->data.$1[n-1]);
	    for (j = 0; j < naoPtr2->nels; j++) {
		if (IsMissing(naoPtr2, j)) {
		    r = m4MissingValue(I32);
		} else if (step == 0.0) {
		    r = 0;
		} else if ((naoPtr2->data.$1[j] - mid_final_step)/step > 0.0) {
		    r = n - 1;
		} else {
		    fs = (naoPtr2->data.$1[j] - naoPtr1->data.$1[0])/step;
		    r = fs < 0.5 ? 0 : fs + 0.5;
		}
		result->data.I32[j] = r;
	    }
	    break;
	case NAP_STEP_NON_NEGATIVE:
	case NAP_STEP_NON_POSITIVE:
	    g = n;
	    for (j = 0; j < naoPtr2->nels; j++) {
		if (IsMissing(naoPtr2, j)) {
		    result->data.I32[j] = m4MissingValue(I32);
		} else {
		    result->data.I32[j] = Nap_HuntNao(nap_cd, naoPtr1, naoPtr2->data.$1+j, g);
		}
	    }
	    break;
	case NAP_STEP_BOTH:
	    for (j = 0; j < naoPtr2->nels; j++) {
		if (IsMissing(naoPtr2, j)) {
		    result->data.I32[j] = m4MissingValue(I32);
		} else {
		    r = -1;
		    for (i = 0; i < n; i++) {
			if (r < 0  ||  AbsDiff(naoPtr2->data.$1[j], naoPtr1->data.$1[i]) <
				       AbsDiff(naoPtr2->data.$1[j], naoPtr1->data.$1[r])) {
			    r = i;
			}
		    }
		    result->data.I32[j] = r < 0 ? m4MissingValue(I32) : r;
		}
	    }
	    break;
	case NAP_STEP_NULL:
	    for (j = 0; j < naoPtr2->nels; j++) {
		if (IsMissing(naoPtr2, j)) {
		    result->data.I32[j] = m4MissingValue(I32);
		} else {
		    r = -1;
		    for (i = 0; i < n; i++) {
			if (!IsMissing(naoPtr1, i)) {
			    if (r < 0  ||  AbsDiff(naoPtr2->data.$1[j], naoPtr1->data.$1[i]) <
					   AbsDiff(naoPtr2->data.$1[j], naoPtr1->data.$1[r])) {
				r = i;
			    }
			}
		    }
		    result->data.I32[j] = r < 0 ? m4MissingValue(I32) : r;
		}
	    }
	    break;
	default:
	    assert(FALSE);
	}
	break;')

m4end

EXTERN char *
Nap_Closest(
    NapClientData	*nap_cd,
    char		*str1,
    char		*str2)
{
    Nap_dataType        dataType;
    float		delta;
    double		fs;			/* fractional subscript */
    size_t		g;			/* guess */
    size_t		i;
    char		*id;
    size_t		j;
    double		mid_final_step;		/* mid-point of final step */
    size_t		n;			/* naoPtr1->nels */
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr1old;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoPtr2old;
    Nap_NAO		*naoTmp;
    int			r;
    float		range;
    Nap_NAO		*result;
    size_t              shape[1];
    double		step;
    int			status;
    float		x0;		/* element 0 */
    float		xmax;
    float		xmin;

    naoPtr1old = naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Undefined left-hand operand");
    CHECK2NULL(naoPtr1->rank == 1, "m4NAME: left-hand operand should be vector");
    Nap_IncrRefCount(nap_cd, naoPtr1old);
    Nap_IncrRefCount(nap_cd, naoPtr1);
    naoPtr2old = naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    CHECK2NULL(naoPtr2, "m4NAME: Undefined right-hand operand");
    Nap_IncrRefCount(nap_cd, naoPtr2old);
    Nap_IncrRefCount(nap_cd, naoPtr2);
    n = naoPtr1->nels;
    dataType = Max(naoPtr1->dataType, naoPtr2->dataType);
    if (dataType == NAP_C8) {
	id = Nap_Match(nap_cd, str1, str2);
    } else {
	    /* Cyclic (currently just longitude as indicated by unit "degrees_east")? */
	if (naoPtr1->unit && !strcmp(naoPtr1->unit, "degrees_east") && naoPtr1->nels > 0) {
	    dataType = NAP_F32;
	    naoTmp = Nap_CastNAO(nap_cd, naoPtr1, NAP_F32);
	    CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoPtr1);
	    naoPtr1 = naoTmp;
            j = naoPtr1->nels - 1;
            x0 = naoPtr1->data.F32[0];
            range = naoPtr1->data.F32[j] - x0;
            delta = 360.0f * Sign(range);
            if (Abs(range) < 360.0f) {
                shape[0] = naoPtr1->nels + 1;
                naoTmp = Nap_ReshapeNAO(nap_cd, naoPtr1, NAP_F32, 1, shape);
		CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_ReshapeNAO");
                Nap_IncrRefCount(nap_cd, naoTmp);
                Nap_DecrRefCount(nap_cd, naoPtr1);
                naoPtr1 = naoTmp;
                ++j;
		naoPtr1->data.F32[j] = x0 + delta;
	    }
	    naoTmp = Nap_CastNAO(nap_cd, naoPtr2, NAP_F32);
	    CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoPtr2);
	    naoPtr2 = naoTmp;
	    xmin = Min(x0, naoPtr1->data.F32[j]);
	    xmax = Max(x0, naoPtr1->data.F32[j]);
	    for (j = 0; j < naoPtr2->nels; j++) {
		if (naoPtr2->data.F32[j] < xmin  ||  naoPtr2->data.F32[j] > xmax) {
		    naoPtr2->data.F32[j] = x0 + Nap_fmod_f32(naoPtr2->data.F32[j] - x0, delta);
		}
	    }
	} 
	if (naoPtr1->dataType < dataType) {
	    naoTmp = Nap_CastNAO(nap_cd, naoPtr1, dataType);
	    CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoPtr1);
	    naoPtr1 = naoTmp;
	}
	if (naoPtr2->dataType < dataType) {
	    naoTmp = Nap_CastNAO(nap_cd, naoPtr2, dataType);
	    CHECK2NULL(naoTmp, "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    Nap_DecrRefCount(nap_cd, naoPtr2);
	    naoPtr2 = naoTmp;
	}
	if (naoPtr1->step == NAP_STEP_UNKNOWN) {
	    status = Nap_OilNao(naoPtr1);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_OilNao");
	}
	result = Nap_NewNAO(nap_cd, NAP_I32, naoPtr2->rank, naoPtr2->shape);
	status = Nap_CopyDims(nap_cd, naoPtr2, result);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
	switch (dataType) {
	m4ForAllUnboxedDataType(`m4closest(', `)')
	default:            /* error */
	    CHECK2NULL(FALSE, "m4NAME: Illegal data-type");
	}
	id = result->id;
	if (naoPtr2old->rank == 1) {
	    status = Nap_AttachLink(nap_cd, result, naoPtr2old);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
	}
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Nap_DecrRefCount(nap_cd, naoPtr1old);
    Nap_DecrRefCount(nap_cd, naoPtr2old);
    return id;
}
