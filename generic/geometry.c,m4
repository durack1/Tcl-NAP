m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (geometry.c) */
/* It was produced from source file geometry.c,m4 */

/* 
 *	Copyright 2004, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Atmospheric Research
 */

#ifndef lint
static char *rcsid="@(#) $Id: geometry.c,m4,v 1.8 2006/12/12 22:44:17 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"

/*
 *  Nap_inPolygon --
 *
 *  Nap function 'inPolygon(x, y, p)'
 *  Tests whether points defined by 'x' & 'y' are inside, outside or on polygon defined by 'p'.
 *
 *  x & y must have shapes which are compatible with each other.
 *  Result has the same shape as x or y (whichever has the higher rank).
 *  Result has value -1 if (x,y) is outside, 0 if exactly on edge, 1 if inside.
 *  If x or y is missing then the result is missing.
 *
 *  p is matrix with 2 or more columns.  Each row corresponds to a vertex of the polygon.
 *  Column 0 contains x values & column 1 contains y values. Any further columns are ignored.
 *
 *  Based on function 'pnpoly' by Randolph Franklin at URL
 *  http://astronomy.swin.edu.au/~pbourke/geometry/insidepoly/
 *  This page was written by Paul Bourke in November 1987 & is titled
 *  'Determining if a point lies on the interior of a polygon'.
 */

m4begin

# m4inPoly(dataType)

m4define(`m4inPoly', `

/*
 *  Enter with z = -128 if corresponding x or y is missing, otherwise 0.
 *
 *  During processing z is set to -2 for "exactly on edge" & -1 for outside.
 *  Values of 0 & 1 indicate current odd/even status with further processing needed.
 *
 *  At end change -2 to 0 & 0 to -1.
 */

static int
inPoly_$1(
    NapClientData	*nap_cd,
    size_t		nx,		/* # elements in x */
    m4DataTypeName($1)	*px,		/* pointer to x */
    size_t		ny,		/* # elements in y */
    m4DataTypeName($1)	*py,		/* pointer to y */
    size_t		nrp,		/* # rows in v (= vertices in polygon) */
    size_t		ncp,		/* # columns in v */
    m4DataTypeName($1)	*pv,		/* pointer to v (vertices) (= p in inPolygon) */
    size_t		nz,		/* # elements in z */
    m4DataTypeName(I8)	mvz,		/* missing value of z (-128) */
    m4DataTypeName(I8)	*z)		/* pointer to result (out) */
{
    int			i;		/* vertex subscript (row of v) */
    int			j;		/* temp. subscript */
    int			k;		/* subscript of z */
    m4DataTypeName($1)	x;		/* x-coord of point to test */
    m4DataTypeName($1)	xi;		/* x-coord of vertex i of polygon */
    m4DataTypeName($1)	xi1;		/* x-coord of vertex i+1 of polygon */
    m4DataTypeName($1)	xlength;	/* length of horizontal ray right from point to polygon */
    m4DataTypeName($1)	xmax, xmin;	/* bounding box of polygon */
    m4DataTypeName($1)	y;		/* y-coord of point to test */
    m4DataTypeName($1)	yi;		/* y-coord of vertex i of polygon */
    m4DataTypeName($1)	yi1;		/* y-coord of vertex i+1 of polygon */
    m4DataTypeName($1)	ymax, ymin;	/* bounding box of polygon */

    assert(mvz < -2  ||  mvz > 1);
    xmin = xmax = pv[0];
    ymin = ymax = pv[1];
    for (i = 1; i < nrp; i++) {
	j = i * ncp;
	xi = pv[j];
	yi = pv[j + 1];
	if (xi < xmin) xmin = xi;
	if (xi > xmax) xmax = xi;
	if (yi < ymin) ymin = yi;
	if (yi > ymax) ymax = yi;
    }
    for (k = 0; k < nz; k++) {
	if (z[k] == 0) {
	    x = px[k % nx];
	    y = py[k % ny];
	    if (x < xmin  ||  x > xmax  ||  y < ymin  ||  y > ymax) {
		z[k] = -1;
	    }
	}
    }
    for (i = 0; i < nrp; i++) {
	j = i * ncp;
	xi = pv[j];
	yi = pv[j + 1];
	j = (i+1) % nrp * ncp;
	xi1 = pv[j];
	yi1 = pv[j + 1];
	for (k = 0; k < nz; k++) {
	    if (z[k] == 0  ||  z[k] == 1) {
		x = px[k % nx];
		y = py[k % ny];
		if (y == yi && (x == xi || yi == yi1 &&
			((xi <= x && x <= xi1) || (xi >= x && x >= xi1)))) {
		    z[k] = -2;		/* -2 means on edge (change to 0 at end) */
		} else if ((yi <= y  &&  y < yi1)  ||  (yi > y  &&  y >= yi1)) {
		    xlength = xi + (y - yi) / (yi1 - yi) * (xi1 - xi) - x;
		    if (xlength > 0) {
			z[k] = 1 - z[k];	/* change 0 to 1, 1 to 0 */
		    } else if (xlength == 0) {
			z[k] = -2;
		    }
		}
	    }
	}
    }
    for (k = 0; k < nz; k++) {		/* change -2 to 0, 0 to -1 */
	switch (z[k]) {
	    case -2: z[k] =  0; break;
	    case  0: z[k] = -1; break;
	}
    }
    return TCL_OK;
}')

m4end

m4ForAllRealDataType(`m4inPoly(', `)')

m4begin

# m4_inPolygon(dataType)

m4define(`m4_inPolygon', `
	    case m4DataTypeEnum($1):
		for (i = 0; i < z->nels; i++) {
		    z->data.I8[i] = (IsMissing(x, i % x->nels)  ||  IsMissing(y, i % y->nels))
			    ? m4MissingValue(I8) : 0;
		}
		status = inPoly_$1(nap_cd, x->nels, x->data.$1, y->nels, y->data.$1,
			p->shape[0], p->shape[1], p->data.$1, z->nels, m4MissingValue(I8),
			z->data.I8);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling inPoly_$1");
		break;')

m4define(`m4NAME', `Nap_inPolygon')

m4end

EXTERN char *
Nap_inPolygon(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_NAO		*argx;			/* argument x */
    Nap_NAO		*argy;			/* argument y */
    Nap_NAO		*argp;			/* argument p */
    Nap_dataType        dataType;		/* for x, y, p */
    int			i;			/* subscript */
    Nap_NAO		*p;			/* vertices of polygon */
    int			status;			/* error code */
    Nap_NAO		*x;			/* x-coords of points to be tested */
    Nap_NAO		*y;			/* y-coords of points to be tested */
    Nap_NAO		*z;			/* result */

    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    Nap_IncrRefCount(nap_cd, box_nao);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: box_nao rank not 1");
    CHECK2NULL(box_nao->nels == 3,  "m4NAME: Wrong number of arguments");
    argx = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    CHECK2NULL(argx, "m4NAME: Error calling Nap_GetNaoFromSlot");
    argy = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(argy, "m4NAME: Error calling Nap_GetNaoFromSlot");
    argp = Nap_GetNaoFromSlot(box_nao->data.Boxed[2]);
    CHECK2NULL(argp, "m4NAME: Error calling Nap_GetNaoFromSlot");
    dataType = m4DataTypeEnum(m4MinRealDataType);
    dataType = Nap_DataType2(dataType, argx->dataType);
    dataType = Nap_DataType2(dataType, argy->dataType);
    dataType = Nap_DataType2(dataType, argp->dataType);
    x = Nap_CastNAO(nap_cd, argx, dataType);
    CHECK2NULL(x, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, x);
    y = Nap_CastNAO(nap_cd, argy, dataType);
    CHECK2NULL(y, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, y);
    p = Nap_CastNAO(nap_cd, argp, dataType);
    CHECK2NULL(p, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, p);
    CHECK2NULL(p->rank == 2, "m4NAME: p is not matrix");
    CHECK2NULL(p->shape[1] > 1, "m4NAME: p has < 2 columns");
    if (x->rank > y->rank) {
	z = Nap_NewNAO(nap_cd, NAP_I8, x->rank, x->shape);
    } else {
	z = Nap_NewNAO(nap_cd, NAP_I8, y->rank, y->shape);
    }
    for (i = 0; i < x->rank; i++) {
	CHECK2NULL(x->shape[i] == z->shape[i + z->rank - x->rank],
		"m4NAME: Shapes of x & y are incompatible");
    }
    for (i = 0; i < y->rank; i++) {
	CHECK2NULL(y->shape[i] == z->shape[i + z->rank - y->rank],
		"m4NAME: Shapes of x & y are incompatible");
    }
    status = Nap_CopyTrailingDims(nap_cd, x, z);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyTrailingDims");
    status = Nap_CopyTrailingDims(nap_cd, y, z);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyTrailingDims");
    switch (dataType) {
	m4ForAllRealDataType(`m4_inPolygon(', `)')
	default: assert(0);
    }
    Nap_DecrRefCount(nap_cd, x);
    Nap_DecrRefCount(nap_cd, y);
    Nap_DecrRefCount(nap_cd, p);
    Nap_DecrRefCount(nap_cd, box_nao);
    return z->id;
}

/*
 *  Nap_clip2d --
 *
 *  Nap function 'clip2d(rectangle, line)'
 *  Result is line clipped by rectangle.
 *
 *  Arguments are 2 by 2 matrices.
 *
 *  rectangle is matrix:
 *  (xmin ymin)
 *  (xmax ymax)
 *
 *  line is either a single 2*2 matrix as follows:
 *  (x0 y0)
 *  (x1 y1)
 *  or an n*2*2 array containing n such matrices as sub-arrays.
 *
 *  Result is similar 2 by 2 matrix.  Values are NaN if line is not visible.
 *
 *  Uses Liang-Barsky parametric line-clipping algorithm
 *
 *  From: Foley, J.D., van Dam, A., Feiner, S.K. and Hughes, J.F.:
 *  Computer Graphics Principles and Practice, 2nd ed. in C, pp 122-3.
 *
 *  <!-- saved from url=(0047)http://www.cs.umu.se/~c98jcn/root/liangbarsky.c -->
 */

/*
    ClipPoint returns TRUE if the point (x,y) lies inside the clip rectangle
 */

#define ClipPoint(xmin,ymin,xmax,ymax,x,y) \
	((x) >= (xmin)  &&  (y) >= (ymin)  &&  (x) <= (xmax)  &&  (y) <= (ymax))

m4begin

# m4clip2d(dataType)

m4define(`m4clip2d', `

int
CLIPt_$1(
    m4DataTypeName($1) denom,
    m4DataTypeName($1) num,
    m4DataTypeName($1) *tE,
    m4DataTypeName($1) *tL)
{
    m4DataTypeName($1) t;
    if (denom > 0) {		/* PE intersection */
	t = num / denom;	/* Value of t at the intersection */
	if (t > *tL)		/* tE and tL crossover */
	    return(0);		/* so prepare to reject line */
	else if (t > *tE)	/* A new tE has been found */
	    *tE = t;
    } else if (denom < 0) {	/* PL intersection */
	t = num / denom;	/* Value of t at the intersection */
	if (t < *tE)		/* tE and tL crossover */
	    return(0);		/* so prepare to reject line */
	else if (t < *tL)	/* A new tL has been found */
	    *tL = t;
    } else if (num > 0)		/* Line on outside of edge */
	return(0);
    return(1);
}

/*
    Clip 2D line segment with endpoints (x0,y0) and (x1,y1), against upright clip rectangle
    with corners at (xmin,ymin) and (xmax,ymax). The flag <visible> is set TRUE if a clipped
    segment is returned in endpoint parameters. If the line is rejected, the endpoints are
    not changed and <visible> is set to FALSE.
 */

m4define(`m4NAME', `Clip2D_$1')

static int
m4NAME (
    NapClientData	*nap_cd,
    m4DataTypeName($1)	xmin,
    m4DataTypeName($1)	ymin,
    m4DataTypeName($1)	xmax,
    m4DataTypeName($1)	ymax,
    m4DataTypeName($1)	*x0,
    m4DataTypeName($1)	*y0,
    m4DataTypeName($1)	*x1,
    m4DataTypeName($1)	*y1)
{
    int			visible;
    m4DataTypeName($1)	dx = *x1 - *x0;
    m4DataTypeName($1)	dy = *y1 - *y0;
    /* Output is generated only if line is inside all four edges. */
    visible = 0;
    /* First test for degenerate line and clip the point */
    if ((dx == 0) && (dy == 0) && (ClipPoint(xmin, ymin, xmax, ymax, *x0, *y0))) {
	visible = 1;
    } else {
	m4DataTypeName($1) tE = 0.0;
	m4DataTypeName($1) tL = 1.0;
	if (CLIPt_$1(dx, xmin - *x0, &tE, &tL)) {		/* Inside wrt left edge */
	    if (CLIPt_$1(-dx, *x0 - xmax, &tE, &tL)) {		/* Inside wrt right edge */
		if (CLIPt_$1(dy, ymin - *y0, &tE, &tL))	{	/* Inside wrt bottom edge */
		    if (CLIPt_$1(-dy, *y0 - ymax, &tE, &tL)) {	/* Inside wrt top edge */
			visible = 1;
			/* Compute PL intersection, if tL has moved */
			if (tL < 1) {
			    *x1 = *x0 + tL * dx;
			    *y1 = *y0 + tL * dy;
			}
			/* Compute PE intersection, if tE has moved */
			if (tE > 0) {
			    *x0 += tE * dx;
			    *y0 += tE * dy;
			}
		    }
		}
	    }
	}
    }
    if (!visible) {
	*x0 = *y0 = *x1 = *y1 = m4DataTypeMissingValue($1);
    }
    return TCL_OK;
}')

m4end

m4ForAllRealDataType(`m4clip2d(', `)')

m4begin

m4define(`m4NAME', `Nap_clip2d')

# m4_clip2d(dataType)

m4define(`m4_clip2d', `
	    case m4DataTypeEnum($1): {
		m4DataTypeName($1) xmin = Min(rectangle->data.$1[0], rectangle->data.$1[2]);
		m4DataTypeName($1) ymin = Min(rectangle->data.$1[1], rectangle->data.$1[3]);
		m4DataTypeName($1) xmax = Max(rectangle->data.$1[0], rectangle->data.$1[2]);
		m4DataTypeName($1) ymax = Max(rectangle->data.$1[1], rectangle->data.$1[3]);
		status = Clip2D_$1(nap_cd, xmin, ymin, xmax, ymax,
			&(line->data.$1[i]), &(line->data.$1[i+1]),
			&(line->data.$1[i+2]), &(line->data.$1[i+3]));
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Clip2D_$1");
		break;
	    }')

m4end

EXTERN char *
Nap_clip2d(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_NAO		*arg_rectangle;		/* argument rectangle */
    Nap_NAO		*arg_line;		/* argument line */
    Nap_dataType        dataType;		/* for rectangle, line, line */
    int			i;
    Nap_NAO		*line;
    Nap_NAO		*rectangle;
    int			status;			/* error code */

    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    Nap_IncrRefCount(nap_cd, box_nao);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: box_nao rank not 1");
    CHECK2NULL(box_nao->nels == 2,  "m4NAME: Wrong number of arguments");
    arg_rectangle = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    CHECK2NULL(arg_rectangle, "m4NAME: Error calling Nap_GetNaoFromSlot");
    CHECK2NULL(arg_rectangle->nels == 4, "m4NAME: nels(rectangle) != 4");
    arg_line = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(arg_line, "m4NAME: Error calling Nap_GetNaoFromSlot");
    CHECK2NULL(arg_line->nels % 4 == 0, "m4NAME: nels(line) not multiple of 4");
    dataType = m4DataTypeEnum(m4MinRealDataType);
    dataType = Nap_DataType2(dataType, arg_rectangle->dataType);
    dataType = Nap_DataType2(dataType, arg_line->dataType);
    rectangle = Nap_CastNAO(nap_cd, arg_rectangle, dataType);
    CHECK2NULL(rectangle, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, rectangle);
    if (arg_line->dataType == dataType) {
	line = Nap_CopyNAO(nap_cd, arg_line);
	CHECK2NULL(line, "m4NAME: Error calling Nap_CopyNAO");
    } else {
	line = Nap_CastNAO(nap_cd, arg_line, dataType);
	CHECK2NULL(line, "m4NAME: Error calling Nap_CastNAO");
    }
    Nap_IncrRefCount(nap_cd, line);
    for (i = 0; i < line->nels; i += 4) {
	switch (dataType) {
	    m4ForAllRealDataType(`m4_clip2d(', `)')
	    default: assert(0);
	}
    }
    Nap_DecrRefCount(nap_cd, rectangle);
    Nap_DecrRefCount(nap_cd, box_nao);
    -- line->count;
    return line->id;
}
