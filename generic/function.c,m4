m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (function.c) */
/* It was produced from source file function.c,m4 */

/* 
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: function.c,m4,v 1.17 2007/11/01 09:01:30 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"
#include "linsys.h"

#define Random_float(max) \
    ((max) * ((float) rand()) * ((1.0f - FLT_EPSILON) / (float) RAND_MAX))

#define Random_double(max) \
    ((max) * ((double) rand()) * ((1.0 - DBL_EPSILON) / (double) RAND_MAX))

static char *Nap_Func1(NapClientData *nap_cd, char *name, char *str);

/*
 *  Nap_CV --
 *	nap function "coordinate_variable(x ?, dimnum?)"
 *	Result is coordinate-variable of dimension dimnum of x.
 *	dimnum taken mod rank.
 *	dimnum defaults to 0.
 *	dimnum can be name of dimension as C8 NAO e.g. coordinate_variable(m, 'latitude')
 */

m4define(`m4NAME', `Nap_CV')

static char *
Nap_CV(
    NapClientData       *nap_cd,
    char		*str1,
    char		*str2)
{
    int			i;
    size_t		shape[NAP_MAX_RANK];
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoPtr3;
    Nap_NAO		*new;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Illegal x in 'coordinate_variable(x ?,dimnum?)'");
    CHECK2NULL(naoPtr1->rank > 0, "m4NAME: scalar x in 'coordinate_variable(x ?,dimnum?)'");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    if (str2) {
	naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
	Nap_IncrRefCount(nap_cd, naoPtr2);
	if (naoPtr2->dataType == NAP_C8) {
	    i = Nap_StrToDimNum(nap_cd, naoPtr1, naoPtr2->data.c);
	} else {
	    CHECK2NULL(naoPtr2->rank == 0, "m4NAME: Non-scalar i in coordinate_variable(v,i)");
	    naoPtr3 = Nap_CastNAO(nap_cd, naoPtr2, NAP_I32);
	    Nap_IncrRefCount(nap_cd, naoPtr3);
	    i = Nap_mod(naoPtr3->data.I32[0], naoPtr1->rank);
	    Nap_DecrRefCount(nap_cd, naoPtr3);
	}
	Nap_DecrRefCount(nap_cd, naoPtr2);
    } else {
	i = 0;
    }
    new = Nap_GetCoordVar(nap_cd, naoPtr1, i);
    if (!new) {
	shape[0] = naoPtr1->shape[i];
	new = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	CHECK2NULL(new, "error calling Nap_NewNAO");
	for (i = 0; i < shape[0]; i++) {
	    new->data.I32[i] = i;
	}
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    return new ? new->id : NULL;
}


/*
 *  Nap_SolveLinear --
 *	nap function "solve_linear(A, B)"
 *	This solves system of linear equations defined by matrix A &
 *	right-hand-sides B (vector or matrix)
 */

m4begin

# m4_solve_linear(dataType)

m4define(`m4_solve_linear', `
	    case m4DataTypeEnum($1):
		{
		    m4DataTypeName($1) **a;	/* pointers to rows of left hand side */
		    m4DataTypeName($1) **b;	/* pointers to rows of right hand side */
		    a = (m4DataTypeName($1) **) NAP_ALLOC(nap_cd, n * sizeof(m4DataTypeName($1) *));
		    CHECK2NULL(a, "m4NAME: Unable to allocate memory");
		    b = (m4DataTypeName($1) **) NAP_ALLOC(nap_cd, n * sizeof(m4DataTypeName($1) *));
		    CHECK2NULL(b, "m4NAME: Unable to allocate memory");
		    for (i = 0; i < n; ++i) {
			a[i] = naoA->data.$1 + i * n;
			b[i] = naoB->data.$1 + i * m;
			if (!naoPtr2) {	/* set B to default (identity matrix) */
			    for (j = 0; j < n; ++j) {
				b[i][j] = i == j;
			    }
			}
		    }
		    status = linsys_$1(nap_cd, n, m, a, b);
		    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling linsys_$1");
		    NAP_FREE(nap_cd, a);
		    NAP_FREE(nap_cd, b);
		}
		break;')

m4define(`m4NAME', `Nap_SolveLinear')

m4end

static char *
Nap_SolveLinear(
    NapClientData       *nap_cd,
    char		*str1,
    char		*str2)
{
    Nap_dataType        dataType;
    int			i;		/* subscript */
    int			j;		/* subscript */
    int			m;		/* # columns in RHS b */
    int			n;		/* # rows (equations) */
    Nap_NAO		*naoA;		/* main matrix (LHS) */
    Nap_NAO		*naoB;		/* RHS & result */
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*oldA;		/* old naoA*/
    Nap_NAO		*oldB;		/* old naoB*/
    int			status;
    char		*str;
    Nap_NAO		*transposeA;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Illegal arg1 in solve_linear");
    CHECK2NULL(naoPtr1->rank == 2, "m4NAME: arg1 has rank other than 2");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    dataType = Nap_DataType2(naoPtr1->dataType, NAP_F32);
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    if (naoPtr2) {
	CHECK2NULL(naoPtr2->rank == 1  ||  naoPtr2->rank == 2,
		"m4NAME: arg2 has rank other than 1 or 2");
	Nap_IncrRefCount(nap_cd, naoPtr2);
	dataType = Nap_DataType2(dataType, naoPtr2->dataType);
    }
    if (dataType == naoPtr1->dataType) {
	naoA = Nap_CopyNAO(nap_cd, naoPtr1);
	CHECK2NULL(naoA, "m4NAME: Error calling Nap_CopyNAO");
    } else {
	naoA = Nap_CastNAO(nap_cd, naoPtr1, dataType);
	CHECK2NULL(naoA, "m4NAME: Error calling Nap_CastNAO");
    }
    Nap_IncrRefCount(nap_cd, naoA);
    if (naoPtr2) {
	if (dataType == naoPtr2->dataType) {
	    naoB = Nap_CopyNAO(nap_cd, naoPtr2);
	    CHECK2NULL(naoA, "m4NAME: Error calling Nap_CopyNAO");
	} else {
	    naoB = Nap_CastNAO(nap_cd, naoPtr2, dataType);
	    CHECK2NULL(naoB, "m4NAME: Error calling Nap_CastNAO");
	}
    } else {
	naoB = Nap_NewNAO(nap_cd, dataType, 2, naoA->shape);
	CHECK2NULL(naoB, "m4NAME: Error calling Nap_NewNAO");
    }
    Nap_IncrRefCount(nap_cd, naoB);
    CHECK2NULL(naoB->shape[0] == naoA->shape[0],
	    "m4NAME: # rows in arg1 differs from # rows in arg2");
    if (naoPtr1->shape[0] > naoPtr1->shape[1]) {	/* overdetermined, so least-squares soln */
	oldA = naoA;
	oldB = naoB;
	str = Nap_Func(nap_cd, "transpose", oldA->id);
	CHECK1NULL(str);
	transposeA = Nap_GetNaoFromId(nap_cd, str);
	Nap_IncrRefCount(nap_cd, transposeA);
	str = Nap_InnerProd(nap_cd, transposeA->id, oldA->id);
	CHECK1NULL(str);
	naoA = Nap_GetNaoFromId(nap_cd, str);
	Nap_IncrRefCount(nap_cd, naoA);
	str = Nap_InnerProd(nap_cd, transposeA->id, oldB->id);
	CHECK1NULL(str);
	naoB = Nap_GetNaoFromId(nap_cd, str);
	Nap_IncrRefCount(nap_cd, naoB);
	Nap_DecrRefCount(nap_cd, transposeA);
	Nap_DecrRefCount(nap_cd, oldA);
	Nap_DecrRefCount(nap_cd, oldB);
    }
    n = (int) naoA->shape[0];
    m = (int) (naoB->rank == 2 ? naoB->shape[1] : 1);
    CHECK2NULL(naoPtr1->shape[0] >= naoPtr1->shape[1], "m4NAME: more unknowns than equations");
    switch (dataType) {
	m4ForAllRealDataType(`m4_solve_linear(', `)')
	default: assert(0);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Nap_DecrRefCount(nap_cd, naoA);
    --naoB->count;
    return naoB->id;
}


/*
 *  Nap_Reshape --
 *	nap function "reshape(x,shape)"
 *	This creates array with specified shape, taking data type & values from x
 *	(recycling if necessary).  If shape not specified then produce vector
 *	with same number of elements as x.
 */

m4define(`m4NAME', `Nap_Reshape')

static char *
Nap_Reshape(
    NapClientData       *nap_cd,
    char		*str1,
    char		*str2)
{
    int			i;
    size_t		shape[NAP_MAX_RANK];
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoPtr3;
    Nap_NAO		*new;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Illegal x in 'reshape(x ?,shape?)'");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    if (naoPtr2) {
	CHECK2NULL(naoPtr2->rank <= 1, 
	    "m4NAME: shape argument not scalar or vector in reshape(array,shape)");
	CHECK4NULL(naoPtr2->nels <= NAP_MAX_RANK, 
	    "m4NAME: shape argument in reshape(array,shape) specifies rank = %d "
	    "which exceeds max. of %d", naoPtr2->nels, NAP_MAX_RANK);
	Nap_IncrRefCount(nap_cd, naoPtr2);
	shape[0] = naoPtr2->nels;
	naoPtr3 = Nap_ReshapeNAO(nap_cd, naoPtr2, NAP_I32, 1, shape);
	Nap_IncrRefCount(nap_cd, naoPtr3);
	for (i = 0; i < naoPtr3->nels; i++) {
	    shape[i] = naoPtr3->data.I32[i];
	}
	new = Nap_ReshapeNAO2(nap_cd, naoPtr1, naoPtr1->dataType, naoPtr3->nels, shape, 1, 0, 0);
	Nap_IncrRefCount(nap_cd, new);
	Nap_DecrRefCount(nap_cd, naoPtr3);
	CHECK2NULL(new, "m4NAME: error calling Nap_ReshapeNAO2");
	Nap_DecrRefCount(nap_cd, naoPtr2);
    } else {
	shape[0] = naoPtr1->nels;
	new = Nap_ReshapeNAO2(nap_cd, naoPtr1, naoPtr1->dataType, 1, shape, 1, 0, 0);
	Nap_IncrRefCount(nap_cd, new);
	CHECK2NULL(new, "m4NAME: error calling Nap_ReshapeNAO2");
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    --new->count;
    return new ? new->id : NULL;
}

/*
 *  mixedBase --
 *	Convert an ordinary number to a mixed base number.
 *
 *  Returns 0 if OK, 1 for error.
 *
 *  Example: Following converts 65 inches to 1 yard, 2 feet and 5 inches.
 *	long        base[] = {3, 12};
 *	long        result[3];
 *	int         status;
 *	status = mixedBase(65, 2, base, result);
 *  This sets result[0] to 1, result[1] to 2, result[2] to 5.
 */

EXTERN int
mixedBase(
    long	n,		/* number to be converted to mixed base */
    size_t	nbases,		/* number of elements in base */
    long	base[],		/* base vector */
    long	result[])	/* mixed-base result (nbases+1 elements) */
{
    ldiv_t	d;
    size_t	i;

    result[nbases] = n;
    if (nbases > 0) {
	for (i = nbases; i > 0; i--) {
	    if (base[i-1] > 0) {
		d = ldiv(result[i], base[i-1]);
		result[i]   = d.rem;
		result[i-1] = d.quot;
	    } else {
		return 1;
	    }
	}
    }
    return 0;
}

/*
 * Nap_sort --
 *	function sort(v) which sorts vector into ascending order
 *	Consider NaN < -infinity
 *	Other missing values simply treated as having their numeric value.
 */

m4begin

#	m4cmpInt(type)
m4define(`m4cmpInt', `
int cmp$1(const void *xp, const void *yp) {
    m4DataTypeName($1) x = **((m4DataTypeName($1) **) xp);
    m4DataTypeName($1) y = **((m4DataTypeName($1) **) yp);
    return x < y ? -1 : (x > y);
}')

#	m4cmpReal(type)
m4define(`m4cmpReal', `
int cmp$1(const void *xp, const void *yp) {
    m4DataTypeName($1) x = **((m4DataTypeName($1) **) xp);
    m4DataTypeName($1) y = **((m4DataTypeName($1) **) yp);
    if (m4isNaN($1)(x)) {
	if (m4isNaN($1)(y)) {
	    return 0;
	} else {
	    return -1;
	}
    } else {
	if (m4isNaN($1)(y)) {
	    return 1;
	} else {
	    return x < y ? -1 : (x > y);
	}
    }
    return 0;
}')

#	m4sort(type)
m4define(`m4sort', `
	case m4DataTypeEnum($1):
	    qsort(pv, n, sizeof(char *), cmp$1);
	    break;')

m4define(`m4NAME', `Nap_sort')

m4end

m4ForAllCharacterDataType(`m4cmpInt(', `)')
m4ForAllIntegerDataType(`m4cmpInt(', `)')
m4ForAllRealDataType(`m4cmpReal(', `)')

static char *
Nap_sort(
    NapClientData	*nap_cd, 
    char		*str1,			/* main nao */
    char		*str2)			/* verb-rank nao */
{
    size_t		c;			/* subscript of cell */
    int			frame_rank;
    Nap_NAO		*naoPtr;		/* main nao */
    Nap_NAO		*nao_tmp;
    Nap_NAO		*nao_verb_rank;		/* verb rank */
    size_t		nCells;			/* no. cells */
    size_t		i;			/* subscript of row */
    size_t		j;			/* subscript of col. */
    size_t		m;			/* no. elements in each cell */
    size_t		n;			/* most sig. dim of cell = # in each sort */
    size_t		nc;			/* prod(other dims of cell) = # cols */
    size_t		nc_s;			/* # bytes in row = nc * s */
    char		**pv;			/* vector of pointers to data values */
    char		*pv0;			/* pointer to sub-array */
    size_t		s;
    Nap_NAO		*result;
    int			verb_rank;

    assert(str1);
    naoPtr = Nap_GetNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr, "m4NAME: Error calling Nap_GetNaoFromId");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (str2) {
	nao_verb_rank = Nap_GetNaoFromId(nap_cd, str2);
	CHECK2NULL(nao_verb_rank, "m4NAME: Error calling Nap_GetNaoFromId");
	Nap_IncrRefCount(nap_cd, nao_verb_rank);
	CHECK2NULL(nao_verb_rank->rank == 0, "m4NAME: Verb-rank is not scalar");
	nao_tmp = Nap_CastNAO(nap_cd, nao_verb_rank, NAP_I32);
	CHECK2NULL(nao_tmp, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, nao_tmp);
	verb_rank = Min(naoPtr->rank, nao_tmp->data.I32[0]);
	Nap_DecrRefCount(nap_cd, nao_tmp);
	Nap_DecrRefCount(nap_cd, nao_verb_rank);
    } else {
	verb_rank = naoPtr->rank;
    }
    result = Nap_DupNAO(nap_cd, naoPtr);
    CHECK2NULL(result, "m4NAME: error calling Nap_DupNAO");
    if (verb_rank > 0) {
	frame_rank = naoPtr->rank - verb_rank;
	s = Nap_SizeOf(naoPtr->dataType);
	nCells = 1;
	for (i = 0; i < frame_rank; i++) {
	    nCells *= naoPtr->shape[i];
	}
	m = naoPtr->nels / nCells;
	n = naoPtr->shape[frame_rank];
	nc = m / n;
	nc_s = nc * s;
	pv = (char **) NAP_ALLOC(nap_cd, n * sizeof(char *));
	for (c = 0; c < nCells; c++) {
	    for (j = 0; j < nc; j++) {
		pv0 = naoPtr->data.c + (c * m + j) * s;
		for (i = 0; i < n; i++) {
		    pv[i] = pv0 + i * nc_s;
		}
		switch (naoPtr->dataType) {
		    m4ForAllUnboxedDataType(`m4sort(', `)')
		    default:                /* error */
			return NULL;
		}
		pv0 = result->data.c + (c * m + j) * s;
		for (i = 0; i < n; i++) {
		    (void) memcpy(pv0 + i * nc_s, pv[i], s);
		}
	    }
	}
	NAP_FREE(nap_cd, pv);
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return result->id;
}

/*
 * Nap_isort --
 *	Called by following unary sort operators:
 *	    '>=' which sorts vector into ascending order
 *	    '<=' which sorts vector into descending order
 *
 *	Consider NaN < -infinity
 *	Other missing values simply treated as having their numeric value.
 */

EXTERN char *
Nap_isort(
    NapClientData	*nap_cd, 
    char		*str1,			/* argument nao */
    int			is_ascending)		/* 1 = ascending, 0 = descending */
{
    Nap_NAO		*naoPtr;		/* main nao */
    size_t		i;			/* subscript */
    size_t		n;			/* nels */
    char		**pv;			/* vector of pointers to data values */
    size_t		s;
    Nap_NAO		*result;

    assert(str1);
    naoPtr = Nap_GetNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr, "m4NAME: Error calling Nap_GetNaoFromId");
    Nap_IncrRefCount(nap_cd, naoPtr);
    CHECK2NULL(naoPtr->rank == 1, "m4NAME: Argument is not vector");
    n = naoPtr->nels;
    pv = (char **) NAP_ALLOC(nap_cd, n * sizeof(char *));
    s = Nap_SizeOf(naoPtr->dataType);
    for (i = 0; i < n; i++) {
	pv[i] = naoPtr->data.c + i * s;
    }
    switch (naoPtr->dataType) {
	m4ForAllUnboxedDataType(`m4sort(', `)')
	default:                /* error */
	    return NULL;
    }
    result = Nap_NewNAO(nap_cd, NAP_I32, 1, naoPtr->shape);
    CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
    if (is_ascending) {
	for (i = 0; i < n; i++) {
	    result->data.I32[i] = (pv[i] - naoPtr->data.c) / s;
	}
    } else {
	for (i = 0; i < n; i++) {
	    result->data.I32[i] = (pv[n-i-1] - naoPtr->data.c) / s;
	}
    }
    NAP_FREE(nap_cd, pv);
    Nap_DecrRefCount(nap_cd, naoPtr);
    return result->id;
}

/*
 *  Nap_Transpose --
 *	nap function "transpose(a ?,order?)"
 *	2nd argument specifies new order of old dimensions. If type C8 then either dim. names or
 *	int values.
 *	If only 1 arg then dimension order is reversed.
 */

m4define(`m4NAME', `Nap_Transpose')

static char *
Nap_Transpose(
    NapClientData       *nap_cd,
    char		*str1,
    char		*str2)
{
    int			found;			/* Has match been found? */
    size_t		i;
    long		indexOld[NAP_MAX_RANK];
    Tcl_Interp		*interp = nap_cd->interp;
    int			j;
    size_t		k;
    Tcl_Obj		*listPtr;		/* list defined by type C8 order arg */
    int			n;			/* # elements in order arg */
    Nap_NAO		*naoArray;		/* array to be transposed */
    Nap_NAO		*naoOrder;		/* new order of dimensions */
    Nap_NAO		*naoResult;
    Nap_NAO		*naoTmp;
    Tcl_Obj		*objPtr;		/* element of list listPtr */
    int			order[NAP_MAX_RANK];
    int			rank;			/* of naoArray & naoResult */
    size_t		shape[NAP_MAX_RANK];
    long		shapeLong[NAP_MAX_RANK];
    int			status;

    naoArray = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoArray, "m4NAME: Illegal x in 'transpose(a ?,order?)'");
    Nap_IncrRefCount(nap_cd, naoArray);
    naoOrder = Nap_GetNumericNaoFromId(nap_cd, str2);
    rank = naoArray->rank;
    if (naoOrder) {
	Nap_IncrRefCount(nap_cd, naoOrder);
	if (naoOrder->dataType == NAP_C8) {
	    listPtr = Tcl_NewStringObj(naoOrder->data.c, naoOrder->nels);
	    Tcl_IncrRefCount(listPtr);
	    status = Tcl_ListObjLength(interp, listPtr, &n);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Tcl_ListObjLength");
	    for (i = 0; i < n; i++) {
		status = Tcl_ListObjIndex(interp, listPtr, i, &objPtr);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Tcl_ListObjIndex");
		Tcl_IncrRefCount(objPtr);
		order[i] = Nap_StrToDimNum(nap_cd, naoArray, Tcl_GetString(objPtr));
		CHECK2NULL(order[i] >= 0, "m4NAME: illegal dimension name/number");
		Tcl_DecrRefCount(objPtr);
	    }
	    Tcl_DecrRefCount(listPtr);
	} else {
	    naoTmp = Nap_CastNAO(nap_cd, naoOrder, NAP_I16);
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    n = naoTmp->nels;
	    for (i = 0; i < n; i++) {
		order[i] = naoTmp->data.I16[i];
	    }
	    Nap_DecrRefCount(nap_cd, naoTmp);
	}
	Nap_DecrRefCount(nap_cd, naoOrder);
	for (i = n; i < rank; i++) {
	    for (j = 0; j < rank; j++) {
		found = FALSE;
		for (k = 0; k < i; k++) {
		    found = found || j == order[k];
		}
		if (!found) {
		    order[i] = j;
		    break;
		}
	    }
	}
    } else {
	for (i = 0; i < rank; i++) {
	    order[i] = rank - i - 1;
	}
    }
    for (i = 0; i < rank; i++) {
	order[i] = Nap_mod(order[i], rank);
	shapeLong[i] = naoArray->shape[i];
	shape[i] = naoArray->shape[order[i]];
    }
    naoResult = Nap_NewNAO(nap_cd, naoArray->dataType, rank, shape);
    Nap_IncrRefCount(nap_cd, naoResult);
    for (i = 0; i < rank; i++) {
	j = order[i];
	naoTmp = Nap_GetCoordVar(nap_cd, naoArray, j);
	Nap_IncrRefCount(nap_cd, naoTmp);
	status = Nap_AttachCoordVar(nap_cd, naoResult, naoTmp, naoArray->dimName[j], i);
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    for (i = 0; i < rank-1; i++) {
	shape[i] = shape[i+1];
    }
    shape[rank-1] = Nap_SizeOf(naoArray->dataType);
    for (i = 0; i < naoArray->nels; i++) {
	status = mixedBase(i, rank-1, shapeLong+1, indexOld);
	CHECK2NULL(status == 0, "m4NAME: Dimension has size 0");
	k = 0;
	for (j = 0; j < rank; j++) {
	    k = (k + indexOld[order[j]]) * shape[j];
	}
	memcpy(naoResult->data.c + k, naoArray->data.c + i * shape[rank-1], shape[rank-1]);
    }
    Nap_DecrRefCount(nap_cd, naoArray);
    --naoResult->count;
    return naoResult->id;
}

m4begin

#	m4Count(oldDataType)  e.g. m4Count(U8)
m4define(`m4Count', `
	    case m4DataTypeEnum($1):
		for (m = 0; m < frameNels; m++) {
		    j0 = m * newCellNels;
		    i0next = i  + cellNels;
		    jfinal = j0 + newCellNels - 1;
		    for (j = j0; i < i0next; i++) {
			new->data.I32[j] += ! IsMissing(old, i);
			j = j < jfinal ? j + 1 : j0;
		    }
		}
		break;')

#	m4Count0 is optimised code for verb-rank of 0 (simple test for missing)
#	m4Count0(oldDataType)  e.g. m4Count0(U8)
m4define(`m4Count0', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.I32[j] = ! IsMissing(old, j);
		}
		break;')

#	m4Sum2(newDataType,oldDataType)  e.g. m4Sum2(F32, U8)
m4define(`m4Sum2', `
		    case m4DataTypeEnum($2):
			for (m = 0; m < frameNels; m++) {
			    j0 = m * newCellNels;
			    i0next = i  + cellNels;
			    jfinal = j0 + newCellNels - 1;
			    for (j = j0; i < i0next; i++) {
				if (! IsMissing(old, i)) {
				    new->data.$1[j] += old->data.$2[i];
				}
				j = j < jfinal ? j + 1 : j0;
			    }
			}
			break;')

#	m4Sum(newDataType)  e.g. m4Sum(F32)
m4define(`m4Sum', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = 0.0;
		}
		switch (old->dataType) {
		    m4ForAllNumericDataType(`m4Sum2($1,', `)')
		}
		break;')

#	m4Prod2(newDataType,oldDataType)  e.g. m4Prod2(F32, U8)
m4define(`m4Prod2', `
		    case m4DataTypeEnum($2):
			for (m = 0; m < frameNels; m++) {
			    j0 = m * newCellNels;
			    i0next = i  + cellNels;
			    jfinal = j0 + newCellNels - 1;
			    for (j = j0; i < i0next; i++) {
				if (! IsMissing(old, i)) {
				    if (old->data.$2[i] > 0) {
					new->data.$1[j] += log(old->data.$2[i]);

#if ! Nap_TypeIsUnsignedIntegerValue($2)
				    } else if (old->data.$2[i] < 0) {
					signProd->data.I8[j] *= -1;
					new->data.$1[j] += log(-old->data.$2[i]);
#endif
				    } else {
					signProd->data.I8[j] = 0;
				    }
				}
				j = j < jfinal ? j + 1 : j0;
			    }
			}
			break;')

#	m4Prod(newDataType)  e.g. m4Prod(F32)
m4define(`m4Prod', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = 0.0;
		    signProd->data.I8[j] = 1;
		}
		switch (old->dataType) {
		    m4ForAllNumericDataType(`m4Prod2($1,', `)')
		}
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = signProd->data.I8[j] * exp(new->data.$1[j]);
		}
		break;')

#	m4Min(DataType)  e.g. m4Min(U8)
m4define(`m4Min', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = m4DataTypeEnum($1)_MAX;
		}
		for (m = 0; m < frameNels; m++) {
		    j0 = m * newCellNels;
		    i0next = i  + cellNels;
		    jfinal = j0 + newCellNels - 1;
		    for (j = j0; i < i0next; i++) {
			if (! IsMissing(old, i)) {
			    new->data.$1[j] = Min(new->data.$1[j], old->data.$1[i]);
			}
			j = j < jfinal ? j + 1 : j0;
		    }
		}
		break;')

#	m4Max(DataType)  e.g. m4Max(U8)
m4define(`m4Max', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = m4DataTypeEnum($1)_MIN;
		}
		for (m = 0; m < frameNels; m++) {
		    j0 = m * newCellNels;
		    i0next = i  + cellNels;
		    jfinal = j0 + newCellNels - 1;
		    for (j = j0; i < i0next; i++) {
			if (! IsMissing(old, i)) {
			    new->data.$1[j] = Max(new->data.$1[j], old->data.$1[i]);
			}
			j = j < jfinal ? j + 1 : j0;
		    }
		}
		break;')

m4end

/*
 * Nap_Reduce --
 *	Reduction: count, sum, prod, min or max.
 *
 *	Based on 'insert' adverb in J.
 *	Default verb_rank is infinity, which (like any other value > old_rank)
 *	is treated as old_rank.
 *
 *	If verb_rank > 0 then new_rank = old_rank - 1;
 *
 *	If verb_rank = old_rank then reduce over leading dimension, which is
 *	thus absent from new shape.
 *
 *	If verb_rank < old_rank then split old shape into 'frame' & 'cell'.
 *	Each cell has rank = verb_rank & shape from trailing dimensions of
 *	argument.  Frame has rank = (old_rank-verb_rank) & shape from leading
 *	dimensions of argument.  Thus we can treat the argument as a frame of
 *	cells.  The verb (e.g. sum) is applied to each cell giving a result
 *	whose shape excludes the leading cell dimension.  Then these results
 *	are combined within the frame.
 */

m4define(`m4NAME', `Nap_Reduce')

Nap_NAO *
Nap_Reduce(
    NapClientData	*nap_cd, 
    char		*name,			/* function name e.g. "sum" */
    Nap_NAO		*old,			/* pointer to source data nao */
    Nap_NAO		*verbRankNaoPtr)	/* pointer to verb rank nao */
{
    size_t		cellNels;		/* # elements in cell */
    size_t		*cellShape;		/* shape of each cell */
    Nap_NAO             *coordNaoPtr;		/* coordinate variable */
    int			d;			/* dimension subscript */
    char                *dimName;		/* dimension name */
    size_t		i;			/* input subscript */
    int			frameRank;		/* rank of frame */
    size_t		frameNels;		/* # elements in frame */
    size_t		i0next;			/* starting value of i in */
						/* following verb application */
    size_t		j;			/* output subscript */
    size_t		j0;			/* starting value of j */
    size_t		jfinal;			/* final value of j */
    size_t		m;			/* verb application count */
    Nap_NAO		*new = NULL;		/* pointer to result nao */
    size_t		newCellNels;		/* # elements in new cell */
    int			newRank;		/* rank of result */
    Nap_dataType	newDataType;		/* data-type of result */
    size_t		newShape[NAP_MAX_RANK];	/* shape of result */
    int			rankDecrease;		/* old-rank - newRank */
    Nap_NAO		*signProd;		/* nao giving sign of product */
    int			status;
    Nap_NAO		*tmpNao;		/* pointer to temp. nao */
    int			verbRank;		/* rank of source for each application of verb */

    assert(name);
    if (       strcmp(name, "count") != 0
    	    && strcmp(name, "sum")   != 0
    	    && strcmp(name, "prod")  != 0
    	    && strcmp(name, "min")   != 0
    	    && strcmp(name, "max")   != 0) {
	return NULL;
    }
    assert(old);
    assert(old->id);
    assert(Nap_IsNAO(nap_cd, old));
    CHECK2NULL(Nap_TypeIsNumeric(old->dataType), "m4NAME: Non-numeric argument");
    if (verbRankNaoPtr) {
	assert(verbRankNaoPtr->id);
	assert(Nap_IsNAO(nap_cd, verbRankNaoPtr));
	CHECK2NULL(verbRankNaoPtr->nels == 1, "m4NAME: Illegal verb-rank");
	tmpNao = Nap_CastNAO(nap_cd, verbRankNaoPtr, NAP_F64);
	CHECK2NULL(tmpNao, "m4NAME: Error calling Nap_CastNAO");
	verbRank = Min(old->rank, tmpNao->data.F64[0]);
	if (tmpNao != verbRankNaoPtr) {
	    Nap_FreeNAO(nap_cd, tmpNao);
	}
    } else {
	verbRank = old->rank;
    }
    if (verbRank < 0) {
	verbRank = Max(0, verbRank + old->rank);
    }
    if (strcmp(name, "count") == 0) {
	newDataType = NAP_I32;
    } else if (strcmp(name, "sum") == 0  ||   strcmp(name, "prod") == 0) {
	newDataType = Max(m4DataTypeEnum(m4MinRealDataType), old->dataType);
	newDataType = Min(m4DataTypeEnum(m4MaxRealDataType), newDataType);
    } else if (strcmp(name, "min") == 0  &&  old->nels == 0) {
	newDataType = NAP_F64;
    } else if (strcmp(name, "max") == 0  &&  old->nels == 0) {
	newDataType = NAP_F64;
    } else {
	newDataType = old->dataType;
    }
    frameRank = old->rank - verbRank;
    rankDecrease = verbRank > 0;
    newRank = old->rank - rankDecrease;
    for (d = 0; d < newRank; d++) {
	i = d + rankDecrease * (d >= frameRank);
	newShape[d] = old->shape[i];
    }
    cellShape = old->shape + old->rank - verbRank;
    new = Nap_NewNAO(nap_cd, newDataType, newRank, newShape);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    for (d = 0; d < newRank; d++) {
	i = d + rankDecrease * (d >= frameRank);
        coordNaoPtr = Nap_GetCoordVar(nap_cd, old, i);
        dimName = old->dimName[i];
        status = Nap_AttachCoordVar(nap_cd, new, coordNaoPtr, dimName, d);
        CHECK1NULL(status == TCL_OK);
    }
    cellNels = 1;
    for (d = 0; d < verbRank; d++) {
	cellNels *= cellShape[d];
    }
    frameNels = cellNels == 0 ? 0 : old->nels / cellNels;
    newCellNels = frameNels == 0 ? 0 : new->nels / frameNels;
    i = 0;
    if (strcmp(name, "count") == 0) {
	if (verbRank == 0) {
	    switch (old->dataType) {
		m4ForAllNumericDataType(`m4Count0(', `)')
		default:            /* error */
		    assert(FALSE);
	    }
	} else {
	    for (j = 0; j < new->nels; j++) {
		new->data.I32[j] = 0;
	    }
	    switch (old->dataType) {
		m4ForAllNumericDataType(`m4Count(', `)')
		default:            /* error */
		    assert(FALSE);
	    }
	}
    } else if (strcmp(name, "sum") == 0) {
	new->unit = Nap_StrDup(nap_cd, old->unit);
	switch (newDataType) {
	    m4ForAllNumericDataType(`m4Sum(', `)')
	    default:            /* error */
		assert(FALSE);
	}
    } else if (strcmp(name, "prod") == 0) {
	signProd = Nap_NewNAO(nap_cd, NAP_I8, newRank, newShape);
	CHECK2NULL(signProd, "m4NAME: Error calling Nap_NewNAO");
	switch (newDataType) {
	    m4ForAllNumericDataType(`m4Prod(', `)')
	    default:            /* error */
		assert(FALSE);
	}
	Nap_FreeNAO(nap_cd, signProd);
    } else if (strcmp(name, "min") == 0) {
	new->unit = Nap_StrDup(nap_cd, old->unit);
	switch (newDataType) {
	    m4ForAllNumericDataType(`m4Min(', `)')
	    default:            /* error */
		assert(FALSE);
	}
    } else if (strcmp(name, "max") == 0) {
	new->unit = Nap_StrDup(nap_cd, old->unit);
	switch (newDataType) {
	    m4ForAllNumericDataType(`m4Max(', `)')
	    default:            /* error */
		assert(FALSE);
	}
    } else {
	new = NULL;
    }
    return new;
}


/*
 *  Nap_CorrelationStore --
 *
 *  Called by Nap_Correlation & Nap_MovingCorrelation
 */

m4begin

#	m4corr(DataType)  e.g. m4corr(F32)
m4define(`m4corr', `
	    case m4DataTypeEnum($1):
		znao->data.$1[i] = z;
		znao->data.$1[j] = n;
		break;')

m4define(`m4NAME', `Nap_CorrelationStore')

m4end

static int
Nap_CorrelationStore(
    double		n,
    double		sumx,
    double		sumx2,
    double		sumy,
    double		sumy2,
    double		sumxy,
    Nap_NAO		*znao,			/* result */
    int			i,			/* index of correlation */
    int			j)			/* index of n */
{
    double		z;			/* result */
    z = (n * sumxy - sumx * sumy) / sqrt((n * sumx2 - Sq(sumx)) * (n * sumy2 - Sq(sumy)));
    switch (znao->dataType) {
    m4ForAllRealDataType(`m4corr(', `)')
    default:            /* error */
	assert(FALSE);
    }
    return TCL_OK;
}

/*
 *  Nap_Correlation --
 *
 *  Nap function 'correlation(x, ?y?)'
 *
 *  Calculates Pearson product-moment correlations between x & y.
 *  If y is not specified then it defaults to x.
 *
 *  The 1st (most significant) dimensions of x & y must have the same size, since this corresponds
 *  to the number of cases. (For time-series this dimensions is time.)
 *  The remaining dimensions (if any) of x & y are essentially merged into column dimensions,
 *  but do appear in the result.
 *
 *  For example, let x be a matrix with shape {80 3} & y a matrix with shape {80 5}. The command
 *  nap "r = correlation(x, y)"
 *  produces an array r with shape {2 3 5}.
 *  r(0,i,j) is the correlation between column i of x & column j of y.
 *  r(1,i,j) is the number of cases (sample size 'n') used to calculate r(0,i,j).
 *  (A case is omitted if either the x or y value is missing.)
 *
 *  If x or y is f64 then result is f64, else it is f32.
 */

m4define(`m4NAME', `Nap_Correlation')

static char *
Nap_Correlation(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_NAO		*arg;			/* argument (x or y) */
    Nap_dataType        dataType;		/* of result */
    int			i;			/* subscript */
    int			ix;			/* row of x */
    int			iz;			/* row of z */
    int			j;			/* subscript */
    int			jz;			/* column of z */
    double		n;			/* # elements in x */
    int			ncx;			/* # columns in x */
    int			ncy;			/* # columns in y */
    int			nr;			/* # rows in x & y (# cases) */
    size_t		shape[NAP_MAX_RANK];
    int			status;
    double		sumx;			/* sum(x) */
    double		sumx2;			/* sum(x*x) */
    double		sumxy;			/* sum(x*y) */
    double		sumy;			/* sum(y) */
    double		sumy2;			/* sum(y*y) */
    Nap_NAO		*tmp_nao;
    Nap_NAO		*xnao;			/* x */
    Nap_NAO		*ynao;			/* y */
    Nap_NAO		*znao;			/* z = result */

    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    Nap_IncrRefCount(nap_cd, box_nao);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels > 0,  "m4NAME: No arguments");
    CHECK2NULL(box_nao->nels < 3,  "m4NAME: Too many arguments");
    arg = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    CHECK2NULL(arg, "m4NAME: Error calling Nap_GetNaoFromSlot");
    CHECK2NULL(arg->rank > 0, "m4NAME: Scalar argument");
    xnao = Nap_CastNAO(nap_cd, arg, NAP_F64);
    CHECK2NULL(xnao, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, xnao);
    dataType = Max(m4DataTypeEnum(m4MinRealDataType), arg->dataType);
    nr = xnao->shape[0];
    if (box_nao->nels > 1) {
	arg = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
	CHECK2NULL(arg, "m4NAME: Error calling Nap_GetNaoFromSlot");
	CHECK2NULL(arg->rank > 0, "m4NAME: Scalar argument");
	CHECK2NULL(nr == arg->shape[0], "m4NAME: Leading dimensions of arguments do not match");
	ynao = Nap_CastNAO(nap_cd, arg, NAP_F64);
	CHECK2NULL(ynao, "m4NAME: Error calling Nap_CastNAO");
	dataType = Max(dataType, arg->dataType);
    } else {
	ynao = xnao;
    }
    Nap_IncrRefCount(nap_cd, ynao);
    j = 0;
    shape[j++] = 2;
    for (i = 1; i < xnao->rank; i++) {
	shape[j++] = xnao->shape[i];
    }
    for (i = 1; i < ynao->rank; i++) {
	shape[j++] = ynao->shape[i];
    }
    znao = Nap_NewNAO(nap_cd, dataType, j, shape);
    CHECK2NULL(znao, "m4NAME: error calling Nap_NewNAO");
    j = 1;
    for (i = 1; i < xnao->rank; i++) {
	tmp_nao = Nap_GetCoordVar(nap_cd, xnao, i);
	status = Nap_AttachCoordVar(nap_cd, znao, tmp_nao, NULL, j++);
	CHECK1NULL(status == TCL_OK);
    }
    for (i = 1; i < ynao->rank; i++) {
	tmp_nao = Nap_GetCoordVar(nap_cd, ynao, i);
	status = Nap_AttachCoordVar(nap_cd, znao, tmp_nao, NULL, j++);
	CHECK1NULL(status == TCL_OK);
    }
    ncx = xnao->nels / nr;
    ncy = ynao->nels / nr;
    for (iz = 0; iz < ncx; iz++) {
	for (jz = 0; jz < ncy; jz++) {
	    n = sumx = sumx2 = sumy = sumy2 = sumxy = 0.0;
	    for (ix = 0; ix < nr; ix++) {
		i = iz + ncx * ix;
		j = jz + ncy * ix;
		if (!IsMissing(xnao, i)  &&  !IsMissing(ynao, j)) {
		    ++n;
		    sumx  += xnao->data.F64[i];
		    sumx2 += Sq(xnao->data.F64[i]);
		    sumy  += ynao->data.F64[j];
		    sumy2 += Sq(ynao->data.F64[j]);
		    sumxy += xnao->data.F64[i] * ynao->data.F64[j];
		}
	    }
	    status = Nap_CorrelationStore(n, sumx, sumx2, sumy, sumy2, sumxy, znao,
		    jz+iz*ncx, jz+iz*ncx+ncy*ncx);
	    CHECK1NULL(status == TCL_OK);
	}
    }
    Nap_DecrRefCount(nap_cd, xnao);
    Nap_DecrRefCount(nap_cd, ynao);
    Nap_DecrRefCount(nap_cd, box_nao);
    return znao->id;
}

/*
 *  Nap_MovingCorrelation --
 *
 *  Nap function 'moving_correlation(x, y, ?lag0?, ?lag1?)'
 *  Calculates Pearson product-moment correlations (omitting cases where either value is missing).
 *  If x or y is F64 then result is F64, else it is F32. (But calculation still done using F64.)
 *  Dimension 0 has size 2. Index 0 corresponds to the correlation values themselves, while index 1
 *  corresponds to the sample sizes (n).
 *
 *  Smaller of x & y is a window (chip) array which is moved around in other array.
 *  In this case the result is array of correlations for each position.
 *  Ranks of x and y must be the same.  (Current version supports ranks 1 & 2 only.)
 *  lag0 is vector of row    lags (default: all possible)
 *  lag1 is vector of column lags (default: all possible)
 */

m4define(`m4NAME', `Nap_MovingCorrelation')

static char *
Nap_MovingCorrelation(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_NAO		*arg0_nao;		/* 1st argument */
    Nap_NAO		*arg1_nao;		/* 2nd argument */
    Nap_NAO		*cvy[NAP_MAX_RANK];	/* coordinate variables of y */
    Nap_NAO		*cvz[NAP_MAX_RANK];	/* coordinate variables of z */
    Nap_dataType        dataType;		/* of result */
    int			i;			/* subscript */
    int			ijx0;			/* subscript of start of row of x */
    int			ijy0;			/* subscript of start of row of y */
    int			ix;			/* row of x */
    int			iz;			/* row of z */
    int			j;			/* subscript */
    int			jx;			/* column of x */
    int			jz;			/* column of z */
    Nap_NAO		*lag[NAP_MAX_RANK];	/* arguments 2, 3, ... */
    int			lag0;			/* lag in row */
    int			lag1;			/* lag in column */
    double		n;			/* # elements in x */
    int			ncx;			/* # columns in x */
    int			nrx;			/* # rows in x */
    int			ncy;			/* # columns in y */
    int			nry;			/* # rows in y */
    int			ncz;			/* # columns in z */
    int			nrz;			/* # rows in z */
    size_t		shape[NAP_MAX_RANK];
    int			status;
    double		sumx;			/* sum(x) */
    double		sumx2;			/* sum(x*x) */
    double		sumxy;			/* sum(x*y) */
    double		sumy;			/* sum(y) */
    double		sumy2;			/* sum(y*y) */
    Nap_NAO		*tmp_nao;
    Nap_NAO		*xnao;			/* x = moving window matrix */
    Nap_NAO		*ynao;			/* y = main matrix */
    Nap_NAO		*znao;			/* z = result */

    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    Nap_IncrRefCount(nap_cd, box_nao);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels > 0,  "m4NAME: No arguments");
    arg0_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    CHECK2NULL(arg0_nao, "m4NAME: Error calling Nap_GetNaoFromSlot");
    dataType = Max(m4DataTypeEnum(m4MinRealDataType), arg0_nao->dataType);
    arg1_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(arg1_nao, "m4NAME: Error calling Nap_GetNaoFromSlot");
    dataType = Max(dataType, arg1_nao->dataType);
    CHECK2NULL(arg0_nao->rank == arg1_nao->rank, "m4NAME: Rank of x differs from that of y");
    CHECK2NULL(arg0_nao->rank > 0, "m4NAME: Rank of x is 0");
    CHECK2NULL(arg0_nao->rank < 3, "m4NAME: Rank of x > 2 which is not yet supported");
    CHECK2NULL(box_nao->nels <= 2+arg0_nao->rank, "m4NAME: Too many arguments");
    if (arg0_nao->nels > arg1_nao->nels) {
	tmp_nao = arg0_nao;
	arg0_nao = arg1_nao;
	arg1_nao = tmp_nao;
    }
    shape[0] = arg0_nao->shape[0];
    shape[1] = arg0_nao->rank > 1 ? arg0_nao->shape[1] : 1;
    xnao = Nap_ReshapeNAO(nap_cd, arg0_nao, NAP_F64, 2, shape);
    CHECK2NULL(xnao, "m4NAME: Error calling Nap_ReshapeNAO");
    Nap_IncrRefCount(nap_cd, xnao);
    shape[0] = arg1_nao->shape[0];
    shape[1] = arg1_nao->rank > 1 ? arg1_nao->shape[1] : 1;
    ynao = Nap_ReshapeNAO(nap_cd, arg1_nao, NAP_F64, 2, shape);
    CHECK2NULL(ynao, "m4NAME: Error calling Nap_ReshapeNAO");
    Nap_IncrRefCount(nap_cd, ynao);
    for (i = 0; i < 2; i++) {
	tmp_nao = Nap_GetCoordVar(nap_cd, ynao, i);
	if (tmp_nao) {
	    Nap_IncrRefCount(nap_cd, tmp_nao);
	    cvy[i] = Nap_CastNAO(nap_cd, tmp_nao, NAP_F32);
	    CHECK2NULL(cvy[i], "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, cvy[i]);
	    Nap_DecrRefCount(nap_cd, tmp_nao);
	} else {
	    cvy[i] = Nap_NewNAO(nap_cd, NAP_F32, 1, ynao->shape + i);
	    CHECK2NULL(cvy[i], "m4NAME: Error calling Nap_NewNAO");
	    Nap_IncrRefCount(nap_cd, cvy[i]);
	    for (j = 0; j < cvy[i]->nels; j++) {
		cvy[i]->data.F32[j] = j;
	    }
	}
	if (box_nao->nels > i+2) {
	    tmp_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[i+2]);
	    CHECK2NULL(tmp_nao, "m4NAME: Error calling Nap_GetNaoFromSlot");
	    CHECK3NULL(tmp_nao->rank < 2, "m4NAME: Rank of lag %d > 1", i);
	    Nap_IncrRefCount(nap_cd, tmp_nao);
	    shape[0] = tmp_nao->nels;
	    lag[i] = Nap_ReshapeNAO(nap_cd, tmp_nao, NAP_I32, 1, shape);
	    CHECK2NULL(lag[i], "m4NAME: Error calling Nap_ReshapeNAO");
	    Nap_IncrRefCount(nap_cd, lag[i]);
	    Nap_DecrRefCount(nap_cd, tmp_nao);
	} else {
	    shape[0] = 1 + ynao->shape[i] - xnao->shape[i];
	    lag[i] = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	    CHECK2NULL(lag[i], "m4NAME: Error calling Nap_NewNAO");
	    Nap_IncrRefCount(nap_cd, lag[i]);
	    for (j = 0; j < lag[i]->nels; j++) {
		lag[i]->data.I32[j] = j;
	    }
	}
    }
    shape[0] = 2;
    shape[1] = nrz = lag[0]->nels;
    shape[2] = ncz = lag[1]->nels;
    znao = Nap_NewNAO(nap_cd, dataType, 1 + arg0_nao->rank, shape);
    CHECK2NULL(znao, "m4NAME: Error calling Nap_NewNAO");
    for (i = 1; i < znao->rank; i++) {
	cvz[i] = Nap_NewNAO(nap_cd, NAP_F32, 1, shape+i);
	CHECK2NULL(cvz[i], "m4NAME: Error calling Nap_NewNAO");
	status = Nap_AttachCoordVar(nap_cd, znao, cvz[i], ynao->dimName[i-1], i);
	CHECK1NULL(status == TCL_OK);
    }
    nrx = xnao->shape[0];
    ncx = xnao->shape[1];
    nry = ynao->shape[0];
    ncy = ynao->shape[1];
    CHECK2NULL(nrx <= nry  &&  ncx <= ncy, "m4NAME: Shape of x incompatible with that of y");
    for (iz = 0; iz < nrz; iz++) {
	lag0 = lag[0]->data.I32[iz];
	cvz[1]->data.F32[iz] = 0.5 * (cvy[0]->data.F32[lag0] + cvy[0]->data.F32[lag0+nrx-1]);
	for (jz = 0; jz < ncz; jz++) {
	    lag1 = lag[1]->data.I32[jz];
	    n = sumx = sumx2 = sumy = sumy2 = sumxy = 0.0;
	    if (znao->rank > 2) {
		cvz[2]->data.F32[jz]
			= 0.5 * (cvy[1]->data.F32[lag1] + cvy[1]->data.F32[lag1+ncx-1]);
	    }
	    for (ix = 0; ix < nrx; ix++) {
		ijx0 = ix * ncx;
		ijy0 = lag1 + (lag0 + ix) * ncy;
		for (jx = 0; jx < ncx; jx++) {
		    i = ijx0 + jx;
		    j = ijy0 + jx;
		    if (!IsMissing(xnao, i)  &&  !IsMissing(ynao, j)) {
			++n;
			sumx  += xnao->data.F64[i];
			sumx2 += Sq(xnao->data.F64[i]);
			sumy  += ynao->data.F64[j];
			sumy2 += Sq(ynao->data.F64[j]);
			sumxy += xnao->data.F64[i] * ynao->data.F64[j];
		    }
		}
	    }
	    status = Nap_CorrelationStore(n, sumx, sumx2, sumy, sumy2, sumxy, znao,
		    jz+iz*ncz, jz+iz*ncz+ncz*nrz);
	    CHECK1NULL(status == TCL_OK);
	}
    }
    for (i = 0; i < 2; i++) {
	Nap_DecrRefCount(nap_cd, lag[i]);
	Nap_DecrRefCount(nap_cd, cvy[i]);
    }
    Nap_DecrRefCount(nap_cd, ynao);
    Nap_DecrRefCount(nap_cd, xnao);
    Nap_DecrRefCount(nap_cd, box_nao);
    return znao->id;
}

/*
 * solve_quadratic --
 * Returns number of real solutions (0, 1 or 2)
 *
 * Reference: 
 * 	W.H. Press, et. al
 *	Numerical Recipes in C
 *	page 156
 */

m4define(`m4NAME', `solve_quadratic')

static int
solve_quadratic(
    float		a,			/* coeff of quadratic */
    float		b,			/* coeff of quadratic */
    float		c,			/* coeff of quadratic */
    float		x[2])			/* solutions (out) */
{
    double		d;			/* discriminant of quadratic */
    int			n;			/* # solutions of quadratic */
    float		q;

    d = b * b - 4.0 * a * c;
    if (a == 0.0f) {
	if (b == 0.0f) {
	    n = 0;
	} else {
	    n = 1;
	    x[0] = -c / b;
	}
    } else if (d > 0.0) {
	n = 2;
	q = (-0.5) * (b + Sign(b) * sqrt(d));
	x[0] = q / a;
	x[1] = c / q;
    } else if (d == 0.0) {
	n = 1;
	x[0] = -b / (a + a);
    } else {
	n = 0;
    }
    return n;
}

/*
 * Nap_pad --
 *
 * NAP function 'pad' which pads a ragged array to form an ordinary array.
 * 1st arg is ragged nao.  
 * 2nd arg is value for padding (default is missing value of NAO argument).  
 * All rows should have same data type.
 * If 1st argument is not ragged then this is returned as result.
 */

m4define(`m4NAME', `Nap_pad')

EXTERN char *
Nap_pad(
    NapClientData	*nap_cd, 
    char		*str1,			/* data argument */
    char		*str2)			/* value for padding */
{
    Nap_NAO		*arg2nao;		/* value for padding */
    Nap_dataType        dataType;
    int			i;			/* subscript */
    int			k0;			/* char start position */
    int			ncols;			/* # columns in result */
    int			nk;			/* s * row->nels */
    int			nrows;			/* # rows in result */
    Nap_NAO		*pad_nao;		/* value for padding */
    Nap_NAO		*ragged_nao;		/* 1st arg. */
    int                 rank;
    Nap_NAO		*row;			/* row of ragged matrix */
    Nap_NAO		*result;
    Nap_NAO		*start_nao;		/* ragged start index */
    int			s;			/* size of data type */
    int			status;
    char		*str;
    Nap_NAO		*tmp_nao;

    ragged_nao = Nap_GetNaoFromId(nap_cd, str1);
    CHECK2NULL(ragged_nao, "m4NAME: Illegal ragged in 'pad(ragged ?,pad_value?)'");
    arg2nao = Nap_GetNaoFromId(nap_cd, str2);
    if (ragged_nao->dataType == NAP_RAGGED) {
	Nap_IncrRefCount(nap_cd, ragged_nao);
	rank = ragged_nao->rank;
	CHECK2NULL(rank > 1, "m4NAME: rank of ragged array < 2");
	row = Nap_UnboxedElement1(nap_cd, ragged_nao);
	dataType = row ? row->dataType : NAP_I8;
	result = Nap_NewNAO(nap_cd, dataType, rank, ragged_nao->shape);
	CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, ragged_nao, result);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
	if (ragged_nao->missingValueSlot > 0) {
	    status = Nap_SetMissing(nap_cd, result, ragged_nao->missingValueSlot);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	}
	s = Nap_SizeOf(dataType);
	if (arg2nao) {
	    Nap_IncrRefCount(nap_cd, arg2nao);
	    pad_nao = Nap_CastNAO(nap_cd, arg2nao, dataType);
	    CHECK2NULL(pad_nao, "m4NAME: Error calling Nap_CastNAO");
	    CHECK2NULL(pad_nao->nels == 1, "m4NAME: pad_value is not scalar");
	    Nap_IncrRefCount(nap_cd, pad_nao);
	    Nap_DecrRefCount(nap_cd, arg2nao);
	    str = pad_nao->data.c;
	} else {
	    pad_nao = NULL;
	    tmp_nao = Nap_GetMissingValueNAO(nap_cd, result);
            CHECK1NULL(tmp_nao);
            str = tmp_nao->data.c;
	}
	for (i = 0; i < result->nels; i++) {	/* init with missing values */
	    memcpy(result->data.c+s*i, str, s);
	}
	start_nao = Nap_GetNaoFromSlot(ragged_nao->raggedStartSlot);
	CHECK2NULL(start_nao, "m4NAME: raggedStart NAO is NULL");
	CHECK2NULL(start_nao->dataType == NAP_I32,
		"m4NAME: raggedStart NAO not type int	");
	CHECK2NULL(start_nao->nels == ragged_nao->nels,
		"m4NAME: raggedStart NAO has wrong # elements");
        ncols = result->shape[rank-1];
        nrows = result->nels / ncols;
	for (i = 0; i < nrows; i++) {
	    row = Nap_GetNaoFromSlot(ragged_nao->data.Boxed[i]);
	    if (row) {
		nk = s * row->nels;
		k0 = s * (start_nao->data.I32[i] + ncols * i);
		memcpy(result->data.c+k0, row->data.c, nk);
	    }
	}
	Nap_DecrRefCount(nap_cd, pad_nao);
	Nap_DecrRefCount(nap_cd, ragged_nao);
    } else {
	result = ragged_nao;
    }
    return result->id;
}

/*
 * Nap_prune --
 *
 * NAP function 'prune' which is inverse of function 'pad'.  In other words it
 * compresses an ordinary array to a ragged array.
 * 1st arg is array to be compressed by removing leading & trailing padding in
 * each row.
 * 2nd arg is value of padding (default is missing value of NAO argument).  
 */

m4define(`m4NAME', `Nap_prune')

static char *
Nap_prune(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_dataType        dataType;
    int			i;			/* subscript */
    Nap_NAO		*in_nao;		/* input nao (1st arg.) */
    int			j;			/* subscript */
    int			k0;			/* char start position */
    int			n;			/* # els before this row */
    int			ncols;			/* # columns in result */
    int			newMV;			/* slot of new missing value */
    int			nk;			/* s * row->nels */
    int			npad;			/* # leading pad elements */
    int			nrows;			/* # rows in result */
    int			oldMV;			/* slot of old missing value */
    Nap_NAO		*pad_nao;		/* value for padding */
    int			rank;
    Nap_NAO		*row;			/* row of ragged matrix */
    Nap_NAO		*result;
    size_t		shape[1];
    Nap_NAO		*start_nao;		/* ragged start index */
    int			s;			/* size of data type */
    int			status;
    const char		*usage =
	"m4NAME: Usage should be 'prune(array)' or 'prune(array, pad_value)'";

    assert(box_nao);
    CHECK2NULL(box_nao->dataType == NAP_BOXED, "m4NAME: Argument not boxed");
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels == 1  ||  box_nao->nels == 2, usage);
    in_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    if (in_nao->dataType == NAP_RAGGED  ||  in_nao->rank < 2) {
	result = in_nao;
    } else {
	dataType = in_nao->dataType;
	rank = in_nao->rank;
	newMV = oldMV = in_nao->missingValueSlot;
        if (box_nao->nels == 2) {
            pad_nao = Nap_CastNAO(nap_cd, Nap_GetNaoFromSlot(box_nao->data.Boxed[1]), dataType);
	    CHECK2NULL(pad_nao, "m4NAME: Error calling Nap_CastNAO");
            CHECK2NULL(pad_nao->nels == 1, "m4NAME: pad_value is not scalar");
	    Nap_IncrRefCount(nap_cd, pad_nao);
	    newMV = pad_nao->slot;
	    status = Nap_SetMissing(nap_cd, in_nao, newMV);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	    Nap_DecrRefCount(nap_cd, pad_nao);
	}
	result = Nap_NewNAO(nap_cd, NAP_RAGGED, in_nao->rank, in_nao->shape);
	CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, in_nao, result);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
	status = Nap_SetMissing(nap_cd, result, newMV);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	s = Nap_SizeOf(dataType);
	ncols = in_nao->shape[rank-1];
	nrows = in_nao->nels / ncols;
	shape[0] = nrows;
	start_nao = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	CHECK2NULL(start_nao, "m4NAME: Error calling Nap_NewNAO");
	result->raggedStartSlot = start_nao->slot;
	Nap_IncrRefCount(nap_cd, start_nao);
	for (i = 0; i < result->nels; i++) {
	    n = ncols * i;
	    npad = 0;
	    for (j = 0; j < ncols && IsMissing(in_nao,n+j); j++) {
		++npad;
	    }
	    start_nao->data.I32[i] = npad;
	    shape[0] = ncols - npad;
	    if (npad < ncols) {
		for (j = ncols -1; IsMissing(in_nao,n+j); j--) {
		    --shape[0];
		}
	    }
	    if (shape[0] > 0) {
		row = Nap_NewNAO(nap_cd, dataType, 1, shape);
		CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
		status = Nap_SetMissing(nap_cd, row, newMV);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
		result->data.Boxed[i] = row->slot;
		Nap_IncrRefCount(nap_cd, row);
		nk = s * row->nels;
		k0 = s * (start_nao->data.I32[i] + n);
		memcpy(row->data.c, in_nao->data.c + k0, nk);
	    } else {
		result->data.Boxed[i] = 0;
	    }
	}
        if (newMV != oldMV) {	/* restore old missing value */
	    status = Nap_SetMissing(nap_cd, in_nao, oldMV);
            CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	}
    }
    return result->id;
}

/*
 * Nap_psum1 --
 *	Partial-sum function psum1(v)
 *	Each element of result is partial sum in direction defined by verb rank
 */

m4begin

m4define(`m4NAME', `Nap_psum1')

#	m4psum_mv(type) -- change missing values to 0
m4define(`m4psum_mv', `
	case m4DataTypeEnum($1):
	    for (j = 0; j < result->nels; j++) {
		if (IsMissing(result, j)) {
		    result->data.$1[j] = 0;
		}
	    }
	    break;')

#	m4psum1(DataType)  e.g. m4psum1(U8)
m4define(`m4psum1', `
	    case m4DataTypeEnum($1):
		for (m = 0; m < frameNels; m++) {
		    j0 = m * cellNels;
		    jlimit = j0 + cellNels;
		    for (j = j0 + n; j < jlimit; j++) {
			result->data.$1[j] += result->data.$1[j-n];
		    }
		}
		break;')

m4end

static char *
Nap_psum1(
    NapClientData	*nap_cd, 
    char		*str1,			/* data argument */
    char		*str2)			/* verb-rank argument */
{
    size_t		cellNels;		/* # elements in cell */
    size_t		*cellShape;		/* shape of each cell */
    long		d;			/* dimension subscript */
    size_t		frameNels;		/* # elements in frame */
    size_t		j;			/* output subscript */
    size_t		j0;
    size_t		jlimit;
    size_t		m;			/* verb application count */
    size_t		n;			/* # elements in each item of cell */
    Nap_NAO		*result;
    Nap_NAO		*tmpNao;		/* pointer to temp. nao */
    int			verbRank;
    Nap_NAO		*verbRankNaoPtr;	/* pointer to verb rank nao */
    Nap_NAO		*x;			/* data argument */

    x = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(x, "m4NAME: Illegal x in 'psum1(x ?,verbRank?)'");
    verbRankNaoPtr= Nap_GetNumericNaoFromId(nap_cd, str2);
    if (verbRankNaoPtr) {
	assert(verbRankNaoPtr->id);
	assert(Nap_IsNAO(nap_cd, verbRankNaoPtr));
	Nap_IncrRefCount(nap_cd, verbRankNaoPtr);
	CHECK2NULL(verbRankNaoPtr->nels == 1, "m4NAME: Illegal verb-rank");
	tmpNao = Nap_CastNAO(nap_cd, verbRankNaoPtr, NAP_F64);
	CHECK2NULL(tmpNao, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, tmpNao);
	verbRank = Min(x->rank, tmpNao->data.F64[0]);
	Nap_DecrRefCount(nap_cd, tmpNao);
	Nap_DecrRefCount(nap_cd, verbRankNaoPtr);
	if (verbRank < 0) {
	    verbRank = Max(0, verbRank + x->rank);
	}
    } else {
	verbRank = x->rank;
    }
    result = Nap_DupNAO(nap_cd, x);
    CHECK2NULL(result, "m4NAME: error calling Nap_DupNAO");
    switch (x->dataType) {
	m4ForAllNumericDataType(`m4psum_mv(', `)')
	default:                /* error */
	    return NULL;
    }
    if (x->rank > 0) {
	cellShape = x->shape + x->rank - verbRank;
	cellNels = 1;
	for (d = 0; d < verbRank; d++) {
	    cellNels *= cellShape[d];
	}
	frameNels = cellNels == 0 ? 0 : x->nels / cellNels;
	n = cellNels / cellShape[0];
	switch (x->dataType) {
	    m4ForAllNumericDataType(`m4psum1(', `)')
	    default:            /* error */
		assert(FALSE);
	}
    }
    return result->id;
}

/*
 * Nap_psum --
 *	Partial-sum function psum(v)
 *	Each element of result is sum of entire argument between it and origin 
 */

m4begin

m4define(`m4NAME', `Nap_psum')

#	m4psum_mv(type) -- change missing values to 0
m4define(`m4psum_mv', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < result->nels; i++) {
		if (IsMissing(result, i)) {
		    result->data.$1[i] = 0;
		}
	    }
	    break;')

#	m4psum1(type) -- rank = 1
m4define(`m4psum1', `
	case m4DataTypeEnum($1):
	    for (i = 1; i < result->nels; i++) {
		result->data.$1[i] += result->data.$1[i-1];
	    }
	    break;')

#	m4psum2(type) -- rank = 2
m4define(`m4psum2', `
	case m4DataTypeEnum($1):
	    for (j = 1; j < ncols; j++) {
		result->data.$1[j] += result->data.$1[j-1];
	    }
	    for (i = 1; i < nrows; i++) {
		result->data.$1[ncols*i] += result->data.$1[ncols*(i-1)];
		for (j = 1; j < ncols; j++) {
		    result->data.$1[ncols*i+j] += result->data.$1[ncols*(i-1)+j]
			    + result->data.$1[ncols*i+j-1]
			    - result->data.$1[ncols*(i-1)+j-1];
		}
	    }
	    break;')

#	m4psum(type) -- any rank > 0
m4define(`m4psum', `
	case m4DataTypeEnum($1):
	    for (i = 1; i < result->nels; i++) {
		status = mixedBase(i, rank-1, shape+1, index);
		CHECK2NULL(!status, "m4NAME: Error calling mixedBase");
		for (j = 1; j < n; j++) {
		    s = -1;
		    k = i;
		    for (d = 0; d < rank; d++) {
			bit = 1 & (j >> d);
			s *= (1 - bit - bit) * (index[d] >= bit);
			k -= bit * w[d];
		    }
		    switch (s) {
			case -1: result->data.$1[i] -= result->data.$1[k]; break;
			case  0: break;
			case  1: result->data.$1[i] += result->data.$1[k]; break;
			default: assert(0);	/* error */
		    }
		}
	    }
	    break;')
m4end

static char *
Nap_psum(
    NapClientData	*nap_cd, 
    Nap_NAO		*naoPtr)		/* data */
{
    long		bit;			/* 0 or 1 */
    long		d;			/* dimension subscript */
    long		i;			/* subscript */
    long		index[NAP_MAX_RANK];	/* subscripts for general rank */
    long		j;			/* subscript */
    long		k;			/* subscript */
    const long		max_rank = sizeof(long) * CHAR_BIT - 2;
    long		n;			/* pow(2,rank) */
    long		ncols;			/* for rank 2 */
    long		nrows;			/* for rank 2 */
    long		rank = naoPtr->rank;
    Nap_NAO		*result;
    int			s;			/* sign (-1, 0 or +1) */
    long		shape[NAP_MAX_RANK];
    int			status;
    long		w[NAP_MAX_RANK];	/* weights for indexing */

    assert(naoPtr);
    result = Nap_DupNAO(nap_cd, naoPtr);
    CHECK2NULL(result, "m4NAME: error calling Nap_DupNAO");
    switch (naoPtr->dataType) {
	m4ForAllNumericDataType(`m4psum_mv(', `)')
	default:                /* error */
	    return NULL;
    }
    switch (rank) {
	case 0:
	    break;
	case 1:
	    switch (naoPtr->dataType) {
		m4ForAllNumericDataType(`m4psum1(', `)')
		default:                /* error */
		    return NULL;
	    }
	    break;
	case 2:
	    nrows = result->shape[0];
	    ncols = result->shape[1];
	    switch (naoPtr->dataType) {
		m4ForAllNumericDataType(`m4psum2(', `)')
		default:                /* error */
		    return NULL;
	    }
	    break;
	default:
	    for (d = 0; d < rank; d++) {
		shape[d] = result->shape[d];
	    }
	    w[rank-1] = 1;
	    for (d = rank-1; d > 0; d--) {
		w[d-1] = w[d] * shape[d];
	    }
	    CHECK4NULL(rank < max_rank, "m4NAME: rank = %ld which exceeds maximum of %ld",
		    rank, max_rank);
	    n = 1L << rank;
	    switch (naoPtr->dataType) {
		m4ForAllNumericDataType(`m4psum(', `)')
		default:                /* error */
		    return NULL;
	    }
    }
    return result->id;
}


/*
 * Nap_invert_grid --
 */

m4define(`m4NAME', `Nap_invert_grid')

#define MAX_GRID_RANK 2

static char *
Nap_invert_grid(
    NapClientData	*nap_cd, 
    char		*str,			/* id of box nao */
    int			trim)			/* 1 = invert_grid, 0 = invert_grid_no_trim */
{
    float		a;			/* coeff of quadratic */
    float		b;			/* coeff of quadratic */
    float		bc;			/* const in formula for b */
    Nap_NAO		*box_nao;		/* points to user's arguments */
    float		c;			/* coeff of quadratic */
    float		cc;			/* const in formula for c */
    float		d2;			/* squared length of diagonal */
    float		*d2save;		/* saved squared length of diagonal */
    float		delta;			/* tolerance in CV */
    const float		eps = 1E-4;		/* delta = eps * range_of_CV */
    const float		epsilon = 0.02;		/* tolerance in line/pixel */
    float		fmin[MAX_GRID_RANK];	/* lower value of index0/1 */
    float		fmax[MAX_GRID_RANK];	/* upper value of index0/1 */
    float		frange[MAX_GRID_RANK];	/* frange[k] = fmax[k] - fmin[k] */
    float		h[2][4];		/* coeff's of hyperboloids */
    const float		highest = 1.0+epsilon;	/* max line/pixel */
    int			i;			/* subscript 0 of input nao */
    float		ii;			/* fractional extension of i */
    int			imin[MAX_GRID_RANK];	/* lower value of index0/1 */
    int			imax[MAX_GRID_RANK];	/* upper value of index0/1 */
    int			index0;			/* subscript 0 of output nao */
    int			index1;			/* subscript 1 of output nao */
    int			j;			/* subscript 1 of input nao */
    int			j00;			/* index of left bottom corner */
    int			j01;			/* index of right bottom corner */
    int			j10;			/* index of left top corner */
    int			j11;			/* index of right top corner */
    float		jj[2];			/* solution for fractional extension of j */
    int			k;			/* subscript */
    int			kk;			/* subscript */
    const float		lowest = -epsilon;	/* min line/pixel */
    Nap_NAO		*main_nao[MAX_GRID_RANK]; /* user arg */
    float		maxValue;
    float		minValue;
    int			n;			/* # solutions of quadratic */
    float		*new_cv[MAX_GRID_RANK];	/* new_cv_nao->data */
    Nap_NAO		*new_cv_nao[MAX_GRID_RANK]; /* subset of user arg */
    float		*old_cv[MAX_GRID_RANK];	/* old_cv_nao->data */
    Nap_NAO		*old_cv_nao[MAX_GRID_RANK]; /* CV of main_nao */
    int			rank;			/* rank of main_nao */
    Nap_NAO		*result;
    size_t		shape[MAX_GRID_RANK+1];	/* shape of result */
    int			shape_main[MAX_GRID_RANK]; /* shape of main_nao */
    int			status;
    float		tmp;			/* temporary value */
    Nap_NAO		*tmp_nao1;		/* temporary nao pointer */
    Nap_NAO		*tmp_nao2;		/* temporary nao pointer */
    float		value;			/* temporary value */
    float		w0;			/* weight of lower point */
    float		w1;			/* weight of higher point */
    float		x0;			/* new_cv[0] value e.g. lat */
    float		x1;			/* new_cv[1] value e.g. lon */
    float		z00;	/* main_nao value in left bottom corner */
    float		z01;	/* main_nao value in right bottom corner */
    float		z10;	/* main_nao value in left top corner */
    float		z11;	/* main_nao value in right top corner */

    assert(str);
    box_nao = Nap_GetNaoFromId(nap_cd, str);
    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels % 2 == 0, "m4NAME: Odd # elements (arguments)");
    CHECK2NULL(box_nao->nels > 0, "m4NAME: 0 elements (arguments)");
    rank = box_nao->nels / 2;
    CHECK2NULL(rank <= MAX_GRID_RANK, "m4NAME: Too many elements (arguments)");
    for (i = 0; i < rank; i++) {
	tmp_nao1 = Nap_GetNaoFromSlot(box_nao->data.Boxed[2*i]);
	CHECK2NULL(tmp_nao1, "m4NAME: NULL argument");
	CHECK2NULL(tmp_nao1->rank == rank, "m4NAME: Main array has wrong rank");
	Nap_IncrRefCount(nap_cd, tmp_nao1);
	main_nao[i] = Nap_CastNAO(nap_cd, tmp_nao1, NAP_F32);
	CHECK2NULL(main_nao[i], "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, main_nao[i]);
	Nap_DecrRefCount(nap_cd, tmp_nao1);
	maxValue = -FLT_MAX;
	minValue =  FLT_MAX;
	for (j = 0; j < main_nao[i]->nels; j++) {
	    if (!IsMissing(main_nao[i], j)) {
		value = main_nao[i]->data.F32[j];
		maxValue = Max(maxValue, value);
		minValue = Min(minValue, value);
	    }
	}
	delta = 8.0 * FLT_EPSILON * Max(Abs(maxValue), Abs(minValue));
	minValue -= delta;
	maxValue += delta;
	tmp_nao1 = Nap_GetNaoFromSlot(box_nao->data.Boxed[2*i+1]);
	CHECK2NULL(tmp_nao1, "m4NAME: NULL argument");
	CHECK2NULL(tmp_nao1->rank <= 1, "m4NAME: Coordinate variable has wrong rank");
	Nap_IncrRefCount(nap_cd, tmp_nao1);
	shape[0] = tmp_nao1->nels;
	tmp_nao2 = Nap_ReshapeNAO(nap_cd, tmp_nao1, NAP_F32, 1, shape);
	CHECK2NULL(tmp_nao2, "m4NAME: Error calling Nap_ReshapeNAO");
	Nap_IncrRefCount(nap_cd, tmp_nao2);
	Nap_DecrRefCount(nap_cd, tmp_nao1);
	if (trim) {
	    shape[0] = 0;
	    for (j = 0; j < tmp_nao2->nels; j++) {
		value = tmp_nao2->data.F32[j];
		shape[0] += value >= minValue  &&  value <= maxValue;
	    }
	    new_cv_nao[i] = Nap_NewNAO(nap_cd, NAP_F32, 1, shape);
	    CHECK2NULL(new_cv_nao[i], "m4NAME: Error calling Nap_NewNAO");
	} else {
	    new_cv_nao[i] = tmp_nao2;
	}
	Nap_IncrRefCount(nap_cd, new_cv_nao[i]);
	status = Nap_AttachCoordVar(nap_cd, new_cv_nao[i], NULL, tmp_nao2->dimName[0], 0);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	NAP_FREE(nap_cd, new_cv_nao[i]->unit);
	if (main_nao[i]->unit) {
	    new_cv_nao[i]->unit = Nap_StrDup(nap_cd, main_nao[i]->unit);
	} else if (tmp_nao2->unit) {
	    new_cv_nao[i]->unit = Nap_StrDup(nap_cd, tmp_nao2->unit);
	}
	new_cv[i] = new_cv_nao[i]->data.F32;
	for (j = k = 0; j < tmp_nao2->nels; j++) {
	    value = tmp_nao2->data.F32[j];
	    if (!trim  ||  value >= minValue  &&  value <= maxValue) {
		new_cv[i][k++] = value;
	    }
	}
	Nap_DecrRefCount(nap_cd, tmp_nao2);
    }
    for (j = 0; j < rank; j++) {
	shape_main[j] = main_nao[0]->shape[j];
	for (i = 0, tmp_nao1 = NULL; i < rank && !tmp_nao1; i++) {
	    tmp_nao1 = Nap_GetCoordVar(nap_cd, main_nao[i], j);
	    Nap_IncrRefCount(nap_cd, tmp_nao1);
	}
	if (tmp_nao1) {
	    old_cv_nao[j] = Nap_CastNAO(nap_cd, tmp_nao1, NAP_F32);
	    CHECK2NULL(old_cv_nao[j], "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, old_cv_nao[j]);
	    Nap_DecrRefCount(nap_cd, tmp_nao1);
	    old_cv[j] = old_cv_nao[j]->data.F32;
	} else {
	    old_cv_nao[j] = NULL;
	    old_cv[j] = NULL;
	}
    }
    for (i = 0; i < rank; i++) {
	for (j = 0; j < rank; j++) {
	    CHECK2NULL(main_nao[i]->shape[j] == shape_main[j],
		    "m4NAME: Main arrays have different shapes");
	    tmp_nao1 = Nap_GetCoordVar(nap_cd, main_nao[i], j);
	    Nap_IncrRefCount(nap_cd, tmp_nao1);
	    if (old_cv[j] && tmp_nao1) {
		tmp_nao2 = Nap_CastNAO(nap_cd, tmp_nao1, NAP_F32);
		CHECK2NULL(tmp_nao2, "m4NAME: Error calling Nap_CastNAO");
		Nap_IncrRefCount(nap_cd, tmp_nao2);
		if (shape_main[j] > 0) {
		    delta = eps * Abs(old_cv[j][shape_main[j]-1]-old_cv[j][0]);
		}
		for (k = 0; k < shape_main[j]; k++) {
		    CHECK2NULL(Abs(tmp_nao2->data.F32[k] - old_cv[j][k]) <= delta,
			    "m4NAME: Main arrays have different coordinate variables");
		}
		Nap_DecrRefCount(nap_cd, tmp_nao2);
	    }
	    Nap_DecrRefCount(nap_cd, tmp_nao1);
	}
    }
    switch (rank) {
    case 1:
	result = Nap_NewNAO(nap_cd, NAP_F32, 1, shape);
	CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
	if (old_cv_nao[0]) {
	    status = Nap_AttachLink(nap_cd, result, Nap_NewScalarNAO(nap_cd, NAP_I32, 1.0));
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
	}
	status = Nap_AttachCoordVar(nap_cd, result, new_cv_nao[0], new_cv_nao[0]->dimName[0], 0);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	tmp = -1.0;
	for (j = 0; j < result->nels; j++) {
	    value = new_cv[0][j];
	    if (value < minValue  ||  value > maxValue) {
		result->data.F32[j] = NAP_F32_NULL;
	    } else {
		tmp = Nap_IndexOfNao(
			nap_cd,
			main_nao[0],
			&value,
			tmp);
		k = tmp;
		w1 = tmp - k;
		w0 = 1.0f - w1;
		if (old_cv_nao[0]) {
		    result->data.F32[j] = w0 * old_cv[0][k];
		    if (w1) {
			result->data.F32[j] += w1 * old_cv[0][k+1];
		    }
		} else {
		    result->data.F32[j] = tmp;
		}
	    }
	}
	break;
    case 2:
	shape[0] = new_cv_nao[0]->nels;
	shape[1] = new_cv_nao[1]->nels;
	shape[2] = 2;
	result = Nap_NewNAO(nap_cd, NAP_F32, 3, shape);
	CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
	shape[0] = 2;
	tmp_nao1 = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	CHECK2NULL(tmp_nao1, "m4NAME: Error calling Nap_NewNAO");
	for (i = 0; i < 2; i++) {
	    tmp_nao1->data.I32[i] = old_cv_nao[i] ? 1 : 0;
	}
	status = Nap_AttachLink(nap_cd, result, tmp_nao1);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
	status = Nap_AttachCoordVar(nap_cd, result, new_cv_nao[0], new_cv_nao[0]->dimName[0], 0);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	status = Nap_AttachCoordVar(nap_cd, result, new_cv_nao[1], new_cv_nao[1]->dimName[0], 1);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	if (result->nels == 0) {
	    break;
	}
	d2save = (float *) NAP_ALLOC(nap_cd, result->nels * sizeof(float));
	for (i = 0; i < result->nels; i++) {
	    result->data.F32[i] = NAP_F32_NULL;
	    d2save[i] = napF32Inf;
	}
	for (i = 0; i < shape_main[0]-1; i++) {
	    fmin[0] = fmin[1] = fmax[0] = fmax[1] = -1.0;
	    for (j = 0; j < shape_main[1]-1; j++) {
		imin[0] = imax[0] = 0;
		for (k = 0; k < 2 && imin[0] <= imax[0]; k++) {
		    j00 = shape_main[1]*i+j;
		    j01 = shape_main[1]*i+j+1;
		    j10 = shape_main[1]*(i+1)+j;
		    j11 = shape_main[1]*(i+1)+j+1;
		    if (IsMissing(main_nao[k], j00)  ||  IsMissing(main_nao[k], j01) ||
		        IsMissing(main_nao[k], j10)  ||  IsMissing(main_nao[k], j11)) {
			imin[k] = 1;
			imax[k] = 0;
		    } else {
			z00 = main_nao[k]->data.F32[j00];
			z01 = main_nao[k]->data.F32[j01];
			z10 = main_nao[k]->data.F32[j10];
			z11 = main_nao[k]->data.F32[j11];
			h[k][0] = z00;
			h[k][1] = z10 - z00;
			h[k][2] = z01 - z00;
			h[k][3] = z00 - z01 - z10 + z11;
			maxValue = Max(Max(z00, z01), Max(z10, z11));
			minValue = Min(Min(z00, z01), Min(z10, z11));
			if (new_cv_nao[k]->nels > 1) {
			    fmin[k] = Nap_IndexOfNao(
				    nap_cd,
				    new_cv_nao[k],
				    new_cv[k][0] < new_cv[k][1] ? &minValue : &maxValue,
				    fmin[k]);
			    fmax[k] = Nap_IndexOfNao(
				    nap_cd,
				    new_cv_nao[k],
				    new_cv[k][0] < new_cv[k][1] ? &maxValue : &minValue,
				    fmax[k]);
			} else {
			    fmax[k] = fmin[k] = 0.0;
			}
			imin[k] = ceil(Max(Min(fmin[k], new_cv_nao[k]->nels-1), 0.0));
			imax[k] = floor(Max(Min(fmax[k], new_cv_nao[k]->nels-1), 0.0));
			frange[k] = fmax[k] - fmin[k];
		    }
		}
		if (imin[0] <= imax[0]  &&  imin[1] <= imax[1]) {
		    d2 = frange[0] * frange[0] + frange[1] * frange[1];
		    a = h[0][3] * h[1][2] - h[0][2] * h[1][3];
		    bc = h[0][1] * h[1][2] - h[0][2] * h[1][1]
		       + h[0][3] * h[1][0] - h[0][0] * h[1][3];
		    cc = h[0][1] * h[1][0] - h[0][0] * h[1][1];
		    for (index0 = imin[0]; index0 <= imax[0]; index0++) {
			x0 = new_cv[0][index0];
			for (index1 = imin[1]; index1 <= imax[1]; index1++) {
			    x1 = new_cv[1][index1];
			    b = bc + h[1][3] * x0 - h[0][3] * x1 ;
			    c = cc + h[1][1] * x0 - h[0][1] * x1; 
			    n = solve_quadratic(a, b, c, jj);
			    for (k = 0; k < n; k++) {
				if (jj[k] >= lowest  &&  jj[k] <= highest) {
				    ii = (x0 - h[0][0] - h[0][2] * jj[k])
					    / (h[0][1] + h[0][3] * jj[k]);
				    kk = 2 * (shape[1] * index0 + index1);
				    if (ii >= lowest  &&  ii <= highest  &&  d2 < d2save[kk]) {
					w1 = ii;
					w0 = 1.0f - w1;
					result->data.F32[kk] = old_cv_nao[0] ?
					    w0*old_cv[0][i] + w1*old_cv[0][i+1]
					    : i + ii;
					w1 = jj[k];
					w0 = 1.0f - w1;
					result->data.F32[kk+1] = 
					    old_cv_nao[1] ?
					    w0*old_cv[1][j] + w1*old_cv[1][j+1]
					    : j + jj[k];
					d2save[kk] = d2;
				    }
				}
			    }
			}
		    }
		}
	    }
	}
	NAP_FREE(nap_cd, d2save);
	break;
    default:
	assert(FALSE);
    }
    for (i = 0; i < rank; i++) {
	Nap_DecrRefCount(nap_cd, old_cv_nao[i]);
	Nap_DecrRefCount(nap_cd, new_cv_nao[i]);
	Nap_DecrRefCount(nap_cd, main_nao[i]);
    }
    return result->id;
}

/*
 * Nap_nels --
 *
 * nap function "nels(x)"
 */

m4define(`m4NAME', `Nap_nels')

static char *
Nap_nels(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    Nap_NAO             *new;

    new = Nap_NewNAO(nap_cd, NAP_I32, 0, NULL);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    new->data.I32[0] = naoPtr->nels;
    return new->id;
}

/*
 * Nap_rank --
 *
 * nap function "rank(x)"
 */

m4define(`m4NAME', `Nap_rank')

static char *
Nap_rank(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    Nap_NAO             *new;

    new = Nap_NewNAO(nap_cd, NAP_I32, 0, NULL);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    new->data.I32[0] = naoPtr->rank;
    return new->id;
}

/*
 * Nap_label --
 *
 * nap function "label(x)"
 */

m4define(`m4NAME', `Nap_label')

static char *
Nap_label(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    Nap_NAO             *new;
    size_t              shape[1];

    shape[0] = naoPtr->label ? strlen(naoPtr->label) : 0;
    new = Nap_NewNAO(nap_cd, NAP_C8, 1, shape);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    if (naoPtr->label) {
	strncpy(new->data.c, naoPtr->label, shape[0]);
    }
    return new->id;
}

/*
 * Nap_box --
 *
 * nap function "box(x)"
 * Argument x is any NAO.
 * Result is scalar boxed NAO pointing to argument.
 */

m4define(`m4NAME', `Nap_box')

static char *
Nap_box(
    NapClientData	*nap_cd, 
    Nap_NAO             *args)
{
    Nap_NAO             *naoPtr;	/* argument */
    Nap_NAO             *result;	/* boxed NAO */

    CHECK2NULL(args->nels == 1, "m4NAME: Wrong # arguments");
    naoPtr = Nap_GetNaoFromSlot(args->data.Boxed[0]);
    CHECK2NULL(naoPtr, "m4NAME: error calling Nap_GetNaoFromSlot");
    result = Nap_NewNAO(nap_cd, NAP_BOXED, 0, NULL);
    CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
    result->data.Boxed[0] = naoPtr->slot;
    Nap_IncrRefCount(nap_cd, naoPtr);
    return result->id;
}

/*
 * Nap_open_box --
 *
 * nap function "open_box(x)" which is inverse of function "box(x)".
 *
 * If argument x is single-element (normally scalar) boxed NAO then 
 *     if x is present then result is NAO which x points to.
 *     else result is i32(_)
 * else result is x
 */

m4define(`m4NAME', `Nap_open_box')

static char *
Nap_open_box(
    NapClientData	*nap_cd, 
    Nap_NAO             *args)
{
    Nap_NAO             *naoPtr;	/* argument */
    Nap_NAO             *result;	/* NAO which argument points to */

    CHECK2NULL(args->nels == 1, "m4NAME: Wrong # arguments");
    naoPtr = Nap_GetNaoFromSlot(args->data.Boxed[0]);
    CHECK2NULL(naoPtr, "m4NAME: error calling Nap_GetNaoFromSlot");
    if (naoPtr->dataType == NAP_BOXED  &&  naoPtr->nels == 1) {
	result = Nap_GetNaoFromSlot(naoPtr->data.Boxed[0]);
	if (!result) {
	    result = Nap_StandardMissingValueNAO(nap_cd, NAP_I32);
	}
    } else {
	result = naoPtr;
    }
    return result->id;
}


/*
 * Nap_shape --
 *
 * nap function "shape(x)"
 */

m4define(`m4NAME', `Nap_shape')

static char *
Nap_shape(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    int			i;
    Nap_NAO             *new;
    size_t              shape[1];

    shape[0] = naoPtr->rank;
    new = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    for (i = 0; i < naoPtr->rank; i++) {
        new->data.I32[i] = naoPtr->shape[i];
    }
    return new->id;
}

/*
 * Nap_missing_value --
 *
 * nap function "missing_value(x)"
 */

m4define(`m4NAME', `Nap_missing_value')

static char *
Nap_missing_value(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    Nap_dataType        dataType;
    Nap_NAO             *new;

    assert(naoPtr);
    if (naoPtr->missingValueSlot) {
	switch (naoPtr->dataType) {
	case NAP_C8:
	case NAP_I8:
	case NAP_U8:
	    dataType = NAP_I16;
	    break;
	case NAP_I16:
	case NAP_U16:
	    dataType = NAP_I32;
	    break;
	case NAP_I32:
	case NAP_U32:
	    dataType = NAP_F64;
	    break;
	default:
	    dataType = naoPtr->dataType;
	}
	new = Nap_NewScalarNAO(nap_cd, dataType, Nap_GetF64MissingValue(nap_cd, naoPtr->slot));
	return new->id;
    } else {
	return NULL;
    }
}

/*
 *  boxed_function --
 *	Handler for functions with boxed argument.
 */

m4define(`m4NAME', `boxed_function')

static char *
boxed_function(
    NapClientData	*nap_cd,
    char		*name,			/* name of function */
    Nap_NAO		*boxed)			/* boxed NAO pointing to function args */
{
    char		*result = NULL;		/* NAO ID to be returned */

    if (strcmp(name, "box") == 0) {
	result = Nap_box(nap_cd, boxed);
    } else if (strcmp(name, "cart_proj_fwd") == 0) {
	result = Nap_cart_proj_fwd(nap_cd, boxed);
    } else if (strcmp(name, "cart_proj_inv") == 0) {
	result = Nap_cart_proj_inv(nap_cd, boxed);
    } else if (strcmp(name, "clip2d") == 0) {
	result = Nap_clip2d(nap_cd, boxed);
    } else if (strcmp(name, "correlation") == 0) {
	result = Nap_Correlation(nap_cd, boxed);
    } else if (strcmp(name, "dilate") == 0) {
	result = Nap_dilate(nap_cd, boxed);
    } else if (strcmp(name, "erode") == 0) {
	result = Nap_erode(nap_cd, boxed);
    } else if (strcmp(name, "inPolygon") == 0) {
	result = Nap_inPolygon(nap_cd, boxed);
    } else if (strcmp(name, "invert_grid") == 0) {
	result = Nap_invert_grid(nap_cd, boxed->id, 1);
    } else if (strcmp(name, "invert_grid_no_trim") == 0) {
	result = Nap_invert_grid(nap_cd, boxed->id, 0);
    } else if (strcmp(name, "moving_correlation") == 0) {
	result = Nap_MovingCorrelation(nap_cd, boxed);
    } else if (strcmp(name, "moving_range") == 0) {
	result = Nap_moving_range(nap_cd, boxed);
    } else if (strcmp(name, "open_box") == 0) {
	result = Nap_open_box(nap_cd, boxed);
    } else if (strcmp(name, "prune") == 0) {
	result = Nap_prune(nap_cd, boxed);
    } else if (strcmp(name, "triangulate") == 0) {
	result = Nap_Triangulate(nap_cd, boxed);
    } else if (strcmp(name, "triangulate_edges") == 0) {
	result = Nap_TriangulateEdges(nap_cd, boxed);
    }
    return result;
}

/*
 *  Nap_Func2 --
 *	Handler for functions with 2 arguments.
 */

m4define(`m4NAME', `Nap_Func2')

static char *
Nap_Func2(
    NapClientData	*nap_cd,
    char		*name,			/* name of function */
    char		*str1,			/* id of argument 1 */
    char		*str2)			/* id of argument 2 */
{
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*new;

    if (!name) {
	assert(FALSE);
    } else if (strcmp(name, "atan2") == 0) {
	return Nap_Atan2(nap_cd, str1, str2);
    } else if (strcmp(name, "atan") == 0) {
	return Nap_Atan2(nap_cd, str1, str2);
    } else if (strcmp(name, "coordinate_variable") == 0) {
	return Nap_CV(nap_cd, str1, str2);
    } else if (strcmp(name, "hypot") == 0) {
	return Nap_Hypot(nap_cd, str1, str2);
    } else if (strcmp(name, "fmod") == 0) {
	return Nap_Rem(nap_cd, str1, str2);
    } else if (strcmp(name, "log") == 0) {
	return Nap_Log(nap_cd, str1, str2);
    } else if (strcmp(name, "pad") == 0) {
	return Nap_pad(nap_cd, str1, str2);
    } else if (strcmp(name, "pow") == 0) {
	return Nap_Power(nap_cd, str1, str2);
    } else if (strcmp(name, "psum1") == 0) {
	return Nap_psum1(nap_cd, str1, str2);
    } else if (strcmp(name, "reshape") == 0) {
	return Nap_Reshape(nap_cd, str1, str2);
    } else if (strcmp(name, "solve_linear") == 0) {
	return Nap_SolveLinear(nap_cd, str1, str2);
    } else if (strcmp(name, "sort") == 0) {
	return Nap_sort(nap_cd, str1, str2);
    } else if (strcmp(name, "transpose") == 0) {
	return Nap_Transpose(nap_cd, str1, str2);
    }
    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    Nap_IncrRefCount(nap_cd, naoPtr1);
    Nap_IncrRefCount(nap_cd, naoPtr2);
    new = Nap_Reduce(nap_cd, name, naoPtr1, naoPtr2);
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return new ? new->id : NULL;
}

/*
 * Nap_Func1 --
 *
 * Functions with 1 argument
 */

m4begin

#       m4monad1(data_type)  e.g. m4monad1(U8)
m4define(`m4monad1', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		if (!IsMissing(naoPtr, i)) {
		    new->data.$1[i] = m4defn(new->data.$1[i]);
		}
	    }
	    break;')

#       m4monadSigned(defn)
#       e.g.  m4monadSigned(`Abs($1)')
m4define(`m4monadSigned', `
    m4define(`m4defn', `$1')
	new = Nap_CopyNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
        switch (new->dataType) {
	m4ForAllSignedDataType(`m4monad1(', `)')
	default:            /* error */
	    assert(FALSE);
	}
	')

#       m4monadUnsigned(defn)
m4define(`m4monadUnsigned', `
    m4define(`m4defn', `$1')
	new = Nap_CopyNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
        switch (new->dataType) {
	m4ForAllUnsignedIntegerDataType(`m4monad1(', `)')
	default:            /* error */
	    assert(FALSE);
	}
	')

#       m4monad(defn)
#       e.g. m4monad(`-($1)')
m4define(`m4monad', `
    m4define(`m4defn', `$1')
	new = Nap_CopyNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
        switch (new->dataType) {
	m4ForAllNumericDataType(`m4monad1(', `)')
	default:            /* error */
	    assert(FALSE);
	}
	')

#       m4func1(data_type)
m4define(`m4func1', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		if (!IsMissing(naoPtr, i)) {
		    new->data.$1[i] = m4defn`'((double) new->data.$1[i]);
		}
	    }
	    break;')

#       m4func(name)  e.g. m4func(sin)
m4define(`m4func', `
    m4define(`m4defn', `$1')
    } else if (strcmp(name, "$1") == 0) {
	if (Nap_IsReal(naoPtr)) {
	    new = Nap_CopyNAO(nap_cd, naoPtr);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
	} else {
	    new = Nap_CastNAO(nap_cd, naoPtr, NAP_F64);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_CastNAO");
	}
        switch (new->dataType) {
	m4ForAllRealDataType(`m4func1(', `)')
        default:            /* error */
            assert(FALSE);
        }
	')
	}')

#       m4cast(new_data_type)  e.g. m4cast(F32)
m4define(`m4cast', `
    if (strcmp(name, "m4LowerCase(`$1')") == 0) {
        dataType = m4DataTypeEnum($1);
	if (dataType == naoPtr->dataType) {
	    new = naoPtr;
	} else {
	    new = Nap_CastNAO(nap_cd, naoPtr, dataType);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_CastNAO");
        }
    }')

#       m4random(old_data_type)  e.g. m4random(I32)
m4define(`m4random', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		if (!IsMissing(naoPtr, i)) {
		    new->data.F32[i] = Random_float((float) naoPtr->data.$1[i]);
		}
	    }
	    break;')

m4define(`m4NAME', `Nap_Func1')

m4end

static char *
Nap_Func1(
    NapClientData	*nap_cd, 
    char		*name,
    char		*str)
{
    Nap_dataType        dataType;
    size_t		i;
    char		*id;
    Nap_NAO		*new = NULL;
    Nap_NAO		*naoPtr;
    int			status;

    CHECK2NULL(str, "m4NAME: NULL argument");
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsUnsignedInteger(naoPtr)  &&  !strcmp(name, "abs")
	    ||  Nap_IsInteger(naoPtr)  &&  (!strcmp(name, "nint") || !strcmp(name, "round")
	    || !strcmp(name, "ceil") || !strcmp(name, "floor"))) {
	new = Nap_CopyNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
    } else if (!strcmp(name, "abs")) {
	m4monadSigned(`Abs($1)')
    } else if (!strcmp(name, "sign")) {
	if (Nap_IsUnsignedInteger(naoPtr)) {
	    m4monadUnsigned(`$1 > 0')
	} else {
	    m4monadSigned(`Sign($1)')
	}
    } else if (!strcmp(name, "nint")  ||  !strcmp(name, "round")) {
	m4monad(`Nint($1)')
    } else if (!strcmp(name, "random")) {
	if (naoPtr->dataType == NAP_F64) {
	    new = Nap_CopyNAO(nap_cd, naoPtr);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
	    for (i = 0; i < new->nels; i++) {
		new->data.F64[i] = Random_double(naoPtr->data.F64[i]);
	    }
	} else {
	    new = Nap_NewNAO(nap_cd, NAP_F32, naoPtr->rank, naoPtr->shape);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
	    status = Nap_CopyDims(nap_cd, naoPtr, new);
	    CHECK1NULL(status == TCL_OK);
	    switch (naoPtr->dataType) {
	    m4ForAllNumericDataType(`m4random(', `)')
	    default:            /* error */
		assert(FALSE);
	    }
	}
    } else if (strcmp(name, "isnan") == 0) {
	new = Nap_NewNAO(nap_cd, NAP_U8, naoPtr->rank, naoPtr->shape);
	CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
	switch (naoPtr->dataType) {
	case NAP_F32:
	    for (i = 0; i < new->nels; i++) {
		new->data.U8[i] = IsNaN32(naoPtr->data.F32[i]);
	    }
	    break;
	case NAP_F64:
	    for (i = 0; i < new->nels; i++) {
		new->data.U8[i] = IsNaN64(naoPtr->data.F64[i]);
	    }
	    break;
	default:
	    for (i = 0; i < new->nels; i++) {
		new->data.U8[i] = FALSE;
	    }
	}
    } else if (strcmp(name, "psum") == 0) {
	id = Nap_psum(nap_cd, naoPtr);
	new = Nap_GetNaoFromId(nap_cd, id);
    } else if (strcmp(name, "label") == 0) {
	id = Nap_label(nap_cd, naoPtr);
	new = Nap_GetNaoFromId(nap_cd, id);
    } else if (strcmp(name, "missing_value") == 0) {
	id = Nap_missing_value(nap_cd, naoPtr);
	new = Nap_GetNaoFromId(nap_cd, id);
    } else if (strcmp(name, "nels") == 0) {
	id = Nap_nels(nap_cd, naoPtr);
	new = Nap_GetNaoFromId(nap_cd, id);
    } else if (strcmp(name, "rank") == 0) {
	id = Nap_rank(nap_cd, naoPtr);
	new = Nap_GetNaoFromId(nap_cd, id);
    } else if (strcmp(name, "shape") == 0) {
	id = Nap_shape(nap_cd, naoPtr);
	new = Nap_GetNaoFromId(nap_cd, id);

    m4func(ceil)
    m4func(floor)
    m4func(acos)
    m4func(asin)
    m4func(atan)
    m4func(cos)
    m4func(cosh)
    m4func(exp)
    m4func(log)
    m4func(log10)
    m4func(sin)
    m4func(sinh)
    m4func(sqrt)
    m4func(tan)
    m4func(tanh)
    }
    m4ForAllUnboxedDataType(`m4cast(', `)')
    if (!new) {
	new = Nap_Reduce(nap_cd, name, naoPtr, NULL);
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}

/*
 * Nap_StdFuncs --
 *
 * Standard (built-in) nap functions.
 */

m4define(`m4NAME', `Nap_StdFuncs')

static char *
Nap_StdFuncs(
    NapClientData	*nap_cd, 
    char                *name,		/* function-name */
    Nap_NAO		*args)		/* function args */
{   
    Nap_NAO		*boxed = NULL;
    char                *id1;		/* NAO ID */
    char                *id2;		/* NAO ID */
    size_t		n;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    char		*result = NULL;	/* NAO ID to be returned */
    size_t		shape[] = {1};

    assert(name);
    if (args) {
	if (args->dataType == NAP_BOXED  &&  args->rank == 1) {
	    boxed = args;
	} else {
	    result = Nap_Func1(nap_cd, name, args->id);
	    if (!result) {
		boxed = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
		CHECK2NULL(boxed, "m4NAME: Error calling Nap_NewNAO");
		boxed->data.Boxed[0] = args->slot;
		Nap_IncrRefCount(nap_cd, args);
	    }
	}
	Nap_IncrRefCount(nap_cd, boxed);
	if (!result) {
	    result = boxed_function(nap_cd, name, boxed);
	}
	if (!result) {
	    n = boxed->nels;
	    if (n < 3) {
		naoPtr1 = n < 1 ? NULL : Nap_GetNaoFromSlot(boxed->data.Boxed[0]);
		naoPtr2 = n < 2 ? NULL : Nap_GetNaoFromSlot(boxed->data.Boxed[1]);
		id1 = naoPtr1 ? naoPtr1->id : NULL;
		id2 = naoPtr2 ? naoPtr2->id : NULL;
		result = Nap_Func2(nap_cd, name, id1, id2);
		if (!result  &&  n < 2) {
		    result = Nap_Func1(nap_cd, name, id1);
		}
	    }
	}
	Nap_DecrRefCount(nap_cd, boxed);
    }
    return result;
}

/*
 * CommandIsDefined --
 *
 * Return 1 if specified command exists or can be defined via auto_index.
 * If latter then execute this auto_index script.
 */

m4define(`m4NAME', `CommandIsDefined')

static int
CommandIsDefined(
    NapClientData	*nap_cd, 
    Tcl_Obj		*commandNameObj)	/* command-name */
{   
    static Tcl_Obj	*auto_indexObj = NULL;
    Tcl_CmdInfo		info;
    Tcl_Obj		*resultObj;
    int			status;
    char		*str;

    if (!auto_indexObj) {
	auto_indexObj = Tcl_NewStringObj("::auto_index", -1);
	assert(auto_indexObj);
	Tcl_IncrRefCount(auto_indexObj);
    }
    str = Tcl_GetStringFromObj(commandNameObj, NULL);
    status = Tcl_GetCommandInfo(nap_cd->interp, str, &info);
    if (!status) {
	resultObj = Tcl_ObjGetVar2(nap_cd->interp, auto_indexObj, commandNameObj, 0);
	if (resultObj) {
	    Tcl_IncrRefCount(resultObj);
	    status = Tcl_EvalObj(nap_cd->interp, resultObj);
	    Tcl_DecrRefCount(resultObj);
	    status = Tcl_GetCommandInfo(nap_cd->interp, str, &info);
	}
    }
    return status;
}

/*
 * Nap_FuncProc --
 *
 * Use tcl procedure to define result of nap function
 * If no such procedure defined then set pointer 'result' to NULL & return TCL_OK.
 *
 * Note that Nap_TraceUnsets does not delete NAOs pointed to by variables unset during 
 * execution of this tcl procedure.  Instead it adds NAO to "death list" whose head is list_nao.
 * This ensures that the result (which could be one of these) is still defined.
 * The ref. count of the result is incremented before deleting these NAOs here.
 */

m4define(`m4NAME', `Nap_FuncProc')

static int
Nap_FuncProc(
    NapClientData	*nap_cd, 
    char                *prefix,	/* "" or "::NAP::" */
    char                *funcName,	/* function-name */
    Nap_NAO		*args,		/* NAO pointing to function args */
    char		**result)	/* NAO ID (NULL if no proc found) (out) */
{   
    int			i;
    Nap_NAO		*list_nao;	/* list of NAOs whose deletion has been delayed */
    Nap_NAO		*naoPtr;
    Nap_NAO		*resultNao = NULL;
    Tcl_Obj		*resultObj;
    int			old_slotList;
    Tcl_Obj		*scriptObj;
    size_t              slot;
    int			status;

    *result = NULL;
    scriptObj = Tcl_NewStringObj(prefix, -1);
    assert(scriptObj);
    Tcl_IncrRefCount(scriptObj);
    Tcl_AppendToObj(scriptObj, funcName, -1);
    if (CommandIsDefined(nap_cd, scriptObj)) {
	if (args) {
	    if (args->dataType == NAP_BOXED  &&  args->rank == 1) {
		for (i = 0; i < args->shape[0]; i++) {
		    slot = args->data.Boxed[i];
		    if (slot > 0) {
			naoPtr = Nap_GetNaoFromSlot(slot);
			Tcl_AppendStringsToObj(scriptObj, " ", naoPtr->id, NULL);
		    } else {
			Tcl_AppendToObj(scriptObj, " NULL", -1);
		    }
		}
	    } else {
		Tcl_AppendStringsToObj(scriptObj, " ", args->id, NULL);
	    }
	}
	list_nao = Nap_NewNAO(nap_cd, NAP_I32, 0, NULL);
	CHECK2(list_nao, "m4NAME: Error calling Nap_NewNAO");
	old_slotList = nap_cd->slotList;
	nap_cd->slotList = list_nao->data.U32[0] = list_nao->slot;
	status = Tcl_EvalObj(nap_cd->interp, scriptObj);
	if (status != TCL_OK) {
	    CHECK5(0, "%s\n" "m4NAME: Error executing procedure \"%s%s\"",
		    Tcl_GetStringResult(nap_cd->interp), prefix, funcName);
	}
	resultObj = Tcl_GetObjResult(nap_cd->interp);
	assert(resultObj);
	Tcl_IncrRefCount(resultObj);
	resultNao = Nap_GetNaoFromObj(nap_cd, resultObj);
	CHECK2(resultNao, "m4NAME: Error calling Nap_GetNaoFromObj");
	Nap_IncrRefCount(nap_cd, resultNao);
	*result = resultNao->id;
	while (list_nao) {
	    naoPtr = list_nao;
	    list_nao = Nap_GetNaoFromSlot(list_nao->nextSlot);
	    naoPtr->nextSlot = 0;
	    Nap_DecrRefCount(nap_cd, naoPtr);
	}
	nap_cd->slotList = old_slotList;
	if (resultNao) {
	    --resultNao->count;
	}
	Tcl_DecrRefCount(resultObj);
    }
    Tcl_DecrRefCount(scriptObj);
    return TCL_OK;
}

/*
 * Nap_Func --
 *
 * Call nap function.
 */

m4define(`m4NAME', `Nap_Func')

EXTERN char *
Nap_Func(
    NapClientData	*nap_cd, 
    char		*name,		/* function-name */
    char		*str2)		/* arguments */
{
    Nap_NAO		*naoPtr2;
    char		*result = NULL;	/* NAO ID to be returned */
    int			status;
    Nap_NAO		*result_NAO;

    assert(name);
    naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
    Nap_IncrRefCount(nap_cd, naoPtr2);
    assert(name);
    status = Nap_FuncProc(nap_cd, NAP_NAMESPACE, name, naoPtr2, &result);
    CHECK1NULL(status == TCL_OK);
    if (!result) {
	result = Nap_StdFuncs(nap_cd, name, naoPtr2);
	if (!result) {
	    status = Nap_FuncProc(nap_cd, "", name, naoPtr2, &result);
	    CHECK1NULL(status == TCL_OK);
	    if (!result) {
		Nap_DecrRefCount(nap_cd, naoPtr2);
		CHECK3NULL(FALSE, "m4NAME: Undefined function %s()", name);
	    }
	}
    }
    result_NAO = Nap_GetNaoFromId(nap_cd, result);
    CHECK2NULL(result_NAO, "m4NAME: Error calling Nap_GetNaoFromId");
    Nap_IncrRefCount(nap_cd, result_NAO);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    --result_NAO->count;
    return result;
}
