m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (napMonad.c) */
/* It was produced from source file napMonad.c,m4 */

/* 
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napMonad.c,m4,v 1.178 2002/10/10 09:00:20 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"

#define Random_float(max) \
    ((max) * ((float) rand()) * ((1.0f - FLT_EPSILON) / (float) RAND_MAX))

#define Random_double(max) \
    ((max) * ((double) rand()) * ((1.0 - DBL_EPSILON) / (double) RAND_MAX))

static char *Nap_Func1(NapClientData *nap_cd, char *name, char *str);

m4begin

#	m4Count(oldDataType)  e.g. m4Count(U8)
m4define(`m4Count', `
	    case m4DataTypeEnum($1):
		for (m = 0; m < frameNels; m++) {
		    j0 = m * newCellNels;
		    i0next = i  + cellNels;
		    jfinal = j0 + newCellNels - 1;
		    for (j = j0; i < i0next; i++) {
			new->data.I32[j] += ! IsMissing(old, i);
			j = j < jfinal ? j + 1 : j0;
		    }
		}
		break;')

#	m4Count0 is optimised code for verb-rank of 0 (simple test for missing)
#	m4Count0(oldDataType)  e.g. m4Count0(U8)
m4define(`m4Count0', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.I32[j] = ! IsMissing(old, j);
		}
		break;')

#	m4Sum2(newDataType,oldDataType)  e.g. m4Sum2(F32, U8)
m4define(`m4Sum2', `
		    case m4DataTypeEnum($2):
			for (m = 0; m < frameNels; m++) {
			    j0 = m * newCellNels;
			    i0next = i  + cellNels;
			    jfinal = j0 + newCellNels - 1;
			    for (j = j0; i < i0next; i++) {
				if (! IsMissing(old, i)) {
				    new->data.$1[j] += old->data.$2[i];
				}
				j = j < jfinal ? j + 1 : j0;
			    }
			}
			break;')

#	m4Sum(newDataType)  e.g. m4Sum(F32)
m4define(`m4Sum', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = 0.0;
		}
		switch (old->dataType) {
		    m4ForAllNumericDataType(`m4Sum2($1,', `)')
		}
		break;')

#	m4Prod2(newDataType,oldDataType)  e.g. m4Prod2(F32, U8)
m4define(`m4Prod2', `
		    case m4DataTypeEnum($2):
			for (m = 0; m < frameNels; m++) {
			    j0 = m * newCellNels;
			    i0next = i  + cellNels;
			    jfinal = j0 + newCellNels - 1;
			    for (j = j0; i < i0next; i++) {
				if (! IsMissing(old, i)) {
				    if (old->data.$2[i] > 0) {
					new->data.$1[j] += log(old->data.$2[i]);

#if ! Nap_TypeIsUnsignedIntegerValue($2)
				    } else if (old->data.$2[i] < 0) {
					signProd->data.I8[j] *= -1;
					new->data.$1[j] += log(-old->data.$2[i]);
#endif
				    } else {
					signProd->data.I8[j] = 0;
				    }
				}
				j = j < jfinal ? j + 1 : j0;
			    }
			}
			break;')

#	m4Prod(newDataType)  e.g. m4Prod(F32)
m4define(`m4Prod', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = 0.0;
		    signProd->data.I8[j] = 1;
		}
		switch (old->dataType) {
		    m4ForAllNumericDataType(`m4Prod2($1,', `)')
		}
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = signProd->data.I8[j] * exp(new->data.$1[j]);
		}
		break;')

#	m4Min(DataType)  e.g. m4Min(U8)
m4define(`m4Min', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = m4DataTypeEnum($1)_MAX;
		}
		for (m = 0; m < frameNels; m++) {
		    j0 = m * newCellNels;
		    i0next = i  + cellNels;
		    jfinal = j0 + newCellNels - 1;
		    for (j = j0; i < i0next; i++) {
			if (! IsMissing(old, i)) {
			    new->data.$1[j] = Min(new->data.$1[j], old->data.$1[i]);
			}
			j = j < jfinal ? j + 1 : j0;
		    }
		}
		break;')

#	m4Max(DataType)  e.g. m4Max(U8)
m4define(`m4Max', `
	    case m4DataTypeEnum($1):
		for (j = 0; j < new->nels; j++) {
		    new->data.$1[j] = m4DataTypeEnum($1)_MIN;
		}
		for (m = 0; m < frameNels; m++) {
		    j0 = m * newCellNels;
		    i0next = i  + cellNels;
		    jfinal = j0 + newCellNels - 1;
		    for (j = j0; i < i0next; i++) {
			if (! IsMissing(old, i)) {
			    new->data.$1[j] = Max(new->data.$1[j], old->data.$1[i]);
			}
			j = j < jfinal ? j + 1 : j0;
		    }
		}
		break;')

m4end

/*
 * Nap_Reduce --
 *	Reduction: count, sum, prod, min or max.
 *
 *	Based on 'insert' adverb in J.
 *	Default verb_rank is infinity, which (like any other value > old_rank)
 *	is treated as old_rank.
 *
 *	If verb_rank > 0 then new_rank = old_rank - 1;
 *
 *	If verb_rank = old_rank then reduce over leading dimension, which is
 *	thus absent from new shape.
 *
 *	If verb_rank < old_rank then split old shape into 'frame' & 'cell'.
 *	Each cell has rank = verb_rank & shape from trailing dimensions of
 *	argument.  Frame has rank = (old_rank-verb_rank) & shape from leading
 *	dimensions of argument.  Thus we can treat the argument as a frame of
 *	cells.  The verb (e.g. sum) is applied to each cell giving a result
 *	whose shape excludes the leading cell dimension.  Then these results
 *	are combined within the frame.
 */

m4define(`m4NAME', `Nap_Reduce')

Nap_NAO *
Nap_Reduce(
    NapClientData	*nap_cd, 
    char		*name,			/* function name e.g. "sum" */
    Nap_NAO		*old,			/* pointer to source data nao */
    Nap_NAO		*verbRankNaoPtr)	/* pointer to verb rank nao */
{
    size_t		cellNels;		/* # elements in cell */
    size_t		*cellShape;		/* shape of each cell */
    Nap_NAO             *coordNaoPtr;		/* coordinate variable */
    int			d;			/* dimension subscript */
    char                *dimName;		/* dimension name */
    size_t		i;			/* input subscript */
    int			frameRank;		/* rank of frame */
    size_t		frameNels;		/* # elements in frame */
    size_t		i0next;			/* starting value of i in */
						/* following verb application */
    size_t		j;			/* output subscript */
    size_t		j0;			/* starting value of j */
    size_t		jfinal;			/* final value of j */
    size_t		m;			/* verb application count */
    Nap_NAO		*new = NULL;		/* pointer to result nao */
    size_t		newCellNels;		/* # elements in new cell */
    int			newRank;		/* rank of result */
    Nap_dataType	newDataType;		/* data-type of result */
    size_t		newShape[NAP_MAX_RANK];	/* shape of result */
    int			rankDecrease;		/* old-rank - newRank */
    Nap_NAO		*signProd;		/* nao giving sign of product */
    int			status;
    Nap_NAO		*tmpNao;		/* pointer to temp. nao */
    int			verbRank;		/* rank of source for each application of verb */

    assert(name);
    if (       strcmp(name, "count") != 0
    	    && strcmp(name, "sum")   != 0
    	    && strcmp(name, "prod")  != 0
    	    && strcmp(name, "min")   != 0
    	    && strcmp(name, "max")   != 0) {
	return NULL;
    }
    assert(old);
    assert(old->id);
    assert(Nap_IsNAO(nap_cd, old));
    CHECK2NULL(Nap_TypeIsNumeric(old->dataType), "m4NAME: Non-numeric argument");
    if (verbRankNaoPtr) {
	assert(verbRankNaoPtr->id);
	assert(Nap_IsNAO(nap_cd, verbRankNaoPtr));
	CHECK2NULL(verbRankNaoPtr->nels == 1, "m4NAME: Illegal verb-rank");
	tmpNao = Nap_CastNAO(nap_cd, verbRankNaoPtr, NAP_F64);
	CHECK2NULL(tmpNao, "m4NAME: Error calling Nap_CastNAO");
	verbRank = Min(old->rank, tmpNao->data.F64[0]);
	if (tmpNao != verbRankNaoPtr) {
	    Nap_FreeNAO(nap_cd, tmpNao);
	}
    } else {
	verbRank = old->rank;
    }
    if (verbRank < 0) {
	verbRank = Max(0, verbRank + old->rank);
    }
    if (strcmp(name, "count") == 0) {
	newDataType = NAP_I32;
    } else if (strcmp(name, "sum") == 0  ||   strcmp(name, "prod") == 0) {
	newDataType = Max(m4DataTypeEnum(m4MinRealDataType), old->dataType);
	newDataType = Min(m4DataTypeEnum(m4MaxRealDataType), newDataType);
    } else if (strcmp(name, "min") == 0  &&  old->nels == 0) {
	newDataType = NAP_F64;
    } else if (strcmp(name, "max") == 0  &&  old->nels == 0) {
	newDataType = NAP_F64;
    } else {
	newDataType = old->dataType;
    }
    frameRank = old->rank - verbRank;
    rankDecrease = verbRank > 0;
    newRank = old->rank - rankDecrease;
    for (d = 0; d < newRank; d++) {
	i = d + rankDecrease * (d >= frameRank);
	newShape[d] = old->shape[i];
    }
    cellShape = old->shape + old->rank - verbRank;
    new = Nap_NewNAO(nap_cd, newDataType, newRank, newShape);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    for (d = 0; d < newRank; d++) {
	i = d + rankDecrease * (d >= frameRank);
        coordNaoPtr = Nap_GetCoordVar(nap_cd, old, i);
        dimName = old->dimName[i];
        status = Nap_AttachCoordVar(nap_cd, new, coordNaoPtr, dimName, d);
        CHECK1NULL(status == TCL_OK);
    }
    cellNels = 1;
    for (d = 0; d < verbRank; d++) {
	cellNels *= cellShape[d];
    }
    frameNels = cellNels == 0 ? 0 : old->nels / cellNels;
    newCellNels = frameNels == 0 ? 0 : new->nels / frameNels;
    i = 0;
    if (strcmp(name, "count") == 0) {
	if (verbRank == 0) {
	    switch (old->dataType) {
		m4ForAllNumericDataType(`m4Count0(', `)')
		default:            /* error */
		    assert(FALSE);
	    }
	} else {
	    for (j = 0; j < new->nels; j++) {
		new->data.I32[j] = 0;
	    }
	    switch (old->dataType) {
		m4ForAllNumericDataType(`m4Count(', `)')
		default:            /* error */
		    assert(FALSE);
	    }
	}
    } else if (strcmp(name, "sum") == 0) {
	new->unit = Nap_StrDup(old->unit);
	switch (newDataType) {
	    m4ForAllNumericDataType(`m4Sum(', `)')
	    default:            /* error */
		assert(FALSE);
	}
    } else if (strcmp(name, "prod") == 0) {
	signProd = Nap_NewNAO(nap_cd, NAP_I8, newRank, newShape);
	CHECK2NULL(signProd, "m4NAME: Error calling Nap_NewNAO");
	switch (newDataType) {
	    m4ForAllNumericDataType(`m4Prod(', `)')
	    default:            /* error */
		assert(FALSE);
	}
	Nap_FreeNAO(nap_cd, signProd);
    } else if (strcmp(name, "min") == 0) {
	new->unit = Nap_StrDup(old->unit);
	switch (newDataType) {
	    m4ForAllNumericDataType(`m4Min(', `)')
	    default:            /* error */
		assert(FALSE);
	}
    } else if (strcmp(name, "max") == 0) {
	new->unit = Nap_StrDup(old->unit);
	switch (newDataType) {
	    m4ForAllNumericDataType(`m4Max(', `)')
	    default:            /* error */
		assert(FALSE);
	}
    } else {
	new = NULL;
    }
    return new;
}


/*
 *  Nap_CorrelationStore --
 *
 *  Called by Nap_Correlation
 */

m4begin

#	m4corr(DataType)  e.g. m4corr(F32)
m4define(`m4corr', `
	    case m4DataTypeEnum($1):
		znao->data.$1[i] = z;
		znao->data.$1[j] = n;
		break;')

m4define(`m4NAME', `Nap_CorrelationStore')

m4end

static int
Nap_CorrelationStore(
    double		n,
    double		sumx,
    double		sumx2,
    double		sumy,
    double		sumy2,
    double		sumxy,
    Nap_NAO		*znao,			/* result */
    int			i,			/* index of correlation */
    int			j)			/* index of n */
{
    double		z;			/* result */
    z = (n * sumxy - sumx * sumy) / sqrt((n * sumx2 - Sq(sumx)) * (n * sumy2 - Sq(sumy)));
    switch (znao->dataType) {
    m4ForAllRealDataType(`m4corr(', `)')
    default:            /* error */
	assert(FALSE);
    }
    return TCL_OK;
}

/*
 *  Nap_Correlation --
 *
 *  Nap function 'correlation(x, ?y,? ?lag0,? ?lag1,? ...)'
 *  Calculates Pearson product-moment correlations (omitting cases where either value is missing).
 *  If x or y is F64 then result is F64, else it is F32. (But calculation still done using F64.)
 *  Dimension 0 has size 2. Index 0 corresponds to the correlation values themselves, while index 1
 *  corresponds to the sample sizes (n).
 *
 *  If there is only one argument (x) then this must be a matrix.  In this case the result
 *  is a matrix such that element (i,j) is the correlation between columns i & j of the argument.
 *
 *  If y is defined then smaller of x & y is a window (chip) array which is moved around in other
 *  array.  In this case the result is array of correlations for each position.
 *  Ranks of x and y must be the same.  (Current version supports ranks 1 & 2 only.)
 *  lag0 is vector of row    lags (default: all possible)
 *  lag1 is vector of column lags (default: all possible)
 */

m4define(`m4NAME', `Nap_Correlation')

static char *
Nap_Correlation(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_NAO		*arg0_nao;		/* 1st argument */
    Nap_NAO		*arg1_nao;		/* 2nd argument */
    Nap_NAO		*cvy[NAP_MAX_RANK];	/* coordinate variables of y */
    Nap_NAO		*cvz[NAP_MAX_RANK];	/* coordinate variables of z */
    Nap_dataType        dataType;		/* of result */
    int			i;			/* subscript */
    int			ijx0;			/* subscript of start of row of x */
    int			ijy0;			/* subscript of start of row of y */
    int			ix;			/* row of x */
    int			iz;			/* row of z */
    int			j;			/* subscript */
    int			jx;			/* column of x */
    int			jz;			/* column of z */
    Nap_NAO		*lag[NAP_MAX_RANK];	/* arguments 2, 3, ... */
    int			lag0;			/* lag in row */
    int			lag1;			/* lag in column */
    double		n;			/* # elements in x */
    int			ncx;			/* # columns in x */
    int			nrx;			/* # rows in x */
    int			ncy;			/* # columns in y */
    int			nry;			/* # rows in y */
    int			ncz;			/* # columns in z */
    int			nrz;			/* # rows in z */
    size_t		shape[NAP_MAX_RANK];
    int			status;
    double		sumx;			/* sum(x) */
    double		sumx2;			/* sum(x*x) */
    double		sumxy;			/* sum(x*y) */
    double		sumy;			/* sum(y) */
    double		sumy2;			/* sum(y*y) */
    Nap_NAO		*tmp_nao;
    Nap_NAO		*xnao;			/* x = moving window matrix */
    Nap_NAO		*ynao;			/* y = main matrix */
    Nap_NAO		*znao;			/* z = result */

    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    Nap_IncrRefCount(nap_cd, box_nao);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels > 0,  "m4NAME: No arguments");
    arg0_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    CHECK2NULL(arg0_nao, "m4NAME: Error calling Nap_GetNaoFromSlot");
    dataType = Max(m4DataTypeEnum(m4MinRealDataType), arg0_nao->dataType);
    if (box_nao->nels > 1) {
	arg1_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
	CHECK2NULL(arg1_nao, "m4NAME: Error calling Nap_GetNaoFromSlot");
	dataType = Max(dataType, arg1_nao->dataType);
	CHECK2NULL(arg0_nao->rank == arg1_nao->rank, "m4NAME: Rank of x differs from that of y");
	CHECK2NULL(arg0_nao->rank > 0, "m4NAME: Rank of x is 0");
	CHECK2NULL(arg0_nao->rank < 3, "m4NAME: Rank of x > 2 which is not yet supported");
	CHECK2NULL(box_nao->nels <= 2+arg0_nao->rank, "m4NAME: Too many arguments");
	if (arg0_nao->nels > arg1_nao->nels) {
	    tmp_nao = arg0_nao;
	    arg0_nao = arg1_nao;
	    arg1_nao = tmp_nao;
	}
	shape[0] = arg0_nao->shape[0];
	shape[1] = arg0_nao->rank > 1 ? arg0_nao->shape[1] : 1;
	xnao = Nap_ReshapeNAO(nap_cd, arg0_nao, NAP_F64, 2, shape);
	CHECK2NULL(xnao, "m4NAME: Error calling Nap_ReshapeNAO");
	Nap_IncrRefCount(nap_cd, xnao);
	shape[0] = arg1_nao->shape[0];
	shape[1] = arg1_nao->rank > 1 ? arg1_nao->shape[1] : 1;
	ynao = Nap_ReshapeNAO(nap_cd, arg1_nao, NAP_F64, 2, shape);
	CHECK2NULL(ynao, "m4NAME: Error calling Nap_ReshapeNAO");
	Nap_IncrRefCount(nap_cd, ynao);
	for (i = 0; i < 2; i++) {
	    tmp_nao = Nap_GetCoordVar(nap_cd, ynao, i);
	    if (tmp_nao) {
		Nap_IncrRefCount(nap_cd, tmp_nao);
		cvy[i] = Nap_CastNAO(nap_cd, tmp_nao, NAP_F32);
		CHECK2NULL(cvy[i], "m4NAME: Error calling Nap_CastNAO");
		Nap_IncrRefCount(nap_cd, cvy[i]);
		Nap_DecrRefCount(nap_cd, tmp_nao);
	    } else {
		cvy[i] = Nap_NewNAO(nap_cd, NAP_F32, 1, ynao->shape + i);
		CHECK2NULL(cvy[i], "m4NAME: Error calling Nap_NewNAO");
		Nap_IncrRefCount(nap_cd, cvy[i]);
		for (j = 0; j < cvy[i]->nels; j++) {
		    cvy[i]->data.F32[j] = j;
		}
	    }
	    if (box_nao->nels > i+2) {
		tmp_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[i+2]);
		CHECK2NULL(tmp_nao, "m4NAME: Error calling Nap_GetNaoFromSlot");
		CHECK3NULL(tmp_nao->rank < 2, "m4NAME: Rank of lag %d > 1", i);
		Nap_IncrRefCount(nap_cd, tmp_nao);
		shape[0] = tmp_nao->nels;
		lag[i] = Nap_ReshapeNAO(nap_cd, tmp_nao, NAP_I32, 1, shape);
		CHECK2NULL(lag[i], "m4NAME: Error calling Nap_ReshapeNAO");
		Nap_IncrRefCount(nap_cd, lag[i]);
		Nap_DecrRefCount(nap_cd, tmp_nao);
	    } else {
		shape[0] = 1 + ynao->shape[i] - xnao->shape[i];
		lag[i] = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
		CHECK2NULL(lag[i], "m4NAME: Error calling Nap_NewNAO");
		Nap_IncrRefCount(nap_cd, lag[i]);
		for (j = 0; j < lag[i]->nels; j++) {
		    lag[i]->data.I32[j] = j;
		}
	    }
	}
	shape[0] = 2;
	shape[1] = nrz = lag[0]->nels;
	shape[2] = ncz = lag[1]->nels;
	znao = Nap_NewNAO(nap_cd, dataType, 1 + arg0_nao->rank, shape);
	CHECK2NULL(znao, "m4NAME: Error calling Nap_NewNAO");
	for (i = 1; i < znao->rank; i++) {
	    cvz[i] = Nap_NewNAO(nap_cd, NAP_F32, 1, shape+i);
	    CHECK2NULL(cvz[i], "m4NAME: Error calling Nap_NewNAO");
	    status = Nap_AttachCoordVar(nap_cd, znao, cvz[i], ynao->dimName[i-1], i);
	    CHECK1NULL(status == TCL_OK);
	}
	nrx = xnao->shape[0];
	ncx = xnao->shape[1];
	nry = ynao->shape[0];
	ncy = ynao->shape[1];
	CHECK2NULL(nrx <= nry  &&  ncx <= ncy, "m4NAME: Shape of x incompatible with that of y");
	for (iz = 0; iz < nrz; iz++) {
	    lag0 = lag[0]->data.I32[iz];
	    cvz[1]->data.F32[iz] = 0.5 * (cvy[0]->data.F32[lag0] + cvy[0]->data.F32[lag0+nrx-1]);
	    for (jz = 0; jz < ncz; jz++) {
		lag1 = lag[1]->data.I32[jz];
		n = sumx = sumx2 = sumy = sumy2 = sumxy = 0.0;
		if (znao->rank > 2) {
		    cvz[2]->data.F32[jz]
			    = 0.5 * (cvy[1]->data.F32[lag1] + cvy[1]->data.F32[lag1+ncx-1]);
		}
		for (ix = 0; ix < nrx; ix++) {
		    ijx0 = ix * ncx;
		    ijy0 = lag1 + (lag0 + ix) * ncy;
		    for (jx = 0; jx < ncx; jx++) {
			i = ijx0 + jx;
			j = ijy0 + jx;
			if (!IsMissing(xnao, i)  &&  !IsMissing(ynao, j)) {
			    ++n;
			    sumx  += xnao->data.F64[i];
			    sumx2 += Sq(xnao->data.F64[i]);
			    sumy  += ynao->data.F64[j];
			    sumy2 += Sq(ynao->data.F64[j]);
			    sumxy += xnao->data.F64[i] * ynao->data.F64[j];
			}
		    }
		}
		status = Nap_CorrelationStore(n, sumx, sumx2, sumy, sumy2, sumxy, znao,
			jz+iz*ncz, jz+iz*ncz+ncz*nrz);
		CHECK1NULL(status == TCL_OK);
	    }
	}
	for (i = 0; i < 2; i++) {
	    Nap_DecrRefCount(nap_cd, lag[i]);
	    Nap_DecrRefCount(nap_cd, cvy[i]);
	}
	Nap_DecrRefCount(nap_cd, ynao);
    } else {
	CHECK2NULL(arg0_nao->rank == 2, "m4NAME: Rank of argument should be 2");
	xnao = Nap_CastNAO(nap_cd, arg0_nao, NAP_F64);
	CHECK2NULL(xnao, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, xnao);
	nrx = xnao->shape[0];
	shape[0] = 2;
	shape[1] = shape[2] = nrz = ncz = ncx = xnao->shape[1];
	znao = Nap_NewNAO(nap_cd, dataType, 3, shape);
	CHECK2NULL(znao, "m4NAME: error calling Nap_NewNAO");
	tmp_nao = Nap_GetCoordVar(nap_cd, xnao, 1);
	for (i = 1; i < 3; i++) {
	    status = Nap_AttachCoordVar(nap_cd, znao, tmp_nao, NULL, i);
	    CHECK1NULL(status == TCL_OK);
	}
	for (iz = 0; iz < ncx; iz++) {
	    for (jz = 0; jz <= iz; jz++) {
		n = sumx = sumx2 = sumy = sumy2 = sumxy = 0.0;
		for (ix = 0; ix < nrx; ix++) {
		    i = iz + ncx * ix;
		    j = jz + ncx * ix;
		    if (!IsMissing(xnao, i)  &&  !IsMissing(xnao, j)) {
			++n;
			sumx  += xnao->data.F64[i];
			sumx2 += Sq(xnao->data.F64[i]);
			sumy  += xnao->data.F64[j];
			sumy2 += Sq(xnao->data.F64[j]);
			sumxy += xnao->data.F64[i] * xnao->data.F64[j];
		    }
		}
		status = Nap_CorrelationStore(n, sumx, sumx2, sumy, sumy2, sumxy, znao,
			jz+iz*ncx, jz+iz*ncx+ncz*nrz);
		CHECK1NULL(status == TCL_OK);
		status = Nap_CorrelationStore(n, sumx, sumx2, sumy, sumy2, sumxy, znao,
			iz+jz*ncx, iz+jz*ncx+ncz*nrz);
		CHECK1NULL(status == TCL_OK);
	    }
	}
    }
    Nap_DecrRefCount(nap_cd, xnao);
    Nap_DecrRefCount(nap_cd, box_nao);
    return znao->id;
}

/*
 * solve_quadratic --
 * Returns number of real solutions (0, 1 or 2)
 *
 * Reference: 
 * 	W.H. Press, et. al
 *	Numerical Recipes in C
 *	page 156
 */

m4define(`m4NAME', `solve_quadratic')

static int
solve_quadratic(
    float		a,			/* coeff of quadratic */
    float		b,			/* coeff of quadratic */
    float		c,			/* coeff of quadratic */
    float		x[2])			/* solutions (out) */
{
    double		d;			/* discriminant of quadratic */
    int			n;			/* # solutions of quadratic */
    float		q;

    d = b * b - 4.0 * a * c;
    if (a == 0.0f) {
	if (b == 0.0f) {
	    n = 0;
	} else {
	    n = 1;
	    x[0] = -c / b;
	}
    } else if (d > 0.0) {
	n = 2;
	q = (-0.5) * (b + Sign(b) * sqrt(d));
	x[0] = q / a;
	x[1] = c / q;
    } else if (d == 0.0) {
	n = 1;
	x[0] = -b / (a + a);
    } else {
	n = 0;
    }
    return n;
}

/*
 * Nap_pad --
 *
 * NAP function 'pad' which pads a ragged array to form an ordinary array.
 * 1st arg is ragged nao.  
 * 2nd arg is value for padding (default is missing value of NAO argument).  
 * All rows should have same data type.
 * If 1st argument is not ragged then this is returned as result.
 */

m4define(`m4NAME', `Nap_pad')

static char *
Nap_pad(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_dataType        dataType;
    int			i;			/* subscript */
    int			k0;			/* char start position */
    int			ncols;			/* # columns in result */
    int			nk;			/* s * row->nels */
    int			nrows;			/* # rows in result */
    Nap_NAO		*pad_nao;		/* value for padding */
    Nap_NAO		*ragged_nao;		/* 1st arg. */
    int                 rank;
    Nap_NAO		*row;			/* row of ragged matrix */
    Nap_NAO		*result;
    Nap_NAO		*start_nao;		/* ragged start index */
    int			s;			/* size of data type */
    int			status;
    char		*str;
    Nap_NAO		*tmp_nao;
    const char		*usage =
	"m4NAME: Usage should be 'pad(ragged)' or 'pad(ragged, pad_value)'";

    assert(box_nao);
    CHECK2NULL(box_nao->dataType == NAP_BOXED, "m4NAME: Argument not boxed");
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels == 1  ||  box_nao->nels == 2, usage);
    ragged_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    if (ragged_nao->dataType == NAP_RAGGED) {
	rank = ragged_nao->rank;
	CHECK2NULL(rank > 1, "m4NAME: rank of ragged array < 2");
	row = Nap_UnboxedElement1(nap_cd, ragged_nao);
	dataType = row ? row->dataType : NAP_I8;
	result = Nap_NewNAO(nap_cd, dataType, rank, ragged_nao->shape);
	CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, ragged_nao, result);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
	s = Nap_SizeOf(dataType);
	if (box_nao->nels == 2) {
	    pad_nao = Nap_CastNAO(nap_cd, Nap_GetNaoFromSlot(box_nao->data.Boxed[1]),
		    dataType);
	    CHECK2NULL(pad_nao, "m4NAME: Error calling Nap_CastNAO");
	    CHECK2NULL(pad_nao->nels == 1, "m4NAME: pad_value is not scalar");
	    str = pad_nao->data.c;
	} else {
	    tmp_nao = Nap_GetMissingValueNAO(nap_cd, row ? row : result);
            CHECK1NULL(tmp_nao);
            str = tmp_nao->data.c;
	}
	for (i = 0; i < result->nels; i++) {	/* init with missing values */
	    memcpy(result->data.c+s*i, str, s);
	}
	if (box_nao->nels == 2  &&  pad_nao->slot != box_nao->data.Boxed[1]) {
	    Nap_FreeNAO(nap_cd, pad_nao);
	}
	start_nao = Nap_GetNaoFromSlot(ragged_nao->raggedStartSlot);
	CHECK2NULL(start_nao, "m4NAME: raggedStart NAO is NULL");
	CHECK2NULL(start_nao->dataType == NAP_I32,
		"m4NAME: raggedStart NAO not type int	");
	CHECK2NULL(start_nao->nels == ragged_nao->nels,
		"m4NAME: raggedStart NAO has wrong # elements");
        ncols = result->shape[rank-1];
        nrows = result->nels / ncols;
	for (i = 0; i < nrows; i++) {
	    row = Nap_GetNaoFromSlot(ragged_nao->data.Boxed[i]);
	    if (row) {
		nk = s * row->nels;
		k0 = s * (start_nao->data.I32[i] + ncols * i);
		memcpy(result->data.c+k0, row->data.c, nk);
	    }
	}
    } else {
	result = ragged_nao;
    }
    return result->id;
}

/*
 * Nap_prune --
 *
 * NAP function 'prune' which is inverse of function 'pad'.  In other words it
 * compresses an ordinary array to a ragged array.
 * 1st arg is array to be compressed by removing leading & trailing padding in
 * each row.
 * 2nd arg is value of padding (default is missing value of NAO argument).  
 */

m4define(`m4NAME', `Nap_prune')

static char *
Nap_prune(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_dataType        dataType;
    int			i;			/* subscript */
    Nap_NAO		*in_nao;		/* input nao (1st arg.) */
    int			j;			/* subscript */
    int			k0;			/* char start position */
    int			n;			/* # els before this row */
    int			ncols;			/* # columns in result */
    int			newMV;			/* slot of new missing value */
    int			nk;			/* s * row->nels */
    int			npad;			/* # leading pad elements */
    int			nrows;			/* # rows in result */
    int			oldMV;			/* slot of old missing value */
    Nap_NAO		*pad_nao;		/* value for padding */
    int			rank;
    Nap_NAO		*row;			/* row of ragged matrix */
    Nap_NAO		*result;
    size_t		shape[1];
    Nap_NAO		*start_nao;		/* ragged start index */
    int			s;			/* size of data type */
    int			status;
    const char		*usage =
	"m4NAME: Usage should be 'prune(array)' or 'prune(array, pad_value)'";

    assert(box_nao);
    CHECK2NULL(box_nao->dataType == NAP_BOXED, "m4NAME: Argument not boxed");
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels == 1  ||  box_nao->nels == 2, usage);
    in_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    if (in_nao->dataType == NAP_RAGGED  ||  in_nao->rank < 2) {
	result = in_nao;
    } else {
	dataType = in_nao->dataType;
	rank = in_nao->rank;
	newMV = oldMV = in_nao->missingValueSlot;
        if (box_nao->nels == 2) {
            pad_nao = Nap_CastNAO(nap_cd, Nap_GetNaoFromSlot(box_nao->data.Boxed[1]), dataType);
	    CHECK2NULL(pad_nao, "m4NAME: Error calling Nap_CastNAO");
            CHECK2NULL(pad_nao->nels == 1, "m4NAME: pad_value is not scalar");
	    Nap_IncrRefCount(nap_cd, pad_nao);
	    newMV = pad_nao->slot;
	    status = Nap_SetMissing(nap_cd, in_nao, newMV);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	    Nap_DecrRefCount(nap_cd, pad_nao);
	}
	result = Nap_NewNAO(nap_cd, NAP_RAGGED, in_nao->rank, in_nao->shape);
	CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, in_nao, result);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyDims");
	s = Nap_SizeOf(dataType);
	ncols = in_nao->shape[rank-1];
	nrows = in_nao->nels / ncols;
	shape[0] = nrows;
	start_nao = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	CHECK2NULL(start_nao, "m4NAME: Error calling Nap_NewNAO");
	result->raggedStartSlot = start_nao->slot;
	++start_nao->count;
	for (i = 0; i < result->nels; i++) {
	    n = ncols * i;
	    npad = 0;
	    for (j = 0; j < ncols && IsMissing(in_nao,n+j); j++) {
		++npad;
	    }
	    start_nao->data.I32[i] = npad;
	    shape[0] = ncols - npad;
	    if (npad < ncols) {
		for (j = ncols -1; IsMissing(in_nao,n+j); j--) {
		    --shape[0];
		}
	    }
	    row = Nap_NewNAO(nap_cd, dataType, 1, shape);
	    CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
	    status = Nap_SetMissing(nap_cd, row, newMV);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	    result->data.Boxed[i] = row->slot;
	    ++row->count;
	    nk = s * row->nels;
	    k0 = s * (start_nao->data.I32[i] + n);
	    memcpy(row->data.c, in_nao->data.c + k0, nk);
	}
        if (newMV != oldMV) {	/* restore old missing value */
	    status = Nap_SetMissing(nap_cd, in_nao, oldMV);
            CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	}
    }
    return result->id;
}

/*
 * Nap_psum --
 *	Partial-sum function psum(v)
 */

m4begin

m4define(`m4NAME', `Nap_psum')

#	m4psum_mv(type) -- change missing values to 0
m4define(`m4psum_mv', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < result->nels; i++) {
		if (IsMissing(result, i)) {
		    result->data.$1[i] = 0;
		}
	    }
	    break;')

#	m4psum1(type) -- rank = 1
m4define(`m4psum1', `
	case m4DataTypeEnum($1):
	    for (i = 1; i < result->nels; i++) {
		result->data.$1[i] += result->data.$1[i-1];
	    }
	    break;')

#	m4psum2(type) -- rank = 2
m4define(`m4psum2', `
	case m4DataTypeEnum($1):
	    for (j = 1; j < ncols; j++) {
		result->data.$1[j] += result->data.$1[j-1];
	    }
	    for (i = 1; i < nrows; i++) {
		result->data.$1[ncols*i] += result->data.$1[ncols*(i-1)];
		for (j = 1; j < ncols; j++) {
		    result->data.$1[ncols*i+j] += result->data.$1[ncols*(i-1)+j]
			    + result->data.$1[ncols*i+j-1]
			    - result->data.$1[ncols*(i-1)+j-1];
		}
	    }
	    break;')

#	m4psum(type) -- any rank > 0
m4define(`m4psum', `
	case m4DataTypeEnum($1):
	    for (i = 1; i < result->nels; i++) {
		status = mixedBase(i, rank-1, shape+1, index);
		CHECK2NULL(!status, "m4NAME: Error calling mixedBase");
		for (j = 1; j < n; j++) {
		    s = -1;
		    k = i;
		    for (d = 0; d < rank; d++) {
			bit = 1 & (j >> d);
			s *= (1 - bit - bit) * (index[d] >= bit);
			k -= bit * w[d];
		    }
		    result->data.$1[i] += s * result->data.$1[k];
		}
	    }
	    break;')
m4end

static char *
Nap_psum(
    NapClientData	*nap_cd, 
    Nap_NAO		*naoPtr)		/* data */
{
    long		bit;			/* 0 or 1 */
    long		d;			/* dimension subscript */
    long		i;			/* subscript */
    long		index[NAP_MAX_RANK];	/* subscripts for general rank */
    long		j;			/* subscript */
    long		k;			/* subscript */
    const long		max_rank = sizeof(long) * CHAR_BIT - 2;
    long		n;			/* pow(2,rank) */
    long		ncols;			/* for rank 2 */
    long		nrows;			/* for rank 2 */
    long		rank = naoPtr->rank;
    Nap_NAO		*result;
    long		s;			/* sign (-1, 0 or +1) */
    long		shape[NAP_MAX_RANK];
    int			status;
    long		w[NAP_MAX_RANK];	/* weights for indexing */

    assert(naoPtr);
    result = Nap_CopyNAO(nap_cd, naoPtr);
    CHECK2NULL(result, "m4NAME: error calling Nap_CopyNAO");
    switch (naoPtr->dataType) {
	m4ForAllNumericDataType(`m4psum_mv(', `)')
	default:                /* error */
	    return NULL;
    }
    switch (rank) {
	case 0:
	    break;
	case 1:
	    switch (naoPtr->dataType) {
		m4ForAllNumericDataType(`m4psum1(', `)')
		default:                /* error */
		    return NULL;
	    }
	    break;
	case 2:
	    nrows = result->shape[0];
	    ncols = result->shape[1];
	    switch (naoPtr->dataType) {
		m4ForAllNumericDataType(`m4psum2(', `)')
		default:                /* error */
		    return NULL;
	    }
	    break;
	default:
	    for (d = 0; d < rank; d++) {
		shape[d] = result->shape[d];
	    }
	    w[rank-1] = 1;
	    for (d = rank-1; d > 0; d--) {
		w[d-1] = w[d] * shape[d];
	    }
	    CHECK4NULL(rank < max_rank, "m4NAME: rank = %ld which exceeds maximum of %ld",
		    rank, max_rank);
	    n = 1L << rank;
	    switch (naoPtr->dataType) {
		m4ForAllNumericDataType(`m4psum(', `)')
		default:                /* error */
		    return NULL;
	    }
    }
    return result->id;
}


/*
 * Nap_sort --
 *	function sort(v) which sorts vector into ascending order
 *	Consider NaN < -infinity
 *	Other missing values simply treated as having their numeric value.
 */

m4begin

#	m4cmpInt(type)
m4define(`m4cmpInt', `
int cmp$1(const void *xp, const void *yp) {
    m4DataTypeName($1) x = *((m4DataTypeName($1) *) xp);
    m4DataTypeName($1) y = *((m4DataTypeName($1) *) yp);
    return x < y ? -1 : (x > y ? 1 : 0);
}')

#	m4cmpReal(type)
m4define(`m4cmpReal', `
int cmp$1(const void *xp, const void *yp) {
    m4DataTypeName($1) x = *((m4DataTypeName($1) *) xp);
    m4DataTypeName($1) y = *((m4DataTypeName($1) *) yp);
    if (m4isNaN($1)(x)  ||  x < y)  return -1;
    if (m4isNaN($1)(y)  ||  y < x)  return  1;
    return 0;
}')

#	m4sort(type)
m4define(`m4sort', `
	case m4DataTypeEnum($1):
	    qsort(result->data.$1, n, s, cmp$1);
	    break;')

m4define(`m4NAME', `Nap_sort')

m4end

m4ForAllCharacterDataType(`m4cmpInt(', `)')
m4ForAllIntegerDataType(`m4cmpInt(', `)')
m4ForAllRealDataType(`m4cmpReal(', `)')

static char *
Nap_sort(
    NapClientData	*nap_cd, 
    Nap_NAO		*naoPtr)		/* data (must be vector) */
{
    size_t		n;
    size_t		s;
    Nap_NAO		*result;

    assert(naoPtr);
    CHECK2NULL(naoPtr->rank == 1, "m4NAME: rank of argument of sort() not 1");
    result = Nap_CopyNAO(nap_cd, naoPtr);
    CHECK2NULL(result, "m4NAME: error calling Nap_CopyNAO");
    n = naoPtr->nels;
    s = Nap_SizeOf(naoPtr->dataType);
    switch (naoPtr->dataType) {
        m4ForAllUnboxedDataType(`m4sort(', `)')
        default:                /* error */
            return NULL;
    }
    return result->id;
}

/*
 * Nap_invert_grid --
 */

m4define(`m4NAME', `Nap_invert_grid')

#define MAX_GRID_RANK 2

static char *
Nap_invert_grid(
    NapClientData	*nap_cd, 
    char		*str)			/* id of box nao */
{
    float		a;			/* coeff of quadratic */
    float		b;			/* coeff of quadratic */
    float		bc;			/* const in formula for b */
    Nap_NAO		*box_nao;		/* points to user's arguments */
    float		c;			/* coeff of quadratic */
    float		cc;			/* const in formula for c */
    float		delta;			/* tolerance in CV */
    const float		eps = 1E-4;		/* delta = eps * range_of_CV */
    const float		epsilon = 0.02;		/* tolerance in line/pixel */
    float		h[2][4];		/* coeff's of hyperboloids */
    const float		highest = 1.0+epsilon;	/* max line/pixel */
    int			i;			/* subscript 0 of input nao */
    float		ii;			/* fractional extension of i */
    int			imin[MAX_GRID_RANK];	/* lower value of index0/1 */
    int			imax[MAX_GRID_RANK];	/* upper value of index0/1 */
    int			index0;			/* subscript 0 of output nao */
    int			index1;			/* subscript 1 of output nao */
    int			j;			/* subscript 1 of input nao */
    float		jj[2];	/* solution for fractional extension of j */
    int			k;			/* subscript */
    int			kk;			/* subscript */
    const float		lowest = -epsilon;	/* min line/pixel */
    Nap_NAO		*main_nao[MAX_GRID_RANK]; /* user arg */
    float		maxValue;
    float		minValue;
    int			n;			/* # solutions of quadratic */
    float		*new_cv[MAX_GRID_RANK];	/* new_cv_nao->data */
    Nap_NAO		*new_cv_nao[MAX_GRID_RANK]; /* subset of user arg */
    float		*old_cv[MAX_GRID_RANK];	/* old_cv_nao->data */
    Nap_NAO		*old_cv_nao[MAX_GRID_RANK]; /* CV of main_nao */
    int			rank;			/* rank of main_nao */
    Nap_NAO		*result;
    size_t		shape[MAX_GRID_RANK+1];	/* shape of result */
    int			shape_main[MAX_GRID_RANK]; /* shape of main_nao */
    int			status;
    float		tmp;			/* temporary value */
    Nap_NAO		*tmp_nao1;		/* temporary nao pointer */
    Nap_NAO		*tmp_nao2;		/* temporary nao pointer */
    float		value;			/* temporary value */
    float		w0;			/* weight of lower point */
    float		w1;			/* weight of higher point */
    float		x0;			/* new_cv[0] value e.g. lat */
    float		x1;			/* new_cv[1] value e.g. lon */
    float		z00;	/* main_nao value in left bottom corner */
    float		z01;	/* main_nao value in right bottom corner */
    float		z10;	/* main_nao value in left top corner */
    float		z11;	/* main_nao value in right top corner */

    assert(str);
    box_nao = Nap_GetNaoFromId(nap_cd, str);
    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels % 2 == 0, "m4NAME: Odd # elements (arguments)");
    CHECK2NULL(box_nao->nels > 0, "m4NAME: 0 elements (arguments)");
    rank = box_nao->nels / 2;
    CHECK2NULL(rank <= MAX_GRID_RANK, "m4NAME: Too many elements (arguments)");
    for (i = 0; i < rank; i++) {
	tmp_nao1 = Nap_GetNaoFromSlot(box_nao->data.Boxed[2*i]);
	CHECK2NULL(tmp_nao1, "m4NAME: NULL argument");
	CHECK2NULL(tmp_nao1->rank == rank, "m4NAME: Main array has wrong rank");
	main_nao[i] = Nap_CastNAO(nap_cd, tmp_nao1, NAP_F32);
	CHECK2NULL(main_nao[i], "m4NAME: Error calling Nap_CastNAO");
	maxValue = -FLT_MAX;
	minValue =  FLT_MAX;
	for (j = 0; j < main_nao[i]->nels; j++) {
	    value = main_nao[i]->data.F32[j];
	    if (!IsNaN32(value)) {
		maxValue = Max(maxValue, value);
		minValue = Min(minValue, value);
	    }
	}
	delta = 8.0 * FLT_EPSILON * Max(Abs(maxValue), Abs(minValue));
	minValue -= delta;
	maxValue += delta;
	tmp_nao1 = Nap_GetNaoFromSlot(box_nao->data.Boxed[2*i+1]);
	CHECK2NULL(tmp_nao1, "m4NAME: NULL argument");
	CHECK2NULL(tmp_nao1->rank == 1, "m4NAME: Coordinate variable has wrong rank");
	tmp_nao2 = Nap_CastNAO(nap_cd, tmp_nao1, NAP_F32);
	CHECK2NULL(tmp_nao2, "m4NAME: Error calling Nap_CastNAO");
	shape[0] = 0;
	for (j = 0; j < tmp_nao2->nels; j++) {
	    value = tmp_nao2->data.F32[j];
	    shape[0] += value >= minValue  &&  value <= maxValue;
	}
	new_cv_nao[i] = Nap_NewNAO(nap_cd, NAP_F32, 1, shape);
	CHECK2NULL(new_cv_nao[i], "m4NAME: Error calling Nap_NewNAO");
	status = Nap_AttachCoordVar(nap_cd, new_cv_nao[i], NULL, tmp_nao1->dimName[0], 0);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	if (main_nao[i]->unit) {
	    new_cv_nao[i]->unit = Nap_StrDup(main_nao[i]->unit);
	} else if (tmp_nao1->unit) {
	    new_cv_nao[i]->unit = Nap_StrDup(tmp_nao1->unit);
	}
	new_cv[i] = new_cv_nao[i]->data.F32;
	for (j = k = 0; j < tmp_nao2->nels; j++) {
	    value = tmp_nao2->data.F32[j];
	    if (value >= minValue  &&  value <= maxValue) {
		new_cv[i][k++] = value;
	    }
	}
	Nap_FreeNAO(nap_cd, tmp_nao2);
    }
    for (j = 0; j < rank; j++) {
	shape_main[j] = main_nao[0]->shape[j];
	for (i = 0, tmp_nao1 = NULL; i < rank && !tmp_nao1; i++) {
	    tmp_nao1 = Nap_GetCoordVar(nap_cd, main_nao[i], j);
	}
	if (tmp_nao1) {
	    old_cv_nao[j] = Nap_CastNAO(nap_cd, tmp_nao1, NAP_F32);
	    CHECK2NULL(old_cv_nao[j], "m4NAME: Error calling Nap_CastNAO");
	    if (old_cv_nao[j] != tmp_nao1) {
		Nap_FreeNAO(nap_cd, tmp_nao1);
	    }
	    old_cv[j] = old_cv_nao[j]->data.F32;
	} else {
	    old_cv_nao[j] = NULL;
	    old_cv[j] = NULL;
	}
    }
    for (i = 0; i < rank; i++) {
	for (j = 0; j < rank; j++) {
	    CHECK2NULL(main_nao[i]->shape[j] == shape_main[j],
		    "m4NAME: Main arrays have different shapes");
	    tmp_nao1 = Nap_GetCoordVar(nap_cd, main_nao[i], j);
	    if (old_cv[j] && tmp_nao1) {
		tmp_nao2 = Nap_CastNAO(nap_cd, tmp_nao1, NAP_F32);
		CHECK2NULL(tmp_nao2, "m4NAME: Error calling Nap_CastNAO");
		if (tmp_nao2 != tmp_nao1) {
		    Nap_FreeNAO(nap_cd, tmp_nao1);
		}
		if (shape_main[j] > 0) {
		    delta = eps * Abs(old_cv[j][shape_main[j]-1]-old_cv[j][0]);
		}
		for (k = 0; k < shape_main[j]; k++) {
		    CHECK2NULL(Abs(tmp_nao2->data.F32[k] - old_cv[j][k]) <= delta,
			    "m4NAME: Main arrays have different coordinate variables");
		}
		Nap_FreeNAO(nap_cd, tmp_nao2);
	    }
	}
    }
    switch (rank) {
    case 1:
	result = Nap_NewNAO(nap_cd, NAP_F32, 1, shape);
	CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
	if (old_cv_nao[0]) {
	    status = Nap_AttachLink(nap_cd, result, Nap_NewScalarNAO(nap_cd, NAP_I32, 1.0));
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
	}
	status = Nap_AttachCoordVar(nap_cd, result, new_cv_nao[0], new_cv_nao[0]->dimName[0], 0);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	tmp = -1.0;
	for (j = 0; j < result->nels; j++) {
	    tmp = Nap_IndexOfNao(
		    nap_cd,
		    main_nao[0],
		    &(new_cv[0][j]),
		    tmp);
	    k = tmp;
	    w1 = tmp - k;
	    w0 = 1.0f - w1;
	    if (old_cv_nao[0]) {
		result->data.F32[j] = w0 * old_cv[0][k];
		if (w1) {
		    result->data.F32[j] += w1 * old_cv[0][k+1];
		}
	    } else {
		result->data.F32[j] = tmp;
	    }
	}
	break;
    case 2:
	shape[0] = new_cv_nao[0]->nels;
	shape[1] = new_cv_nao[1]->nels;
	shape[2] = 2;
	result = Nap_NewNAO(nap_cd, NAP_F32, 3, shape);
	CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
	shape[0] = 2;
	tmp_nao1 = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	CHECK2NULL(tmp_nao1, "m4NAME: Error calling Nap_NewNAO");
	for (i = 0; i < 2; i++) {
	    tmp_nao1->data.I32[i] = old_cv_nao[i] ? 1 : 0;
	}
	status = Nap_AttachLink(nap_cd, result, tmp_nao1);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
	status = Nap_AttachCoordVar(nap_cd, result, new_cv_nao[0], new_cv_nao[0]->dimName[0], 0);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	status = Nap_AttachCoordVar(nap_cd, result, new_cv_nao[1], new_cv_nao[1]->dimName[0], 1);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachCoordVar");
	if (result->nels == 0) {
	    break;
	}
	for (i = 0; i < result->nels; i++) {
	    result->data.F32[i] = NAP_F32_NULL;
	}
	for (i = 0; i < shape_main[0]-1; i++) {
	    tmp = -1.0;
	    for (j = 0; j < shape_main[1]-1; j++) {
		imin[0] = imax[0] = 0;
		for (k = 0; k < 2 && imin[0] <= imax[0]; k++) {
		    z00 = main_nao[k]->data.F32[shape_main[1]*i+j];
		    z01 = main_nao[k]->data.F32[shape_main[1]*i+j+1];
		    z10 = main_nao[k]->data.F32[shape_main[1]*(i+1)+j];
		    z11 = main_nao[k]->data.F32[shape_main[1]*(i+1)+j+1];
		    h[k][0] = z00;
		    h[k][1] = z10 - z00;
		    h[k][2] = z01 - z00;
		    h[k][3] = z00 - z01 - z10 + z11;
		    maxValue = Max(Max(z00, z01), Max(z10, z11));
		    minValue = Min(Min(z00, z01), Min(z10, z11));
		    tmp = Nap_IndexOfNao(
			    nap_cd,
			    new_cv_nao[k],
			    new_cv[k][0] < new_cv[k][1] ? &minValue : &maxValue,
			    tmp);
		    imin[k] = ceil(Max(Min(tmp, new_cv_nao[k]->nels-1), 0.0));
		    tmp = Nap_IndexOfNao(
			    nap_cd,
			    new_cv_nao[k],
			    new_cv[k][0] < new_cv[k][1] ? &maxValue : &minValue,
			    tmp);
		    imax[k] = floor(Max(Min(tmp, new_cv_nao[k]->nels-1), 0.0));
		}
		if (imin[0] <= imax[0]  &&  imin[1] <= imax[1]) {
		    a = h[0][3] * h[1][2] - h[0][2] * h[1][3];
		    bc = h[0][1] * h[1][2] - h[0][2] * h[1][1]
		       + h[0][3] * h[1][0] - h[0][0] * h[1][3];
		    cc = h[0][1] * h[1][0] - h[0][0] * h[1][1];
		    for (index0 = imin[0]; index0 <= imax[0]; index0++) {
			x0 = new_cv[0][index0];
			for (index1 = imin[1]; index1 <= imax[1]; index1++) {
			    x1 = new_cv[1][index1];
			    b = bc + h[1][3] * x0 - h[0][3] * x1 ;
			    c = cc + h[1][1] * x0 - h[0][1] * x1; 
			    n = solve_quadratic(a, b, c, jj);
			    for (k = 0; k < n; k++) {
				if (jj[k] >= lowest  &&  jj[k] <= highest) {
				    ii = (x0 - h[0][0] - h[0][2] * jj[k])
					    / (h[0][1] + h[0][3] * jj[k]);
				    if (ii >= lowest  &&  ii <= highest) {
					w1 = ii;
					w0 = 1.0f - w1;
					kk = 2 * (shape[1] * index0 + index1);
					result->data.F32[kk] = old_cv_nao[0] ?
					    w0*old_cv[0][i] + w1*old_cv[0][i+1]
					    : i + ii;
					w1 = jj[k];
					w0 = 1.0f - w1;
					result->data.F32[kk+1] = 
					    old_cv_nao[1] ?
					    w0*old_cv[1][j] + w1*old_cv[1][j+1]
					    : j + jj[k];
				    }
				}
			    }
			}
		    }
		}
	    }
	}
	break;
    default:
	assert(FALSE);
    }
    for (i = 0; i < rank; i++) {
	Nap_FreeNAO(nap_cd, old_cv_nao[i]);
	Nap_FreeNAO(nap_cd, main_nao[i]);
    }
    return result->id;
}

/*
 * Nap_nels --
 *
 * nap function "nels(x)"
 */

m4define(`m4NAME', `Nap_nels')

static char *
Nap_nels(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    Nap_NAO             *new;

    new = Nap_NewNAO(nap_cd, NAP_I32, 0, NULL);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    new->data.I32[0] = naoPtr->nels;
    return new->id;
}

/*
 * Nap_rank --
 *
 * nap function "rank(x)"
 */

m4define(`m4NAME', `Nap_rank')

static char *
Nap_rank(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    Nap_NAO             *new;

    new = Nap_NewNAO(nap_cd, NAP_I32, 0, NULL);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    new->data.I32[0] = naoPtr->rank;
    return new->id;
}

/*
 * Nap_label --
 *
 * nap function "label(x)"
 */

m4define(`m4NAME', `Nap_label')

static char *
Nap_label(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    Nap_NAO             *new;
    size_t              shape[1];

    shape[0] = naoPtr->label ? strlen(naoPtr->label) : 0;
    new = Nap_NewNAO(nap_cd, NAP_C8, 1, shape);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    if (naoPtr->label) {
	strncpy(new->data.c, naoPtr->label, shape[0]);
    }
    return new->id;
}

/*
 * Nap_box --
 *
 * nap function "box(x)"
 * Argument x is any NAO.
 * Result is scalar boxed NAO pointing to argument.
 */

m4define(`m4NAME', `Nap_box')

static char *
Nap_box(
    NapClientData	*nap_cd, 
    Nap_NAO             *args)
{
    Nap_NAO             *naoPtr;	/* argument */
    Nap_NAO             *result;	/* boxed NAO */

    CHECK2NULL(args->nels == 1, "m4NAME: Wrong # arguments");
    naoPtr = Nap_GetNaoFromSlot(args->data.Boxed[0]);
    CHECK2NULL(naoPtr, "m4NAME: error calling Nap_GetNaoFromSlot");
    result = Nap_NewNAO(nap_cd, NAP_BOXED, 0, NULL);
    CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
    result->data.Boxed[0] = naoPtr->slot;
    Nap_IncrRefCount(nap_cd, naoPtr);
    return result->id;
}

/*
 * Nap_open_box --
 *
 * nap function "open_box(x)" which is inverse of function "box(x)".
 * If argument x is single-element boxed NAO then result is NAO which argument points to.
 * Otherwise result is argument.
 */

m4define(`m4NAME', `Nap_open_box')

static char *
Nap_open_box(
    NapClientData	*nap_cd, 
    Nap_NAO             *args)
{
    Nap_NAO             *naoPtr;	/* argument */
    Nap_NAO             *result;	/* NAO which argument points to */

    CHECK2NULL(args->nels == 1, "m4NAME: Wrong # arguments");
    naoPtr = Nap_GetNaoFromSlot(args->data.Boxed[0]);
    CHECK2NULL(naoPtr, "m4NAME: error calling Nap_GetNaoFromSlot");
    if (naoPtr->dataType == NAP_BOXED  &&  naoPtr->nels == 1) {
	result = Nap_GetNaoFromSlot(naoPtr->data.Boxed[0]);
	CHECK2NULL(result, "m4NAME: error calling Nap_GetNaoFromSlot");
    } else {
	result = naoPtr;
    }
    return result->id;
}


/*
 * Nap_shape --
 *
 * nap function "shape(x)"
 */

m4define(`m4NAME', `Nap_shape')

static char *
Nap_shape(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    int			i;
    Nap_NAO             *new;
    size_t              shape[1];

    shape[0] = naoPtr->rank;
    new = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    for (i = 0; i < naoPtr->rank; i++) {
        new->data.I32[i] = naoPtr->shape[i];
    }
    return new->id;
}

/*
 * Nap_missing_value --
 *
 * nap function "missing_value(x)"
 */

m4define(`m4NAME', `Nap_missing_value')

static char *
Nap_missing_value(
    NapClientData	*nap_cd, 
    Nap_NAO             *naoPtr)
{
    Nap_dataType        dataType;
    Nap_NAO             *new;

    assert(naoPtr);
    if (naoPtr->missingValueSlot) {
	switch (naoPtr->dataType) {
	case NAP_C8:
	case NAP_I8:
	case NAP_U8:
	    dataType = NAP_I16;
	    break;
	case NAP_I16:
	case NAP_U16:
	    dataType = NAP_I32;
	    break;
	case NAP_I32:
	case NAP_U32:
	    dataType = NAP_F64;
	    break;
	default:
	    dataType = naoPtr->dataType;
	}
	new = Nap_NewScalarNAO(nap_cd, dataType, Nap_GetF64MissingValue(nap_cd, naoPtr->slot));
	return new->id;
    } else {
	return NULL;
    }
}

/*
 * Nap_Tally --
 *
 * Unary operator "#"
 */

m4begin

#	m4tallyMax(type)
m4define(`m4tallyMax', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < naoPtr->nels; i++) {
		if (! IsMissing(naoPtr, i)) {
		    if (naoPtr->data.$1[i] > dataMax) {
			dataMax = naoPtr->data.$1[i];
		    }
		}
	    }
	    break;')

#	m4tallySigned(type)
m4define(`m4tallySigned', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < naoPtr->nels; i++) {
		if (! IsMissing(naoPtr, i)   &&  naoPtr->data.$1[i] >= 0) {
		    j = i + c * (naoPtr->data.$1[i] - i/c);
		    ++(naoResult->data.I32[j]);
		}
	    }
	    break;')

#	m4tallyUnsigned(type)
m4define(`m4tallyUnsigned', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < naoPtr->nels; i++) {
		if (! IsMissing(naoPtr, i)) {
		    j = i + c * (naoPtr->data.$1[i] - i/c);
		    ++(naoResult->data.I32[j]);
		}
	    }
	    break;')

m4define(`m4NAME', `Nap_Tally')

m4end

EXTERN char *
Nap_Tally(
    NapClientData	*nap_cd, 
    char		*str)
{
    int			c;			/* Product of all dims except 1st */
    int			dataMax;		/* max. value in input */
    int			i;			/* subscript */
    int			j;			/* subscript */
    Nap_NAO		*naoPtr;
    Nap_NAO		*naoResult;
    Nap_NAO		*naoTmp;
    size_t		shape[NAP_MAX_RANK];	/* shape of result */
    int			status;

    assert(str);
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsReal(naoPtr)) {
	naoTmp = naoPtr;
	naoPtr = Nap_CastNAO(nap_cd, naoTmp, NAP_I32);
	CHECK2NULL(naoPtr, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, naoPtr);
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    dataMax = 0;
    switch (naoPtr->dataType) {
    m4ForAllIntegerDataType(`m4tallyMax(', `)')
    default:            /* error */
	assert(FALSE);
    }
    shape[0] = dataMax + 1;
    c = 1;
    for (i = 1; i < naoPtr->rank; i++) {
	shape[i] = naoPtr->shape[i];
	c *= naoPtr->shape[i];
    }
    naoResult = Nap_NewNAO(nap_cd, NAP_I32, naoPtr->rank, shape);
    CHECK2NULL(naoResult, "m4NAME: Error calling Nap_NewNAO");
    for (j = 0; j < naoResult->nels; j++) {
	naoResult->data.I32[j] = 0;
    }
    if (Nap_IsSignedInteger(naoPtr)) {
	switch (naoPtr->dataType) {
	m4ForAllSignedIntegerDataType(`m4tallySigned(', `)')
	default:            /* error */
	    assert(FALSE);
	}
    } else {
	switch (naoPtr->dataType) {
	m4ForAllUnsignedIntegerDataType(`m4tallyUnsigned(', `)')
	default:            /* error */
	    assert(FALSE);
	}
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return naoResult ? naoResult->id : NULL;
}

/*
 * Nap_Not --
 *
 * Operator "!"
 */

m4begin

#       m4not(old_data_type)  e.g. m4not(F32)
m4define(`m4not', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		new->data.U8[i] = ! naoPtr->data.$1[i];
	    }
	    break;')

m4define(`m4NAME', `Nap_Not')

m4end

EXTERN char *
Nap_Not(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    assert(str);
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    new = Nap_NewNAO(nap_cd, NAP_U8, naoPtr->rank, naoPtr->shape);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    status = Nap_CopyDims(nap_cd, naoPtr, new);
    CHECK1NULL(status == TCL_OK);
    switch (naoPtr->dataType) {
    m4ForAllNumericDataType(`m4not(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}

/*
 * Nap_Complement --
 *
 * Operator "~"
 */

m4begin

#       m4complement(data_type)  e.g. m4complement(U16)
m4define(`m4complement', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		new->data.$1[i] = ~ new->data.$1[i];
	    }
	    break;')

m4define(`m4NAME', `Nap_Complement')

m4end

EXTERN char *
Nap_Complement(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    assert(str);
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    CHECK2NULL(Nap_IsInteger(naoPtr), "m4NAME: Non-integer operand to '~'");
    new = Nap_CopyNAO(nap_cd, naoPtr);
    CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
    status = Nap_SetMissing(nap_cd, new, 0);
    CHECK1NULL(status == TCL_OK);
    switch (new->dataType) {
    m4ForAllIntegerDataType(`m4complement(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}

/*
 * Nap_Negate --
 *
 * Operator "-"
 */

m4begin

#       m4negate(data_type)  e.g. m4negate(I16)
m4define(`m4negate', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		new->data.$1[i] = - new->data.$1[i];
	    }
	    break;')

m4define(`m4NAME', `Nap_Negate')

m4end

EXTERN char *
Nap_Negate(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    new = Nap_CopyNAO(nap_cd, naoPtr);
    CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
    switch (new->dataType) {
    m4ForAllSignedDataType(`m4negate(', `)')
    default:            /* error */
	CHECK2NULL(FALSE, "m4NAME: Unsigned data-type");
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}


/*
 * Nap_Identity --
 *
 * Operator "+"  i.e. Identity function (copy of argument, not argument itself)
 */

m4define(`m4NAME', `Nap_Identity')

EXTERN char *
Nap_Identity(
    NapClientData	*nap_cd, 
    char		*str)
{
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;

    CHECK2NULL(str, "m4NAME: NULL argument");
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    new = Nap_CopyNAO(nap_cd, naoPtr);
    CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new->id;
}

/*
 * Nap_Indirect --
 *
 * Monadic "@", "@@", "@@@"
 */

m4define(`m4NAME', `Nap_Indirect')

EXTERN char *
Nap_Indirect(
    NapClientData	*nap_cd, 
    int			n,			/* 1 = "@", 2 = "@@", 3 = "@@@" */
    char		*str)			/* argument */
{   
    Nap_NAO		*linkNao;
    Nap_NAO		*naoPtr;
    Nap_NAO		*result;
    int			status;

    CHECK2NULL(str, "m4NAME: NULL argument");
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    result = Nap_CopyNAO(nap_cd, naoPtr);
    CHECK2NULL(result, "m4NAME: Error calling Nap_CopyNAO");
    linkNao = Nap_NewScalarNAO(nap_cd, NAP_I8, n);
    CHECK2NULL(linkNao, "m4NAME: Error calling Nap_NewScalarNAO");
    status = Nap_AttachLink(nap_cd, result, linkNao);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
    Nap_DecrRefCount(nap_cd, naoPtr);
    return result->id;
}

/*
 * Nap_Func1 --
 *
 * Functions with 1 argument
 */

m4begin

#       m4monad1(data_type)  e.g. m4monad1(U8)
m4define(`m4monad1', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		if (!IsMissing(naoPtr, i)) {
		    new->data.$1[i] = m4defn(new->data.$1[i]);
		}
	    }
	    break;')

#       m4monadSigned(defn)
#       e.g.  m4monadSigned(`Abs($1)')
m4define(`m4monadSigned', `
    m4define(`m4defn', `$1')
	new = Nap_CopyNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
        switch (new->dataType) {
	m4ForAllSignedDataType(`m4monad1(', `)')
	default:            /* error */
	    assert(FALSE);
	}
	')

#       m4monadUnsigned(defn)
m4define(`m4monadUnsigned', `
    m4define(`m4defn', `$1')
	new = Nap_CopyNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
        switch (new->dataType) {
	m4ForAllUnsignedIntegerDataType(`m4monad1(', `)')
	default:            /* error */
	    assert(FALSE);
	}
	')

#       m4monad(defn)
#       e.g. m4monad(`-($1)')
m4define(`m4monad', `
    m4define(`m4defn', `$1')
	new = Nap_CopyNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
        switch (new->dataType) {
	m4ForAllNumericDataType(`m4monad1(', `)')
	default:            /* error */
	    assert(FALSE);
	}
	')

#       m4func1(data_type)
m4define(`m4func1', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		if (!IsMissing(naoPtr, i)) {
		    new->data.$1[i] = m4defn`'((double) new->data.$1[i]);
		}
	    }
	    break;')

#       m4func(name)  e.g. m4func(sin)
m4define(`m4func', `
    m4define(`m4defn', `$1')
    } else if (strcmp(name, "$1") == 0) {
	if (Nap_IsReal(naoPtr)) {
	    new = Nap_CopyNAO(nap_cd, naoPtr);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
	} else {
	    new = Nap_CastNAO(nap_cd, naoPtr, NAP_F64);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_CastNAO");
	}
        switch (new->dataType) {
	m4ForAllRealDataType(`m4func1(', `)')
        default:            /* error */
            assert(FALSE);
        }
	')
	}')

#       m4cast(new_data_type)  e.g. m4cast(F32)
m4define(`m4cast', `
    if (strcmp(name, "m4LowerCase(`$1')") == 0) {
        dataType = m4DataTypeEnum($1);
	if (dataType == naoPtr->dataType) {
	    new = Nap_CopyNAO(nap_cd, naoPtr);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
	} else {
	    new = Nap_CastNAO(nap_cd, naoPtr, dataType);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_CastNAO");
        }
    }')

#       m4random(old_data_type)  e.g. m4random(I32)
m4define(`m4random', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		if (!IsMissing(naoPtr, i)) {
		    new->data.F32[i] = Random_float((float) naoPtr->data.$1[i]);
		}
	    }
	    break;')

m4define(`m4NAME', `Nap_Func1')

m4end

static char *
Nap_Func1(
    NapClientData	*nap_cd, 
    char		*name,
    char		*str)
{
    Nap_dataType        dataType;
    size_t		i;
    char		*id;
    Nap_NAO		*new = NULL;
    Nap_NAO		*naoPtr;
    int			status;

    assert(str);
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsUnsignedInteger(naoPtr)  &&  !strcmp(name, "abs")
	    ||  Nap_IsInteger(naoPtr)  &&  (!strcmp(name, "nint") || !strcmp(name, "round")
	    || !strcmp(name, "ceil") || !strcmp(name, "floor"))) {
	new = Nap_CopyNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
    } else if (!strcmp(name, "abs")) {
	m4monadSigned(`Abs($1)')
    } else if (!strcmp(name, "sign")) {
	if (Nap_IsUnsignedInteger(naoPtr)) {
	    m4monadUnsigned(`$1 > 0')
	} else {
	    m4monadSigned(`Sign($1)')
	}
    } else if (!strcmp(name, "nint")  ||  !strcmp(name, "round")) {
	m4monad(`Nint($1)')
    } else if (!strcmp(name, "random")) {
	if (naoPtr->dataType == NAP_F64) {
	    new = Nap_CopyNAO(nap_cd, naoPtr);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_CopyNAO");
	    for (i = 0; i < new->nels; i++) {
		new->data.F64[i] = Random_double(naoPtr->data.F64[i]);
	    }
	} else {
	    new = Nap_NewNAO(nap_cd, NAP_F32, naoPtr->rank, naoPtr->shape);
	    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
	    status = Nap_CopyDims(nap_cd, naoPtr, new);
	    CHECK1NULL(status == TCL_OK);
	    switch (naoPtr->dataType) {
	    m4ForAllNumericDataType(`m4random(', `)')
	    default:            /* error */
		assert(FALSE);
	    }
	}
    } else if (strcmp(name, "isnan") == 0) {
	new = Nap_NewNAO(nap_cd, NAP_U8, naoPtr->rank, naoPtr->shape);
	CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
	switch (naoPtr->dataType) {
	case NAP_F32:
	    for (i = 0; i < new->nels; i++) {
		new->data.U8[i] = IsNaN32(naoPtr->data.F32[i]);
	    }
	    break;
	case NAP_F64:
	    for (i = 0; i < new->nels; i++) {
		new->data.U8[i] = IsNaN64(naoPtr->data.F64[i]);
	    }
	    break;
	default:
	    for (i = 0; i < new->nels; i++) {
		new->data.U8[i] = FALSE;
	    }
	}
    } else if (strcmp(name, "psum") == 0) {
	id = Nap_psum(nap_cd, naoPtr);
	new = Nap_GetNaoFromId(nap_cd, id);
    } else if (strcmp(name, "sort") == 0) {
	id = Nap_sort(nap_cd, naoPtr);
	new = Nap_GetNaoFromId(nap_cd, id);
    m4func(ceil)
    m4func(floor)
    m4func(acos)
    m4func(asin)
    m4func(atan)
    m4func(cos)
    m4func(cosh)
    m4func(exp)
    m4func(log)
    m4func(log10)
    m4func(sin)
    m4func(sinh)
    m4func(sqrt)
    m4func(tan)
    }
    m4ForAllUnboxedDataType(`m4cast(', `)')
    if (!new) {
	new = Nap_Reduce(nap_cd, name, naoPtr, NULL);
    }
    if (!new) {
	id = Nap_Func2(nap_cd, name, naoPtr->id, NULL);
	new = Nap_GetNaoFromId(nap_cd, id);
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}

/*
 * CommandIsDefined --
 *
 * Return 1 if specified command exists or can be defined via auto_index.
 * If latter then execute this auto_index script.
 */

m4define(`m4NAME', `CommandIsDefined')

static int
CommandIsDefined(
    NapClientData	*nap_cd, 
    Tcl_Obj		*commandNameObj)	/* command-name */
{   
    static Tcl_Obj	*auto_indexObj = NULL;
    Tcl_CmdInfo		info;
    Tcl_Obj		*resultObj;
    int			status;
    char		*str;

    if (!auto_indexObj) {
	auto_indexObj = Tcl_NewStringObj("::auto_index", -1);
	assert(auto_indexObj);
	Tcl_IncrRefCount(auto_indexObj);
    }
    str = Tcl_GetStringFromObj(commandNameObj, NULL);
    status = Tcl_GetCommandInfo(nap_cd->interp, str, &info);
    if (!status) {
	resultObj = Tcl_ObjGetVar2(nap_cd->interp, auto_indexObj, commandNameObj, 0);
	if (resultObj) {
	    Tcl_IncrRefCount(resultObj);
	    status = Tcl_EvalObj(nap_cd->interp, resultObj);
	    Tcl_DecrRefCount(resultObj);
	    status = Tcl_GetCommandInfo(nap_cd->interp, str, &info);
	}
    }
    return status;
}

/*
 * Nap_FuncProc --
 *
 * Use tcl procedure to define result of nap function
 * If no such procedure defined then set pointer 'result' to NULL & return TCL_OK.
 *
 * Note that Nap_TraceUnsets does not delete NAOs pointed to by variables unset during 
 * execution of this tcl procedure.  Instead it adds NAO to "death list" whose head is list_nao.
 * This ensures that the result (which could be one of these) is still defined.
 * The ref. count of the result is incremented before deleting these NAOs here.
 */

m4define(`m4NAME', `Nap_FuncProc')

static int
Nap_FuncProc(
    NapClientData	*nap_cd, 
    char                *prefix,	/* "" or "::NAP::" */
    char                *funcName,	/* function-name */
    Nap_NAO		*boxed,		/* boxed NAO pointing to function args */
    char		**result)	/* NAO ID (NULL if no proc found) (out) */
{   
    int			i;
    Nap_NAO		*list_nao;	/* list of NAOs whose deletion has been delayed */
    Nap_NAO		*naoPtr;
    Nap_NAO		*resultNao = NULL;
    Tcl_Obj		*resultObj;
    int			old_slotList;
    Tcl_Obj		*scriptObj;
    size_t              slot;
    int			status;

    *result = NULL;
    scriptObj = Tcl_NewStringObj(prefix, -1);
    assert(scriptObj);
    Tcl_IncrRefCount(scriptObj);
    Tcl_AppendToObj(scriptObj, funcName, -1);
    if (CommandIsDefined(nap_cd, scriptObj)) {
	for (i = 0; i < boxed->shape[0]; i++) {
	    slot = boxed->data.Boxed[i];
	    CHECK3(slot > 0, "m4NAME: NULL argument for function \"%s()\"", funcName);
	    naoPtr = Nap_GetNaoFromSlot(slot);
	    Tcl_AppendStringsToObj(scriptObj, " ", naoPtr->id, NULL);
	}
	list_nao = Nap_NewNAO(nap_cd, NAP_I32, 0, NULL);
	CHECK2(list_nao, "m4NAME: Error calling Nap_NewNAO");
	old_slotList = nap_cd->slotList;
	nap_cd->slotList = list_nao->data.U32[0] = list_nao->slot;
	status = Tcl_EvalObj(nap_cd->interp, scriptObj);
	if (status != TCL_OK) {
	    CHECK5(0, "%s\n" "m4NAME: Error executing procedure \"%s%s\"",
		    Tcl_GetStringResult(nap_cd->interp), prefix, funcName);
	}
	resultObj = Tcl_GetObjResult(nap_cd->interp);
	assert(resultObj);
	Tcl_IncrRefCount(resultObj);
	resultNao = Nap_GetNaoFromObj(nap_cd, resultObj);
	CHECK2(resultNao, "m4NAME: Error calling Nap_GetNaoFromObj");
	Nap_IncrRefCount(nap_cd, resultNao);
	*result = resultNao->id;
	while (list_nao) {
	    naoPtr = list_nao;
	    list_nao = Nap_GetNaoFromSlot(list_nao->nextSlot);
	    naoPtr->nextSlot = 0;
	    Nap_DecrRefCount(nap_cd, naoPtr);
	}
	nap_cd->slotList = old_slotList;
	if (resultNao) {
	    --resultNao->count;
	}
	Tcl_DecrRefCount(resultObj);
    }
    Tcl_DecrRefCount(scriptObj);
    return TCL_OK;
}

/*
 * Nap_StdFuncs --
 *
 * Standard (built-in) nap functions.
 */

m4define(`m4NAME', `Nap_StdFuncs')

static char *
Nap_StdFuncs(
    NapClientData	*nap_cd, 
    char                *funcName,    /* function-name */
    Nap_NAO		*boxed)	      /* boxed NAO pointing to function args */
{   
    char		*result = NULL;	/* NAO ID to be returned */

    if (strcmp(funcName, "box") == 0) {
	result = Nap_box(nap_cd, boxed);
    } else if (strcmp(funcName, "correlation") == 0) {
	result = Nap_Correlation(nap_cd, boxed);
    } else if (strcmp(funcName, "dilate") == 0) {
	result = Nap_dilate(nap_cd, boxed);
    } else if (strcmp(funcName, "erode") == 0) {
	result = Nap_erode(nap_cd, boxed);
    } else if (strcmp(funcName, "invert_grid") == 0) {
	result = Nap_invert_grid(nap_cd, boxed->id);
    } else if (strcmp(funcName, "label") == 0) {
	result = Nap_label(nap_cd, Nap_GetNaoFromSlot(boxed->data.Boxed[0]));
    } else if (strcmp(funcName, "missing_value") == 0) {
	result = Nap_missing_value(nap_cd, Nap_GetNaoFromSlot(boxed->data.Boxed[0]));
    } else if (strcmp(funcName, "moving_range") == 0) {
	result = Nap_moving_range(nap_cd, boxed);
    } else if (strcmp(funcName, "nels") == 0) {
	result = Nap_nels(nap_cd, Nap_GetNaoFromSlot(boxed->data.Boxed[0]));
    } else if (strcmp(funcName, "open_box") == 0) {
	result = Nap_open_box(nap_cd, boxed);
    } else if (strcmp(funcName, "pad") == 0) {
	result = Nap_pad(nap_cd, boxed);
    } else if (strcmp(funcName, "prune") == 0) {
	result = Nap_prune(nap_cd, boxed);
    } else if (strcmp(funcName, "rank") == 0) {
	result = Nap_rank(nap_cd, Nap_GetNaoFromSlot(boxed->data.Boxed[0]));
    } else if (strcmp(funcName, "shape") == 0) {
	result = Nap_shape(nap_cd, Nap_GetNaoFromSlot(boxed->data.Boxed[0]));
    } else {
	switch (boxed->shape[0]) {
	    case 1:
		if (boxed->data.Boxed[0]) {
		    result = Nap_Func1(nap_cd, funcName,
			    Nap_GetNaoFromSlot(boxed->data.Boxed[0])->id);
		}
		break;
	    case 2:
		if (boxed->data.Boxed[0]  &&  boxed->data.Boxed[1]) {
		    result = Nap_Func2(nap_cd, funcName,
			    Nap_GetNaoFromSlot(boxed->data.Boxed[0])->id,
			    Nap_GetNaoFromSlot(boxed->data.Boxed[1])->id);
		}
		break;
	}
    }
    return result;
}

/*
 * Nap_Func --
 *
 * Either subscripting or call nap function.
 */

m4define(`m4NAME', `Nap_Func')

EXTERN char *
Nap_Func(
    NapClientData	*nap_cd, 
    char		*str1,		/* function-name or var-name/nao-ID */
    char		*str2)		/* name/nao-ID of subscript/argument */
{
    Nap_NAO		*boxed;
    int			i;
    const int           maxLevel = 8;   /* max. # levels of indirection */
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    char		*result = NULL;	/* NAO ID to be returned */
    size_t		shape[] = {1};
    int			status;
    char		*str1new;
    Nap_NAO		*tmp_NAO;

    naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
    if (naoPtr2) {
	if (naoPtr2->dataType == NAP_BOXED  &&  naoPtr2->rank > 0) {
	    CHECK2NULL(naoPtr2->rank == 1, "m4NAME: Boxed argument has rank > 1");
	    boxed = naoPtr2;
	} else {
	    boxed = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
	    CHECK2NULL(boxed, "m4NAME: Error calling Nap_NewNAO");
	    boxed->data.Boxed[0] = naoPtr2->slot;
	    Nap_IncrRefCount(nap_cd, naoPtr2);
	}
	Nap_IncrRefCount(nap_cd, boxed);
    } else {
	boxed = NULL;
    }
    CHECK2NULL(str1, "m4NAME: Left argument is NULL");
    str1new = Nap_StrDup(str1);
    i = 0;
    while (str1new) {
	CHECK3NULL(++i < maxLevel, "m4NAME: More than %d levels of indirection", maxLevel);
	str1 = Tcl_GetVar(nap_cd->interp, str1new, 0);
	if (str1) {
	    FREE(str1new);
	    str1new = Nap_StrDup(str1);
	} else {
	    str1 = str1new;
	    str1new = NULL;
	}
    }
    assert(str1);
    if (strlen(str1) > 0  &&  Nap_lexID(str1) == strlen(str1)) {
	naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
	CHECK3NULL(naoPtr1, "m4NAME: Left argument is unknown NAO ID %s", str1);
	if (boxed) {
	    Nap_IncrRefCount(nap_cd, naoPtr1);
	    result = Nap_Subscript(nap_cd, naoPtr1->id, boxed->id);
	    Nap_DecrRefCount(nap_cd, naoPtr1);
	} else {
	    result = naoPtr1->id;
	}
	CHECK3NULL(result, "m4NAME: Undefined result for sub-array %s()", str1);
	assert(naoPtr1);
    } else {
	CHECK3NULL(str2, "m4NAME: Function \"%s()\" called with no arguments", str1);
	CHECK2NULL(naoPtr2, "m4NAME: Error calling Nap_GetNaoFromId");
	assert(boxed);
	assert(boxed->rank == 1);
	status = Nap_FuncProc(nap_cd, NAP_NAMESPACE, str1, boxed, &result);
	CHECK1NULL(status == TCL_OK);
	if (!result) {
	    result = Nap_StdFuncs(nap_cd, str1, boxed);
	    if (!result) {
		status = Nap_FuncProc(nap_cd, "", str1, boxed, &result);
		CHECK1NULL(status == TCL_OK);
		if (!result) {
		    Nap_DecrRefCount(nap_cd, boxed);
		    CHECK3NULL(FALSE, "m4NAME: Undefined function %s()", str1);
		}
	    }
	}
    }
    FREE(str1);
    tmp_NAO = Nap_GetNaoFromId(nap_cd, result);
    CHECK2NULL(tmp_NAO, "m4NAME: Error calling Nap_GetNaoFromId");
    Nap_IncrRefCount(nap_cd, tmp_NAO);
    if (boxed) {
	Nap_DecrRefCount(nap_cd, boxed);
    }
    --tmp_NAO->count;
    Tcl_SetResult(nap_cd->interp, result, TCL_VOLATILE);
    return result;
}
