m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (napMonad.c) */
/* It was produced from source file napMonad.c,m4 */

/* 
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napMonad.c,m4,v 1.212 2007/11/01 09:04:06 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"
#include "napParse.tab.h"

/*
 * Nap_Tally --
 *
 * Unary operator "#"
 */

m4begin

#	m4boxTallyMax(type)
m4define(`m4boxTallyMax', `
	case m4DataTypeEnum($1):
	    for (j = 0; j < n; j++) {
		if (! IsMissing(naoArray[ia], j)) {
		    if (naoArray[ia]->data.$1[j] > dataMax) {
			dataMax = naoArray[ia]->data.$1[j];
		    }
		}
	    }
	    break;')

#	m4boxTally(type)
m4define(`m4boxTally', `
	case m4DataTypeEnum($1):
	    if (IsMissing(naoArray[ia], j)) {
		k = -1;
	    } else {
		k = naoArray[ia]->data.$1[j];
	    }
	    break;')

#	m4tallyMax(type)
m4define(`m4tallyMax', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < naoPtr->nels; i++) {
		if (! IsMissing(naoPtr, i)) {
		    if (naoPtr->data.$1[i] > dataMax) {
			dataMax = naoPtr->data.$1[i];
		    }
		}
	    }
	    break;')

#	m4tallySigned(type)
m4define(`m4tallySigned', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < naoPtr->nels; i++) {
		if (! IsMissing(naoPtr, i)   &&  naoPtr->data.$1[i] >= 0) {
		    j = i + c * (naoPtr->data.$1[i] - i/c);
		    ++(naoResult->data.I32[j]);
		}
	    }
	    break;')

#	m4tallyUnsigned(type)
m4define(`m4tallyUnsigned', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < naoPtr->nels; i++) {
		if (! IsMissing(naoPtr, i)) {
		    j = i + c * (naoPtr->data.$1[i] - i/c);
		    ++(naoResult->data.I32[j]);
		}
	    }
	    break;')

m4define(`m4NAME', `Nap_Tally')

m4end

EXTERN char *
Nap_Tally(
    NapClientData	*nap_cd, 
    char		*str)
{
    int			c;			/* Product of all dims except 1st */
    int			dataMax;		/* max. value in input */
    int			i;			/* subscript */
    int			ia;			/* subscript of array = 0 .. na-1 */
    int			j;			/* subscript */
    int			k;			/* subscript */
    int			m;			/* subscript */
    int			n;			/* # elements in each array */
    int			na;			/* # arrays */
    Nap_NAO		*naoArray[NAP_MAX_RANK]; /* pointers to arrays */
    Nap_NAO		*naoPtr;
    Nap_NAO		*naoResult;
    Nap_NAO		*naoTmp;
    int			p[NAP_MAX_RANK];	/* partial products of shape */
    size_t		shape[NAP_MAX_RANK];	/* shape of result */

    CHECK2NULL(str, "m4NAME: Operand of unary # is NULL");
    assert(str);
    naoPtr = Nap_GetNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Error calling Nap_GetNaoFromId");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsBoxed(naoPtr)) {
	n = ia = -1;
	for (i = 0; i < naoPtr->nels; i++) {
	    naoTmp = Nap_GetNaoFromSlot(naoPtr->data.Boxed[i]);
	    if (naoTmp) {
		CHECK2NULL(ia < NAP_MAX_RANK, "m4NAME: Too many arrays");
		++ia;
		Nap_IncrRefCount(nap_cd, naoTmp);
		if (n < 0) {
		    n = naoTmp->nels;
		}
		CHECK3NULL(naoTmp->nels == n,
			"m4NAME: Array %d has different number of elements from array 0", ia);
		if (Nap_IsReal(naoTmp)) {
		    naoArray[ia] = Nap_CastNAO(nap_cd, naoTmp, NAP_I32);
		    CHECK2NULL(naoArray[ia], "m4NAME: Error calling Nap_CastNAO");
		    Nap_IncrRefCount(nap_cd, naoArray[ia]);
		    Nap_DecrRefCount(nap_cd, naoTmp);
		} else {
		    naoArray[ia] = naoTmp;
		}
		dataMax = -1;
		switch (naoArray[ia]->dataType) {
		m4ForAllIntegerDataType(`m4boxTallyMax(', `)')
		default:            /* error */
		    assert(FALSE);
		}
		shape[ia] = dataMax + 1;
	    }
	}
	na = ia + 1;
	CHECK2NULL(na > 0, "m4NAME: No arrays");
	p[ia] = 1;
	while (ia > 0) {
	    p[ia-1] = p[ia] * shape[ia];
	    ia--;
	}
	naoResult = Nap_NewNAO(nap_cd, NAP_I32, na, shape);
	CHECK2NULL(naoResult, "m4NAME: Error calling Nap_NewNAO");
	for (j = 0; j < naoResult->nels; j++) {
	    naoResult->data.I32[j] = 0;
	}
	for (j = 0; j < n; j++) {
	    m = 0;
	    for (ia = 0; ia < na; ia++) {
		switch (naoArray[ia]->dataType) {
		m4ForAllIntegerDataType(`m4boxTally(', `)')
		default:            /* error */
		    assert(FALSE);
		}
		if (k < 0) {
		    m = -1;
		    break;
		} else {
		    m += p[ia] * k;
		}
	    }
	    if (m >= 0) {
		++ naoResult->data.I32[m];
	    }
	}
	for (ia = 0; ia < na; ia++) {
	    Nap_DecrRefCount(nap_cd, naoArray[ia]);
	}
    } else {
	if (Nap_IsReal(naoPtr)) {
	    naoTmp = naoPtr;
	    naoPtr = Nap_CastNAO(nap_cd, naoTmp, NAP_I32);
	    CHECK2NULL(naoPtr, "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, naoPtr);
	    Nap_DecrRefCount(nap_cd, naoTmp);
	}
	dataMax = 0;
	switch (naoPtr->dataType) {
	m4ForAllIntegerDataType(`m4tallyMax(', `)')
	default:            /* error */
	    CHECK2NULL(0, "m4NAME: Illegal data-type");
	}
	shape[0] = dataMax + 1;
	c = 1;
	for (i = 1; i < naoPtr->rank; i++) {
	    shape[i] = naoPtr->shape[i];
	    c *= naoPtr->shape[i];
	}
	naoResult = Nap_NewNAO(nap_cd, NAP_I32, naoPtr->rank, shape);
	CHECK2NULL(naoResult, "m4NAME: Error calling Nap_NewNAO");
	for (j = 0; j < naoResult->nels; j++) {
	    naoResult->data.I32[j] = 0;
	}
	if (Nap_IsSignedInteger(naoPtr)) {
	    switch (naoPtr->dataType) {
	    m4ForAllSignedIntegerDataType(`m4tallySigned(', `)')
	    default:            /* error */
		assert(FALSE);
	    }
	} else {
	    switch (naoPtr->dataType) {
	    m4ForAllUnsignedIntegerDataType(`m4tallyUnsigned(', `)')
	    default:            /* error */
		assert(FALSE);
	    }
	}
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return naoResult ? naoResult->id : NULL;
}

/*
 * Nap_Not --
 *
 * Operator "!"
 */

m4begin

#       m4not(old_data_type)  e.g. m4not(F32)
m4define(`m4not', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		new->data.U8[i] = ! naoPtr->data.$1[i];
	    }
	    break;')

m4define(`m4NAME', `Nap_Not')

m4end

EXTERN char *
Nap_Not(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    new = Nap_NewNAO(nap_cd, NAP_U8, naoPtr->rank, naoPtr->shape);
    CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
    status = Nap_CopyDims(nap_cd, naoPtr, new);
    CHECK1NULL(status == TCL_OK);
    switch (naoPtr->dataType) {
    m4ForAllNumericDataType(`m4not(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}

/*
 * Nap_Complement --
 *
 * Operator "~"
 */

m4begin

#       m4complement(data_type)  e.g. m4complement(U16)
m4define(`m4complement', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		new->data.$1[i] = ~ new->data.$1[i];
	    }
	    break;')

m4define(`m4NAME', `Nap_Complement')

m4end

EXTERN char *
Nap_Complement(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    assert(str);
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    CHECK2NULL(Nap_IsInteger(naoPtr), "m4NAME: Non-integer operand to '~'");
    new = Nap_DupNAO(nap_cd, naoPtr);
    CHECK2NULL(new, "m4NAME: Error calling Nap_DupNAO");
    status = Nap_SetMissing(nap_cd, new, 0);
    CHECK1NULL(status == TCL_OK);
    switch (new->dataType) {
    m4ForAllIntegerDataType(`m4complement(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}

/*
 * Nap_Negate --
 *
 * Operator "-"
 */

m4begin

#       m4negate(data_type)  e.g. m4negate(I16)
m4define(`m4negate', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		new->data.$1[i] = - new->data.$1[i];
	    }
	    break;')

m4define(`m4NAME', `Nap_Negate')

m4end

EXTERN char *
Nap_Negate(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    new = Nap_DupNAO(nap_cd, naoPtr);
    CHECK2NULL(new, "m4NAME: Error calling Nap_DupNAO");
    switch (new->dataType) {
    m4ForAllSignedDataType(`m4negate(', `)')
    default:            /* error */
	CHECK2NULL(FALSE, "m4NAME: Unsigned data-type");
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}


/*
 * Nap_Identity --
 *
 * Operator "+"  i.e. Identity function (copy of argument, not argument itself)
 * New version copies missing value
 */

m4define(`m4NAME', `Nap_Identity')

EXTERN char *
Nap_Identity(
    NapClientData	*nap_cd, 
    char		*str)
{
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;

    CHECK2NULL(str, "m4NAME: NULL argument");
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    new = Nap_DupAllNAO(nap_cd, naoPtr);
    CHECK2NULL(new, "m4NAME: Error calling Nap_DupAllNAO");
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new->id;
}


/*
 * Nap_Round --
 *
 * Unary operator "^"
 */

m4begin

#       m4Round(data_type)  e.g. m4Round(F32)
m4define(`m4Round', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		new->data.I32[i] = Nint(naoPtr->data.$1[i]);
	    }
	    break;')

m4define(`m4NAME', `Nap_Round')

m4end

EXTERN char *
Nap_Round(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsReal(naoPtr)) {
	new = Nap_NewNAO(nap_cd, NAP_I32, naoPtr->rank, naoPtr->shape);
	CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, naoPtr, new);
	CHECK1NULL(status == TCL_OK);
	switch (naoPtr->dataType) {
	m4ForAllRealDataType(`m4Round(', `)')
	default:            /* error */
	    assert(FALSE);
	}
    } else {
	new = Nap_DupNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_DupNAO");
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}



/*
 * Nap_Floor --
 *
 * Unary operator "^"
 */

m4begin

#       m4Floor(data_type)  e.g. m4Floor(F32)
m4define(`m4Floor', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		new->data.I32[i] = floor(naoPtr->data.$1[i]);
	    }
	    break;')

m4define(`m4NAME', `Nap_Floor')

m4end

EXTERN char *
Nap_Floor(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsReal(naoPtr)) {
	new = Nap_NewNAO(nap_cd, NAP_I32, naoPtr->rank, naoPtr->shape);
	CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, naoPtr, new);
	CHECK1NULL(status == TCL_OK);
	switch (naoPtr->dataType) {
	m4ForAllRealDataType(`m4Floor(', `)')
	default:            /* error */
	    assert(FALSE);
	}
    } else {
	new = Nap_DupNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_DupNAO");
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}



/*
 * Nap_Ceil --
 *
 * Unary operator "^"
 */

m4begin

#       m4Ceil(data_type)  e.g. m4Ceil(F32)
m4define(`m4Ceil', `
	case m4DataTypeEnum($1):
	    for (i = 0; i < new->nels; i++) {
		new->data.I32[i] = ceil(naoPtr->data.$1[i]);
	    }
	    break;')

m4define(`m4NAME', `Nap_Ceil')

m4end

EXTERN char *
Nap_Ceil(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsReal(naoPtr)) {
	new = Nap_NewNAO(nap_cd, NAP_I32, naoPtr->rank, naoPtr->shape);
	CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, naoPtr, new);
	CHECK1NULL(status == TCL_OK);
	switch (naoPtr->dataType) {
	m4ForAllRealDataType(`m4Ceil(', `)')
	default:            /* error */
	    assert(FALSE);
	}
    } else {
	new = Nap_DupNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "m4NAME: Error calling Nap_DupNAO");
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}


/*
 * Nap_Indirect --
 *
 * Monadic "@", "@@", "@@@"
 */

m4define(`m4NAME', `Nap_Indirect')

EXTERN char *
Nap_Indirect(
    NapClientData	*nap_cd, 
    int			op,
    char		*right)			/* argument */
{   
    int			base_rank;		/* rank of base array */
    Nap_NAO		*cv_nao;		/* coord var */
    char		*fmt_s = "m4NAME: Illegal coordinate variable corresponding to unary '%s'";
    int			i;			/* dimension number of base array */
    char		*id;			/* OOC name of result */
    Nap_NAO		*indexBaseCV;		/* boxed NAO of CVs */
    int			level;			/* parse level */
    Nap_NAO		*linkNao;
    int			n;			/* 1 = "@", 2 = "@@", 3 = "@@@" */
    Nap_NAO		*result;
    Nap_NAO		*right_nao;		/* argument */
    size_t		shape[1];		/* shape of linkNao */
    int			status;
    char		*symbol;		/* "@", "@@" or "@@@" */

    right_nao = Nap_GetNaoFromId(nap_cd, right);
    Nap_IncrRefCount(nap_cd, right_nao);
    switch (op) {
	case '@':	n = 1; symbol = "@"; break;
	case CLOSEST:	n = 2; symbol = "@@"; break;
	case MATCH:	n = 3; symbol = "@@@"; break;
	default:	assert(0);
    }
    level = nap_cd->parseLevel;
    assert(level >= 0);
    indexBaseCV = nap_cd->indexBaseCV[level];
    CHECK3NULL(indexBaseCV, fmt_s, symbol);
    CHECK3NULL(Nap_IsNAO(nap_cd, indexBaseCV), fmt_s, symbol);
    CHECK3NULL(Nap_IsBoxed(indexBaseCV), fmt_s, symbol);
    base_rank = indexBaseCV->nels;
    if (base_rank < 2  ||  right_nao->rank < 2) {
	i = nap_cd->indexDimNum[level];
	assert(i >= 0);
	assert(i < base_rank);
	cv_nao = Nap_GetNaoFromSlot(indexBaseCV->data.Boxed[i]);
	CHECK3NULL(cv_nao, fmt_s, symbol);
	CHECK3NULL(cv_nao->rank == 1, fmt_s, symbol);
	switch (op) {
	    case '@':		id = Nap_IndexOf2(nap_cd, cv_nao->id, right); break;
	    case CLOSEST:	id = Nap_Closest( nap_cd, cv_nao->id, right); break;
	    case MATCH:		id = Nap_Match(   nap_cd, cv_nao->id, right); break;
	    default:		assert(0);
	}
    } else {
	/*
	    Following (for rank > 1 i.e. indirect full indexing) is old method of
	    attaching link nao with n values
	 */
	result = Nap_CopyNAO(nap_cd, right_nao);
	CHECK2NULL(result, "m4NAME: Error calling Nap_CopyNAO");
	shape[0] = right_nao->rank;
	linkNao = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	CHECK2NULL(linkNao, "m4NAME: Error calling Nap_NewNAO");
	for (i = 0; i < linkNao->nels; ++i) {
	    linkNao->data.I32[i] = n;
	}
	status = Nap_AttachLink(nap_cd, result, linkNao);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_AttachLink");
	id = result->id;
    }
    CHECK3NULL(id, "m4NAME: Error in unary operator '%s'", symbol);
    Nap_DecrRefCount(nap_cd, right_nao);
    return id;
}

/*
 * Nap_Niladic --
 *
 * Operator with no argument.
 */

m4define(`m4NAME', `Nap_Niladic')

EXTERN char *
Nap_Niladic(
    NapClientData	*nap_cd, 
    int			op)		/* operator */
{
    Nap_NAO		*naoPtr;
    char		*result = NULL;	/* NAO ID to be returned */

    switch (op) {
	case ',':
	    result = Nap_Link(nap_cd, NULL, NULL);
	    CHECK2NULL(result, "m4NAME: Error calling Nap_Link");
	    break;
	case '-':
	    naoPtr = Nap_NewNAO(nap_cd, NAP_F32, 0, NULL);
	    CHECK2NULL(naoPtr, "m4NAME: Error calling Nap_NewNAO");
	    naoPtr->data.F32[0] = -napF32Inf;
	    result = naoPtr->id;
	    break;
	default:
	    CHECK3NULL(0, "m4NAME: Illegal niladic operator '%c'", op);
    }
    return result;
}
