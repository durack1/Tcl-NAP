m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (napLib.c) */
/* It was produced from source file napLib.c,m4 */

/* 
 *      napParseLib.c,m4 --
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napParseLib.c,m4,v 1.62 2006/09/29 12:38:29 dav480 Exp $";
#endif /* not lint */

#include <stdlib.h>

#include "nap.h"
#include "nap_check.h"
#include "napParse.tab.h"

/*
 * Prototypes
 */

static size_t Nap_HexInt(char *str);
static size_t Nap_Infinity(char *str);
static size_t Nap_NaN(char *str);


/*
 * Nap_NewPNode --
 *
 *	Create new Nap_PNode.
 */

m4define(`m4NAME', `Nap_NewPNode')

static Nap_PNode *
Nap_NewPNode(
    NapClientData       *nap_cd,
    Nap_PNclass         class)          /* node type: NAP_VALUE, NAP_LIST, etc. */
{
    int			level;			/* parse level */
    Nap_PNode		*node;

    CHECK2NULL(Nap_ValidPNclass(class), "m4NAME: bad class");
    node = (Nap_PNode *) NAP_ALLOC(nap_cd, sizeof(Nap_PNode));
    CHECK2NULL(node, "m4NAME: Error calling NAP_ALLOC");
    node->class = class;
    level = nap_cd->parseLevel;
    assert(level >= 0);
    assert(level < nap_cd->recursionLimit);
    node->scanPtr = nap_cd->token[level];
    node->str = NULL;
    node->op = NULL_OP;
    node->left = NULL;
    node->right = NULL;
    node->repCount = 0;
    node->list = NULL;
    node->next = NULL;
    node->tail = NULL;
    ++ nap_cd->numberPNodes;
    return node;
}

/*
 * FreePNode --
 *
 *	Free Nap_PNode.
 */

m4define(`m4NAME', `FreePNode')

void
FreePNode(
    NapClientData       *nap_cd,
    Nap_PNode		*node)
{
    assert(Nap_ValidPNclass(node->class));
    NAP_FREE(nap_cd, node);
    -- nap_cd->numberPNodes;
}

m4define(`m4NAME', `Nap_NewExprPNode')

Nap_PNode *
Nap_NewExprPNode(
    NapClientData	*nap_cd,
    Nap_PNode		*left,          /* left operand */
    int                 op,		/* operator */
    Nap_PNode		*right)		/* right operand */
{
    Nap_PNode           *node;

    node = Nap_NewPNode(nap_cd, NAP_EXPR);
    assert(node);
    node->op = op;
    node->left = left;
    node->right = right;
    return node;
}

m4define(`m4NAME', `Nap_NewNamePNode')

Nap_PNode *
Nap_NewNamePNode(
    NapClientData	*nap_cd,
    char		*name)
{
    Nap_PNode           *node;

    node = Nap_NewPNode(nap_cd, NAP_NAME);
    assert(node);
    node->str = name;
    return node;
}

m4define(`m4NAME', `Nap_NewNaoPNode')

Nap_PNode *
Nap_NewNaoPNode(
    NapClientData	*nap_cd,
    char		*naoID)
{
    Nap_PNode           *node;

    node = Nap_NewPNode(nap_cd, NAP_NAO);
    assert(node);
    node->str = naoID;
    return node;
}

m4define(`m4NAME', `Nap_NewValuePNode')

Nap_PNode *
Nap_NewValuePNode(
    NapClientData	*nap_cd,
    char		*repCount,	/* repetition count */
    Nap_Number		number)		/* numeric value */
{
    int			n;
    Nap_PNode           *node;
    int			status;

    status = Tcl_GetInt(nap_cd->interp, repCount, &n);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error parsing repetition count");
    CHECK2NULL(n >= 0, "m4NAME: bad repetition count");
    node = Nap_NewPNode(nap_cd, NAP_VALUE);
    assert(node);
    node->repCount = n;
    node->number = number;
    return node;
}

m4define(`m4NAME', `Nap_NewListPNode')

Nap_PNode *
Nap_NewListPNode(
    NapClientData	*nap_cd,
    char		*repCount,	/* repetition count */
    Nap_PNode           *list)		/* list of lower level */
{
    int			n;
    Nap_PNode           *node;
    int                 status;

    status = Tcl_GetInt(nap_cd->interp, repCount, &n);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error parsing repetition count");
    assert(!list || Nap_ValidPNclass(list->class));
    node = Nap_NewPNode(nap_cd, NAP_LIST);
    assert(node);
    node->repCount = n;
    node->list = list;
    return node;
}

/*
 * Nap_SizePNodeList --
 *	Count elements in Nap_PNode list, taking repetition counts into account.
 */

static int
Nap_SizePNodeList(
    Nap_PNode		*list)		/* head of list */
{
    int			result;

    for (result = 0; list; list = list->next) {
	result += list->repCount;
    }
    return result;
}

/*
 *  Return pointer to tail of Nap_PNode list.
 */

static Nap_PNode *
Nap_TailPNodeList(
    Nap_PNode		*list)		/* head of list */
{
    return list->tail;
}

/*
 * Nap_AppendToPNodeList --
 *
 * Append element to Nap_PNode list. Return pointer to head of list.
 * If head is NULL (empty list) then define new list by setting head = new.
 */

Nap_PNode *
Nap_AppendToPNodeList(
    NapClientData	*nap_cd,
    Nap_PNode		*head,		/* of list */
    Nap_PNode		*new)		/* new element */
{
    if (new) {
	if (head) {
	    Nap_TailPNodeList(head)->next = new;
	} else {
	    head = new;
	}
	head->tail = new;
    }
    return head;
}

/*
 * Nap_DataTypeSuffix --
 *
 * If token is data-type suffix (e.g. i16) then return its length, else return 0
 * Reg. Exp. b|s|f[0-9]*|[iu][0-9]+
 * Char. after suffix must be non-alphnumeric.
 */

static size_t
Nap_DataTypeSuffix(
    char                *str)          /* input stream */
{
    size_t		n;

    assert(str);
    n = 0;
    switch (str[0]) {
	case 'b':
	case 's':
	    n = 1;
	    break;
	case 'f':
	    n = 1;
	    while (isdigit(str[n])) {
		++n;
	    }
	    break;
	case 'i':
	case 'u':
	    if (isdigit(str[1])) {
		n = 1;
		while (isdigit(str[n])) {
		    ++n;
		}
	    }
	    break;
    }
    n = isalnum(str[n]) ? 0 : n;
    return n;
}

/*
 * Nap_DataTypeOfSuffix --
 *
 * If token has data-type suffix (e.g. i16) then delete suffix & return its type, else
 * return NAP_NULL_TYPE
 */

static Nap_dataType
Nap_DataTypeOfSuffix(
    char		*str)
{
    size_t		n;
    Nap_dataType	result = NAP_NULL_TYPE;

    n = strlen(str);
    if (n > 0  &&  Nap_DataTypeSuffix(str+n-1) > 0) {
	switch (str[n-1]) {
	    case 'b': result = NAP_U8;  break;
	    case 's': result = NAP_I16; break;
	    case 'f': result = NAP_F32; break;
	}
	str[n-1] = '\0';
    } else if (n > 1  &&  Nap_DataTypeSuffix(str+n-2) > 0) {
	result = Nap_TextToDataType(str+n-2);
	str[n-2] = '\0';
    } else if (n > 2  &&  Nap_DataTypeSuffix(str+n-3) > 0) {
	result = Nap_TextToDataType(str+n-3);
	str[n-3] = '\0';
    }
    return result;
}

/*
 * Nap_UnsignedInt --
 *
 * If part-token is unsigned decimal integer then return its length, else return 0
 */

static size_t
Nap_UnsignedInt(
    char                *str)          /* input stream */
{
    size_t		n;

    assert(str);
    n = 0;
    while (isdigit(str[n])) {
	++n;
    }
    return n;
}

/*
 * Nap_StringToNumber --
 *
 * Define result of type Nap_Number
 */

m4begin
m4define(`M4Nap_StringToNumber', `result->$1 = i;')
m4define(`M4Nap_StringToNumberMissing', `result->$1 = m4MissingValue($1);')
m4define(`m4NAME', `Nap_StringToNumber')
m4end

EXTERN int
Nap_StringToNumber(
    NapClientData	*nap_cd,
    char		*str,
    Nap_Number		*result)
{
    double		base;
    int			i;
    double		d;
    double		denominator;
    int			exponent;
    int			is_integer;	/* Valid integer? */
    char		*letterPtr;
    int			status;

    assert(str);
    str = Nap_StrDup(nap_cd, str);
    result->dataType = Nap_HexInt(str) > 0 ? NAP_U32 : Nap_DataTypeOfSuffix(str);
    is_integer = Nap_UnsignedInt(str) == strlen(str);
    if (strcmp(str, "_") == 0) {
	m4ForAllNumericDataType(`M4Nap_StringToNumberMissing(', `)')
	result->dataType = NAP_I32;
    } else if (Nap_Infinity(str) > 0) {
	result->F32 = napF32Inf;
	result->F64 = napF64Inf;
	if (result->dataType == NAP_NULL_TYPE ) {
	    result->dataType = NAP_F64;
	}
	CHECK2(Nap_TypeIsReal(result->dataType), "m4NAME: Invalid constant");
    } else if (Nap_NaN(str) > 0) {
	result->F32 = NAP_F32_NULL;
	result->F64 = NAP_F64_NULL;
	if (result->dataType == NAP_NULL_TYPE ) {
	    result->dataType = NAP_F64;
	}
	CHECK2(Nap_TypeIsReal(result->dataType), "m4NAME: Invalid constant");
    } else if (Nap_HexInt(str) > 0) {
	result->U32 = strtoul(str, (char**)NULL, 16);
	result->F64 = result->U32;
    } else if (is_integer) {
	i = atoi(str);
	m4ForAllNumericDataType(`M4Nap_StringToNumber(', `)')
	if (result->dataType == NAP_NULL_TYPE ) {
	    result->dataType = NAP_I32;
	}
	CHECK2(Nap_TypeIsNumeric(result->dataType), "m4NAME: Invalid constant");
	if (result->dataType == NAP_U32) {
	    result->F64 = result->U32;
	}
    } else {
	base = 10.0;
	letterPtr = strpbrk(str, "eEp");
	if (!letterPtr) {
	    exponent = 0;
	} else {
	    if (*letterPtr == 'p') {
		base = 4.0 * atan(1.0);
	    }
	    *letterPtr = '\0';
	    status = sscanf(letterPtr+1, "%d", &exponent);
	    if (status != 1) {
		exponent = 1;
	    }
	}
	letterPtr = strpbrk(str, "r");
	if (!letterPtr) {
	    status = Tcl_GetDouble(nap_cd->interp, str, &d);
	    CHECK2(status == TCL_OK, "m4NAME: Invalid constant");
	} else {
	    *letterPtr = '\0';
	    status = Tcl_GetDouble(nap_cd->interp, str, &d);
	    CHECK2(status == TCL_OK, "m4NAME: Invalid constant");
	    status = Tcl_GetDouble(nap_cd->interp, letterPtr+1, &denominator);
	    CHECK2(status == TCL_OK, "m4NAME: Invalid constant");
	    d /= denominator;
	}
	d *= pow(base, exponent);
	if (result->dataType == NAP_NULL_TYPE ) {
	    result->dataType = NAP_F64;
	}
	CHECK2(Nap_TypeIsReal(result->dataType), "m4NAME: Invalid constant");
	result->F32 = result->F64 = d;
    }
    NAP_FREE(nap_cd, str);
    return TCL_OK;
}

/*
 * Nap_NegateNumber --
 */

m4begin
# M4Nap_NegateNumber2(newType, oldType)
m4define(`M4Nap_NegateNumber2', 
`case m4DataTypeEnum($2): result.$1 = - (m4DataTypeName(`$1')) n.$2; break;')

# M4Nap_NegateNumber1(newType)
m4define(`M4Nap_NegateNumber1',
	`switch (n.dataType) {
	    m4ForAllNumericDataType(`M4Nap_NegateNumber2($1,', `)')
	    default: assert(FALSE);
	}')
m4end

Nap_Number
Nap_NegateNumber(
    NapClientData	*nap_cd,
    Nap_Number		n)
{
    Nap_Number		result;

    result.dataType = Max(m4DataTypeEnum(m4MinSignedDataType), n.dataType);
    m4ForAllSignedDataType(`M4Nap_NegateNumber1(', `)')
    return result;
}

m4begin
m4define(`m4NAME', `Nap_ScalarConstant')
M4DEF_RESULT(TYPE)  e.g. M4DEF_RESULT(I16)
m4define(`M4DEF_RESULT', 
    `case m4DataTypeEnum($1): *(result->data.$1) =  n.$1;  break;')
m4end

EXTERN char *
Nap_ScalarConstant(
    NapClientData	*nap_cd,
    Nap_Number		n)
{
    Nap_NAO		*result;

    result = Nap_NewNAO(nap_cd, n.dataType, 0, NULL);
    CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
    switch (result->dataType) {
	m4ForAllNumericDataType(`M4DEF_RESULT(', `)')
	default: assert(FALSE);
    }
    return result->id;
}

/*
 * Nap_FreePNodeTree --
 *	Free whole tree.
 */

m4define(`m4NAME', `Nap_FreePNodeTree')

EXTERN void
Nap_FreePNodeTree(
    NapClientData       *nap_cd,
    Nap_PNode           *tree)
{
    if (tree) {
	Nap_FreePNodeTree(nap_cd, tree->left);
	Nap_FreePNodeTree(nap_cd, tree->right);
	Nap_FreePNodeTree(nap_cd, tree->next);
	Nap_FreePNodeTree(nap_cd, tree->list);
	FreePNode(nap_cd, tree);
    }
}

/*
 * Nap_ElementsPNodeList --
 *	Fill nao buffer with elements of array constant
 */

m4define(`m4NAME', `Nap_ElementsPNodeList')

static int
Nap_ElementsPNodeList(
    NapClientData       *nap_cd,
    Nap_PNode           *tree,
    Nap_dataType        *maxDataType,
    m4DataTypeName(m4MaxRealDataType)		**dPtr,
    m4DataTypeName(m4MaxRealDataType)		*dPtrMax)
{
    int			i;
    int			status;
    Nap_PNode		*t;

    for (t = tree ;t; t = t->next) {
	switch (t->class) {
	    case NAP_LIST:
		for (i = 0 ;i < t->repCount; ++i) {
		    status = Nap_ElementsPNodeList(nap_cd, t->list, maxDataType, dPtr,
			    dPtrMax);
		    if (status != TCL_OK) {
			return status;
		    }
		}
		break;
	    case NAP_VALUE:
		for (i = 0 ;i < t->repCount; ++i) {
		    *maxDataType = Max(*maxDataType, t->number.dataType);
		    if (*dPtr >= dPtrMax) {
			CHECK2(FALSE, "m4NAME: Invalid array constant");
		    }
		    **dPtr = t->number.F64;
		    ++(*dPtr);
		}
		break;
	    default:
		assert(FALSE);
	}
    }
    return TCL_OK;
}

/*
 * Nap_StringConstant --
 *	Called from napParse.y
 */

m4define(`m4NAME', `Nap_StringConstant')

EXTERN char *
Nap_StringConstant(
    NapClientData	*nap_cd,
    char		*str)
{
    size_t		shape[1];
    Nap_NAO		*result;

    assert(str);
    shape[0] = strlen(str);
    result = Nap_NewNAO(nap_cd, NAP_C8, 1, shape);
    (void) strncpy(result->data.c, str, shape[0]);
    return result->id;
}

/*
 * Nap_ArrayConstant --
 *	Called from napParse.y
 */

m4define(`m4NAME', `Nap_ArrayConstant')

EXTERN char *
Nap_ArrayConstant(
    NapClientData	*nap_cd,
    Nap_PNode		*tree)
{
    Nap_dataType        maxDataType;
    int			i;
    m4DataTypeName(m4MaxRealDataType)		*dPtr;
    m4DataTypeName(m4MaxRealDataType)		*dPtrMax;
    Nap_NAO		*old;
    size_t		shape[NAP_MAX_RANK];
    int			rank;
    Nap_NAO		*result;
    int			status;
    Nap_PNode		*t;

    if (tree) {
	rank = 1;
	for (t = tree; t->list; t = t->list) {
	    ++rank;
	}
	for (i = 0, t = tree; i < rank; ++i, t = t->list) {
	    shape[i] = Nap_SizePNodeList(t);
	}
	result = Nap_NewNAO(nap_cd, m4DataTypeEnum(m4MaxRealDataType), rank, shape);
	CHECK2NULL(result, "m4NAME: Error calling Nap_NewNAO");
	dPtr = result->data.F64;
	dPtrMax = dPtr + result->nels;
	for (i = 0; i < result->nels; i++) {
	    dPtr[i] = m4MissingValue(m4MaxRealDataType);
	}
	maxDataType = m4DataTypeEnum(m4MinNumericDataType);
	status = Nap_ElementsPNodeList(nap_cd, tree, &maxDataType, &dPtr, dPtrMax);
	Nap_FreePNodeTree(nap_cd, tree);
	CHECK1NULL(status == TCL_OK);
	CHECK2NULL(dPtr == dPtrMax, "m4NAME: Invalid array constant");
	if (maxDataType != m4DataTypeEnum(m4MaxRealDataType)) {
	    old = result;
	    result = Nap_ReshapeNAO(nap_cd, old, maxDataType, rank, shape);
	    Nap_FreeNAO(nap_cd, old);
	}
    } else {
	shape[0] = 0;
	result = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
    }
    return result->id;
}

/*
 * Nap_GetNaoIdFromId --
 *
 * Get nao ID corresponding to nao ID or tcl variable-name.
 * Just interface to Nap_GetNaoFromId.
 */

m4define(`m4NAME', `Nap_GetNaoIdFromId')

EXTERN char *
Nap_GetNaoIdFromId(
    NapClientData	*nap_cd,
    char                *name)          /* nao ID or tcl variable-name */
{
    Nap_NAO             *naoPtr;

    CHECK2NULL(name, "m4NAME: Object name has NULL pointer");
    naoPtr = Nap_GetNaoFromId(nap_cd, name);
    CHECK3NULL(naoPtr, "m4NAME: Unable to find object named %s", name);
    return naoPtr->id;
}

/*
 * Nap_lexCompare --
 *
 * If current start of input stream exactly matches specified token then return
 * length of token, else return 0
 */

static size_t
Nap_lexCompare(
    char                *str,          /* input stream */
    char                *token)
{
    size_t		n;

    assert(str);
    assert(token);
    n = 0;
    while (token[n]  &&  str[n] == token[n]) {
	++n;
    }
    n = token[n] ? 0 : n;
    return n;
}

/*
 * Nap_String --
 *
 * If token is string then return its length, else return 0
 */

static size_t
Nap_String(
    char                *str)          /* input stream */
{
    size_t		n;
    char		*p;

    assert(str);
    n = 0;
    switch (str[0]) {
	m4changequote([, ])
	case '`':
	m4changequote
	case '\'':
	    p = strchr(str+1, str[0]);
	    if (p) {
		n = p + 1 - str;
	    }
	    break;
    }
    return n;
}

/*
 * Nap_RealSuffix --
 *
 * If token is real data-type suffix (e.g. f64) then return its length, else return 0
 * Reg. Exp. f[0-9]*
 * Char. after suffix must be non-alphnumeric.
 */

static size_t
Nap_RealSuffix(
    char                *str)          /* input stream */
{
    size_t		n;

    assert(str);
    n = str[0] == 'f' ?  Nap_DataTypeSuffix(str) : 0;
    return n;
}

/*
 * Nap_Int --
 *
 * If token is (signed or unsigned) decimal integer then return its length,
 * else return 0
 *
 * Reg. Exp. [+-]?[0-9]+[A-Za-z]?
 * Optional suffix indicates data-type.
 */

static size_t
Nap_Int(
    char                *str)          /* input stream */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    s += *s == '+'  ||  *s == '-';
    n = Nap_UnsignedInt(s);
    if (n == 0)  return 0;
    s += n;
    n = s + Nap_DataTypeSuffix(s) - str;
    n = isalnum(str[n]) ? 0 : n;
    return n;
}

/*
 * Nap_HexInt --
 *
 * If token is hexadecimal integer then return its length, else return 0
 * Reg. Exp. 0[Xx][0-9A-Fa-f]+
 */

static size_t
Nap_HexInt(
    char                *str)          /* input stream */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    if (*s != '0')  return 0;
    ++s;
    if (*s != 'x'  &&  *s != 'X')  return 0;
    ++s;
    while (isxdigit(*s)) {
	++s;
    }
    n = s - str;
    n = n < 3 ? 0 : n;
    return n;
}

/*
 * Nap_Infinity --
 *
 * If token is infinity then return its length, else return 0
 * Reg. Exp. [0-9][iI][a-zA-Z]?
 * Optional suffix indicates data-type.
 */

static size_t
Nap_Infinity(
    char                *str)          /* input stream */
{
    size_t		n;

    assert(str);
    if (!isdigit(str[0])  ||  tolower(str[1]) != 'i')  return 0;
    n = 2;
    while (isalnum(str[n])) {
	++n;
    }
    n = !isdigit(str[n-1])  ||  Nap_RealSuffix(str+n-3) == 3  ?  n  :  0;
    return n;
}

/*
 * Nap_NaN --
 *
 * If token is infinity then return its length, else return 0
 * Reg. Exp. [0-9][nN][a-zA-Z0-9]?
 * Optional suffix indicates data-type.
 */

static size_t
Nap_NaN(
    char                *str)          /* input stream */
{
    size_t		n;

    assert(str);
    if (!isdigit(str[0])  ||  tolower(str[1]) != 'n')  return 0;
    n = 2;
    while (isalnum(str[n])) {
	++n;
    }
    return n;
}

/*
 * Nap_mantissa --
 *
 * If token is mantissa then return its length, else return 0
 * One of:
 *   unsigned_integer
 *   unsigned_integer "." unsigned_integer
 *   unsigned_integer "r" unsigned_integer
 *   "." unsigned_integer (if braceLevel > 0)
 *   unsigned_integer "." (if braceLevel > 0)
 */

static size_t
Nap_mantissa(
    char		*str,		/* input stream */
    int			braceLevel)	/* nesting level within array constant */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    n = Nap_UnsignedInt(s);
    s += n;
    if (n == 0) {
	if (braceLevel > 0  &&  *str == '.') {
	    n = Nap_UnsignedInt(str+1);
	    if (n > 0) {
		s += n + 1;
	    }
	}
    } else {
	n = Nap_UnsignedInt(s+1);
	switch (*s) {
	    case '.':
		if (n > 0  ||  braceLevel > 0) {
		    s += n + 1;
		}
		break;
	    case 'r':
		if (n > 0) {
		    s += n + 1;
		} else {
		    s = str;
		}
		break;
	}
    }
    return s - str;
}

/*
 * Nap_SimpleNumber --
 *
 * If token is integer or float-without-exponent then return its length, else
 * return 0
 *
 * One of:
 *   mantissa
 *   mantissa suffix
 *
 * Optional suffix indicates data-type.
 */

static size_t
Nap_SimpleNumber(
    char		*str,		/* input stream */
    int			braceLevel)	/* nesting level within array constant */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    n = Nap_mantissa(s, braceLevel);
    if (n > 0) {
	s += n;
	n = s + Nap_DataTypeSuffix(s) - str;
	n = isalnum(str[n]) ? 0 : n;
    }
    return n;
}

/*
 * Nap_ExpFloat --
 *
 * If token is float with exponent then return its length, else return 0
 * One of:
 *   mantissa letter integer
 *   mantissa letter integer suffix
 *
 * Letter is one of 'e', 'E', 'p'.
 * Optional suffix indicates data-type.
 */

static size_t
Nap_ExpFloat(
    char		*str,		/* input stream */
    int			braceLevel)	/* nesting level within array constant */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    n = Nap_mantissa(s, braceLevel);
    s += n;
    if (n > 0  &&  *s  &&  strchr("eEp", *s)) {
	++s;
	n = Nap_Int(s);
	if (n == 0) {
	    n = Nap_DataTypeSuffix(s);
	}
	n += s - str;
    }
    n = isalnum(str[n]) ? 0 : n;
    return n;
}

/*
 * Nap_lexID --
 *
 * If token is NAO ID then return its length, else return 0
 */

EXTERN size_t
Nap_lexID(
    char                *str)          /* input stream */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    n = Nap_lexCompare(s, NAP_NAO_ID_PREFIX);
    if (n == 0) return 0;
    s += n;
    n = Nap_UnsignedInt(s);
    if (n == 0) return 0;
    s += n;
    if (*s != '-') return 0;
    ++s;
    n = Nap_UnsignedInt(s);
    n = n == 0 ? 0 : s + n - str;
    return n;
}

/*
 * Nap_lexSimpleName --
 *
 * If token is simple name then return its length, else return 0
 * Must start with "_" or letter. This may be followed by "_"s, letters and
 * digits.  The string "_" by itself is not a valid name.
 */

EXTERN size_t
Nap_lexSimpleName(
    char                *str)          /* input stream */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    if (!isalpha(*s)  &&  *s != '_') return 0;
    ++s;
    while (isalnum(*s)  ||  *s == '_') {
	++s;
    }
    s -= (*str == '_'  &&  s == str+1);
    n = s - str;
    return n;
}

/*
 * Nap_lexPathSeparator --
 *
 * If token is namespace path separator then return its length, else return 0
 * Separator consists of 2 or more ":"s
 * E.g. "::", ":::", "::::".
 */

static size_t
Nap_lexPathSeparator(
    char                *str)          /* input stream */
{
    size_t		n;

    assert(str);
    n = 0;
    while (str[n] == ':') {
	++n;
    }
    return n == 1 ? 0 : n;
}

/*
 * Nap_lexNamespace --
 *
 * If token is legal name of namespace (with following "::") then return its length, else return 0
 * Either simple name or unsigned integer, followed by "::"
 */

static size_t
Nap_lexNamespace(
    char                *str)          /* input stream */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    n = Nap_lexSimpleName(s);
    if (n == 0) {
	n = Nap_UnsignedInt(s);
    }
    if (n > 0) {
	s += n;
	n = Nap_lexPathSeparator(s);
	if (n > 0) {
	    n += s - str;
	}
    }
    return n;
}

/*
 * Nap_lexPath --
 *
 * If token is legal namespace path then return its length, else return 0
 * Has form [::]namespace:: ... ::namespace::
 * E.g. "::", "abc::", "::a::b::"
 */

static size_t
Nap_lexPath(
    char                *str)          /* input stream */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    s += Nap_lexPathSeparator(s);
    while ((n = Nap_lexNamespace(s)) > 0) {
	s += n;
    }
    n = s - str;
    return n;
}

/*
 * Nap_lexName --
 *
 * If token is name then return its length, else return 0
 * Either simple name or namespace path followed by simple name
 */

EXTERN size_t
Nap_lexName(
    char                *str)          /* input stream */
{
    size_t		n;
    char                *s;

    assert(str);
    s = str;
    s += Nap_lexPath(s);
    n = Nap_lexSimpleName(s);
    if (n > 0) {
	n += s - str;
    }
    return n;
}

/*
 * Nap_lex --
 *
 * Lexical analyser replacing that produced by lex/flex
 */

EXTERN int
Nap_lex(
    Nap_stype		*lvalp,
    NapClientData	*nap_cd)
{
    int			braceLevel = nap_cd->braceLevel[nap_cd->parseLevel];
    int			level = nap_cd->parseLevel;
    size_t		n;
    size_t		nc;		/* # chars in whole command */
    int			result;
    char		*startPtr;

    nc = nap_cd->commandLength[level];
    startPtr = nap_cd->scanString[level];
    assert(startPtr);
    lvalp->str = NULL;
    while (isspace(*startPtr)  ||  *startPtr == '$') {	/* skip white space and $s */
	++startPtr;
    }
    n = 0;
    if (startPtr[0] == '\0')						result = 0;
    else if ((n = Nap_String(startPtr)) > 0)				result = STRING;
    else if ((n = Nap_lexID(startPtr)) > 0)				result = ID;
    else if ((n = Nap_lexName(startPtr)) > 0)				result = NAME;
    else if ((n = Nap_ExpFloat(startPtr, braceLevel)) > 0)		result = UNUMBER;
    else if ((n = Nap_HexInt(startPtr)) > 0)				result = UNUMBER;
    else if ((n = Nap_Infinity(startPtr)) > 0)				result = UNUMBER;
    else if ((n = Nap_NaN(startPtr)) > 0)				result = UNUMBER;
    else if ((n = Nap_SimpleNumber(startPtr, braceLevel)) > 0)		result = UNUMBER;
    else if ((n = Nap_lexCompare(startPtr, "...")) > 0)			result = AP3;
    else if ((n = Nap_lexCompare(startPtr, "..")) > 0)			result = TO;
    else if ((n = Nap_lexCompare(startPtr, "==")) > 0)			result = EQ;
    else if ((n = Nap_lexCompare(startPtr, "!=")) > 0)			result = NE;
    else if ((n = Nap_lexCompare(startPtr, "<=")) > 0)			result = LE;
    else if ((n = Nap_lexCompare(startPtr, ">=")) > 0)			result = GE;
    else if ((n = Nap_lexCompare(startPtr, "<<<")) > 0)			result = LESSER_OF;
    else if ((n = Nap_lexCompare(startPtr, "<<")) > 0)			result = SHIFT_LEFT;
    else if ((n = Nap_lexCompare(startPtr, ">>>")) > 0)			result = GREATER_OF;
    else if ((n = Nap_lexCompare(startPtr, ">>")) > 0)			result = SHIFT_RIGHT;
    else if ((n = Nap_lexCompare(startPtr, "&&")) > 0)			result = AND;
    else if ((n = Nap_lexCompare(startPtr, "||")) > 0)			result = OR;
    else if ((n = Nap_lexCompare(startPtr, "**")) > 0)			result = POWER;
    else if ((n = Nap_lexCompare(startPtr, "///")) > 0)			result = LAMINATE;
    else if ((n = Nap_lexCompare(startPtr, "//")) > 0)			result = CAT;
    else if ((n = Nap_lexCompare(startPtr, "@@@")) > 0)			result = MATCH;
    else if ((n = Nap_lexCompare(startPtr, "@@")) > 0)			result = CLOSEST;
    else if ((n = Nap_lexCompare(startPtr, ".")) > 0)			result = INNER_PROD;
    else if ((n = Nap_lexCompare(startPtr, "+*")) > 0)			result = INNER_PROD;
    else if ((n = Nap_lexCompare(startPtr, "_")) > 0)			result = UNUMBER;
    else {
	n = 1;
	result = *(startPtr);
    }
    assert(n > 0  ||  result == 0);
    switch (result) {
	case ID:
	case NAME:
	case UNUMBER:
	    lvalp->str = startPtr + nc + 1;  /* Use 2nd copy of whole string */
	    lvalp->str[n] = '\0';
	    break;
	case STRING:
	    lvalp->str = startPtr + nc + 2;  /* Use 2nd copy of whole string */
	    lvalp->str[n-2] = '\0';
	    break;
	case '{':
	    ++nap_cd->braceLevel[nap_cd->parseLevel];
	    lvalp->op = result;
	    break;
	case '}':
	    --nap_cd->braceLevel[nap_cd->parseLevel];
	    lvalp->op = result;
	    break;
	default:
	    lvalp->op = result;
    }
    nap_cd->token[level] = startPtr;
    nap_cd->scanString[level] = startPtr + n;
    return result;
}
