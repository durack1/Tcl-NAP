#line 6 "/home/dav480/tcl/nap/generic/include.m4"

#line 5 "/home/dav480/tcl/nap/generic/napSpatial.c,m4"
/* Do not edit this file (napSpatial.c). It was produced from source file napSpatial.c,m4 */

/* 
 *      napSpatial.c,m4 --
 *
 *      Copyright 1999, CSIRO Australia
 *      Author: P.J. Turner, CSIRO Atmospheric Research
 */

#ifndef lint
static char *rcsid="@(#) $Id: napSpatial.c,m4,v 1.12 2004/07/08 23:48:22 dav480 Exp $"
;
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"

/* Nap_moving_range --
 *
 * Compute the maximum difference between elements
 * in a sliding window of size m*n If m and n
 * are odd the result is placed in the center
 * position of the window. Otherwise the result
 * is positioned in the top left corner.
 *
 * Method: Find the maximum and minimum values in the
 *         kernel area to get the maximum difference.
 *
 * Usage:
 *	moving_range(data,kernel_shape)
 *
 *      where data is an array or vector
 *      and shape specifies dimensions (less than or equal data)
 */

#line 162 "/home/dav480/tcl/nap/generic/napSpatial.c,m4"


#line 163

#line 163

#line 163

#line 163
static int
#line 163
movrange_U8(
#line 163
    void *in,		/* input data array	*/
#line 163
    size_t ySize,	/* ysize		*/
#line 163
    size_t xSize,	/* xsize		*/
#line 163
    size_t yksize,	/* ysize of the kernel	*/
#line 163
    size_t xksize,	/* xsize of the kernel	*/
#line 163
    void *out		/* output data array	*/
#line 163
)
#line 163

#line 163
{
#line 163
    size_t xlag;	/* number of x steps across the input data	*/
#line 163
    size_t ylag;	/* number of y steps across the input data	*/
#line 163
    size_t resultOffset;	/* amount to offset result wrt kernel	*/
#line 163
    Nap_u8 *pixelPtr;	/* current input pixelpointer	*/
#line 163
    Nap_u8 *lineInPtr;	/* current input line pointer 	*/ 
#line 163
    Nap_u8 *pixelOutPtr;	/* current output pixel pointer	*/ 
#line 163
    Nap_u8 *lineOutPtr;	/* current output line pointer	*/ 
#line 163
    Nap_u8 *kpixelPtr;	/* pixel pointer  current window area */
#line 163
    Nap_u8 *klinePtr;	/* line pointer inthe window area */
#line 163
    Nap_u8 kmax;	/* current maximum kernel value		*/
#line 163
    Nap_u8 kmin;	/* current minimum kernel value		*/
#line 163
    int i,j;	/* integer x,y positions in the data space	*/
#line 163
    int m,n,xwo,ywo;
#line 163

#line 163
    if(xSize + 1 < xksize || ySize + 1 < yksize) {
#line 163
        return(-1);
#line 163
    }
#line 163

#line 163
    xlag = xSize - xksize + 1;
#line 163
    ylag = ySize - yksize + 1;
#line 163

#line 163
/*
#line 163
 * Put the result as close to the center of the
#line 163
 * sliding window as possible
#line 163
 */
#line 163
    xwo = (xksize - 1)/2;
#line 163
    ywo = (yksize - 1)/2;
#line 163
    resultOffset = ywo*xSize + xwo;
#line 163

#line 163
/*
#line 163
 * Clear regions the window is not going to write to.
#line 163
 */
#line 163

#line 163
    lineOutPtr = out;
#line 163
    for(i=0; i < ySize; i++) {
#line 163
        pixelOutPtr = lineOutPtr;
#line 163
        if(i < ywo || i >= (ylag + ywo)) {
#line 163
            for(j=0; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_U8_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
        } else {
#line 163
            for(j=0; j < xwo; j++) {
#line 163
                *pixelOutPtr = NAP_U8_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
            pixelOutPtr = lineOutPtr + xlag + xwo;
#line 163
            for(j=xlag+xwo; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_U8_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163

#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
    }
#line 163

#line 163
    lineInPtr = in;
#line 163
    lineOutPtr = out;
#line 163
    lineOutPtr = lineOutPtr + resultOffset;
#line 163
    for(i=0; i < ylag; i++) {
#line 163
        pixelPtr = lineInPtr;
#line 163
        for(j=0; j < xlag; j++) {
#line 163
/*
#line 163
 * At this point we are positioned at some i,j pixel
#line 163
 * in the input data array. The i,j represents the
#line 163
 * top left corner of the operator kernel.
#line 163
 */
#line 163
            m = 0;
#line 163
            klinePtr = pixelPtr;
#line 163
            kpixelPtr = pixelPtr;
#line 163
/* case here */
#line 163
            kmax = kmin = *kpixelPtr;
#line 163
            for(m=0; m < yksize; m++) {
#line 163
                for(n=0; n < xksize; n++) {
#line 163
                    if(*kpixelPtr > kmax) kmax = *kpixelPtr;
#line 163
                    if(*kpixelPtr < kmin) kmin = *kpixelPtr;
#line 163
                    kpixelPtr++;
#line 163
                }
#line 163
                klinePtr = klinePtr + xSize;
#line 163
                kpixelPtr = klinePtr;
#line 163
            }
#line 163
/*
#line 163
 * Put the result somewhere!
#line 163
 */
#line 163
            pixelOutPtr = lineOutPtr + j;
#line 163
            *pixelOutPtr = kmax - kmin;
#line 163
/*
#line 163
 * Move to the next pixel position
#line 163
 */
#line 163
            pixelPtr++;
#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
        lineInPtr = lineInPtr + xSize;
#line 163
    }
#line 163
    return(0);
#line 163
}
#line 163

#line 163

#line 163
static int
#line 163
movrange_U16(
#line 163
    void *in,		/* input data array	*/
#line 163
    size_t ySize,	/* ysize		*/
#line 163
    size_t xSize,	/* xsize		*/
#line 163
    size_t yksize,	/* ysize of the kernel	*/
#line 163
    size_t xksize,	/* xsize of the kernel	*/
#line 163
    void *out		/* output data array	*/
#line 163
)
#line 163

#line 163
{
#line 163
    size_t xlag;	/* number of x steps across the input data	*/
#line 163
    size_t ylag;	/* number of y steps across the input data	*/
#line 163
    size_t resultOffset;	/* amount to offset result wrt kernel	*/
#line 163
    Nap_u16 *pixelPtr;	/* current input pixelpointer	*/
#line 163
    Nap_u16 *lineInPtr;	/* current input line pointer 	*/ 
#line 163
    Nap_u16 *pixelOutPtr;	/* current output pixel pointer	*/ 
#line 163
    Nap_u16 *lineOutPtr;	/* current output line pointer	*/ 
#line 163
    Nap_u16 *kpixelPtr;	/* pixel pointer  current window area */
#line 163
    Nap_u16 *klinePtr;	/* line pointer inthe window area */
#line 163
    Nap_u16 kmax;	/* current maximum kernel value		*/
#line 163
    Nap_u16 kmin;	/* current minimum kernel value		*/
#line 163
    int i,j;	/* integer x,y positions in the data space	*/
#line 163
    int m,n,xwo,ywo;
#line 163

#line 163
    if(xSize + 1 < xksize || ySize + 1 < yksize) {
#line 163
        return(-1);
#line 163
    }
#line 163

#line 163
    xlag = xSize - xksize + 1;
#line 163
    ylag = ySize - yksize + 1;
#line 163

#line 163
/*
#line 163
 * Put the result as close to the center of the
#line 163
 * sliding window as possible
#line 163
 */
#line 163
    xwo = (xksize - 1)/2;
#line 163
    ywo = (yksize - 1)/2;
#line 163
    resultOffset = ywo*xSize + xwo;
#line 163

#line 163
/*
#line 163
 * Clear regions the window is not going to write to.
#line 163
 */
#line 163

#line 163
    lineOutPtr = out;
#line 163
    for(i=0; i < ySize; i++) {
#line 163
        pixelOutPtr = lineOutPtr;
#line 163
        if(i < ywo || i >= (ylag + ywo)) {
#line 163
            for(j=0; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_U16_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
        } else {
#line 163
            for(j=0; j < xwo; j++) {
#line 163
                *pixelOutPtr = NAP_U16_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
            pixelOutPtr = lineOutPtr + xlag + xwo;
#line 163
            for(j=xlag+xwo; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_U16_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163

#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
    }
#line 163

#line 163
    lineInPtr = in;
#line 163
    lineOutPtr = out;
#line 163
    lineOutPtr = lineOutPtr + resultOffset;
#line 163
    for(i=0; i < ylag; i++) {
#line 163
        pixelPtr = lineInPtr;
#line 163
        for(j=0; j < xlag; j++) {
#line 163
/*
#line 163
 * At this point we are positioned at some i,j pixel
#line 163
 * in the input data array. The i,j represents the
#line 163
 * top left corner of the operator kernel.
#line 163
 */
#line 163
            m = 0;
#line 163
            klinePtr = pixelPtr;
#line 163
            kpixelPtr = pixelPtr;
#line 163
/* case here */
#line 163
            kmax = kmin = *kpixelPtr;
#line 163
            for(m=0; m < yksize; m++) {
#line 163
                for(n=0; n < xksize; n++) {
#line 163
                    if(*kpixelPtr > kmax) kmax = *kpixelPtr;
#line 163
                    if(*kpixelPtr < kmin) kmin = *kpixelPtr;
#line 163
                    kpixelPtr++;
#line 163
                }
#line 163
                klinePtr = klinePtr + xSize;
#line 163
                kpixelPtr = klinePtr;
#line 163
            }
#line 163
/*
#line 163
 * Put the result somewhere!
#line 163
 */
#line 163
            pixelOutPtr = lineOutPtr + j;
#line 163
            *pixelOutPtr = kmax - kmin;
#line 163
/*
#line 163
 * Move to the next pixel position
#line 163
 */
#line 163
            pixelPtr++;
#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
        lineInPtr = lineInPtr + xSize;
#line 163
    }
#line 163
    return(0);
#line 163
}
#line 163

#line 163

#line 163
static int
#line 163
movrange_U32(
#line 163
    void *in,		/* input data array	*/
#line 163
    size_t ySize,	/* ysize		*/
#line 163
    size_t xSize,	/* xsize		*/
#line 163
    size_t yksize,	/* ysize of the kernel	*/
#line 163
    size_t xksize,	/* xsize of the kernel	*/
#line 163
    void *out		/* output data array	*/
#line 163
)
#line 163

#line 163
{
#line 163
    size_t xlag;	/* number of x steps across the input data	*/
#line 163
    size_t ylag;	/* number of y steps across the input data	*/
#line 163
    size_t resultOffset;	/* amount to offset result wrt kernel	*/
#line 163
    Nap_u32 *pixelPtr;	/* current input pixelpointer	*/
#line 163
    Nap_u32 *lineInPtr;	/* current input line pointer 	*/ 
#line 163
    Nap_u32 *pixelOutPtr;	/* current output pixel pointer	*/ 
#line 163
    Nap_u32 *lineOutPtr;	/* current output line pointer	*/ 
#line 163
    Nap_u32 *kpixelPtr;	/* pixel pointer  current window area */
#line 163
    Nap_u32 *klinePtr;	/* line pointer inthe window area */
#line 163
    Nap_u32 kmax;	/* current maximum kernel value		*/
#line 163
    Nap_u32 kmin;	/* current minimum kernel value		*/
#line 163
    int i,j;	/* integer x,y positions in the data space	*/
#line 163
    int m,n,xwo,ywo;
#line 163

#line 163
    if(xSize + 1 < xksize || ySize + 1 < yksize) {
#line 163
        return(-1);
#line 163
    }
#line 163

#line 163
    xlag = xSize - xksize + 1;
#line 163
    ylag = ySize - yksize + 1;
#line 163

#line 163
/*
#line 163
 * Put the result as close to the center of the
#line 163
 * sliding window as possible
#line 163
 */
#line 163
    xwo = (xksize - 1)/2;
#line 163
    ywo = (yksize - 1)/2;
#line 163
    resultOffset = ywo*xSize + xwo;
#line 163

#line 163
/*
#line 163
 * Clear regions the window is not going to write to.
#line 163
 */
#line 163

#line 163
    lineOutPtr = out;
#line 163
    for(i=0; i < ySize; i++) {
#line 163
        pixelOutPtr = lineOutPtr;
#line 163
        if(i < ywo || i >= (ylag + ywo)) {
#line 163
            for(j=0; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_U32_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
        } else {
#line 163
            for(j=0; j < xwo; j++) {
#line 163
                *pixelOutPtr = NAP_U32_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
            pixelOutPtr = lineOutPtr + xlag + xwo;
#line 163
            for(j=xlag+xwo; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_U32_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163

#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
    }
#line 163

#line 163
    lineInPtr = in;
#line 163
    lineOutPtr = out;
#line 163
    lineOutPtr = lineOutPtr + resultOffset;
#line 163
    for(i=0; i < ylag; i++) {
#line 163
        pixelPtr = lineInPtr;
#line 163
        for(j=0; j < xlag; j++) {
#line 163
/*
#line 163
 * At this point we are positioned at some i,j pixel
#line 163
 * in the input data array. The i,j represents the
#line 163
 * top left corner of the operator kernel.
#line 163
 */
#line 163
            m = 0;
#line 163
            klinePtr = pixelPtr;
#line 163
            kpixelPtr = pixelPtr;
#line 163
/* case here */
#line 163
            kmax = kmin = *kpixelPtr;
#line 163
            for(m=0; m < yksize; m++) {
#line 163
                for(n=0; n < xksize; n++) {
#line 163
                    if(*kpixelPtr > kmax) kmax = *kpixelPtr;
#line 163
                    if(*kpixelPtr < kmin) kmin = *kpixelPtr;
#line 163
                    kpixelPtr++;
#line 163
                }
#line 163
                klinePtr = klinePtr + xSize;
#line 163
                kpixelPtr = klinePtr;
#line 163
            }
#line 163
/*
#line 163
 * Put the result somewhere!
#line 163
 */
#line 163
            pixelOutPtr = lineOutPtr + j;
#line 163
            *pixelOutPtr = kmax - kmin;
#line 163
/*
#line 163
 * Move to the next pixel position
#line 163
 */
#line 163
            pixelPtr++;
#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
        lineInPtr = lineInPtr + xSize;
#line 163
    }
#line 163
    return(0);
#line 163
}
#line 163

#line 163

#line 163

#line 163

#line 163
static int
#line 163
movrange_I8(
#line 163
    void *in,		/* input data array	*/
#line 163
    size_t ySize,	/* ysize		*/
#line 163
    size_t xSize,	/* xsize		*/
#line 163
    size_t yksize,	/* ysize of the kernel	*/
#line 163
    size_t xksize,	/* xsize of the kernel	*/
#line 163
    void *out		/* output data array	*/
#line 163
)
#line 163

#line 163
{
#line 163
    size_t xlag;	/* number of x steps across the input data	*/
#line 163
    size_t ylag;	/* number of y steps across the input data	*/
#line 163
    size_t resultOffset;	/* amount to offset result wrt kernel	*/
#line 163
    Nap_i8 *pixelPtr;	/* current input pixelpointer	*/
#line 163
    Nap_i8 *lineInPtr;	/* current input line pointer 	*/ 
#line 163
    Nap_i8 *pixelOutPtr;	/* current output pixel pointer	*/ 
#line 163
    Nap_i8 *lineOutPtr;	/* current output line pointer	*/ 
#line 163
    Nap_i8 *kpixelPtr;	/* pixel pointer  current window area */
#line 163
    Nap_i8 *klinePtr;	/* line pointer inthe window area */
#line 163
    Nap_i8 kmax;	/* current maximum kernel value		*/
#line 163
    Nap_i8 kmin;	/* current minimum kernel value		*/
#line 163
    int i,j;	/* integer x,y positions in the data space	*/
#line 163
    int m,n,xwo,ywo;
#line 163

#line 163
    if(xSize + 1 < xksize || ySize + 1 < yksize) {
#line 163
        return(-1);
#line 163
    }
#line 163

#line 163
    xlag = xSize - xksize + 1;
#line 163
    ylag = ySize - yksize + 1;
#line 163

#line 163
/*
#line 163
 * Put the result as close to the center of the
#line 163
 * sliding window as possible
#line 163
 */
#line 163
    xwo = (xksize - 1)/2;
#line 163
    ywo = (yksize - 1)/2;
#line 163
    resultOffset = ywo*xSize + xwo;
#line 163

#line 163
/*
#line 163
 * Clear regions the window is not going to write to.
#line 163
 */
#line 163

#line 163
    lineOutPtr = out;
#line 163
    for(i=0; i < ySize; i++) {
#line 163
        pixelOutPtr = lineOutPtr;
#line 163
        if(i < ywo || i >= (ylag + ywo)) {
#line 163
            for(j=0; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_I8_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
        } else {
#line 163
            for(j=0; j < xwo; j++) {
#line 163
                *pixelOutPtr = NAP_I8_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
            pixelOutPtr = lineOutPtr + xlag + xwo;
#line 163
            for(j=xlag+xwo; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_I8_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163

#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
    }
#line 163

#line 163
    lineInPtr = in;
#line 163
    lineOutPtr = out;
#line 163
    lineOutPtr = lineOutPtr + resultOffset;
#line 163
    for(i=0; i < ylag; i++) {
#line 163
        pixelPtr = lineInPtr;
#line 163
        for(j=0; j < xlag; j++) {
#line 163
/*
#line 163
 * At this point we are positioned at some i,j pixel
#line 163
 * in the input data array. The i,j represents the
#line 163
 * top left corner of the operator kernel.
#line 163
 */
#line 163
            m = 0;
#line 163
            klinePtr = pixelPtr;
#line 163
            kpixelPtr = pixelPtr;
#line 163
/* case here */
#line 163
            kmax = kmin = *kpixelPtr;
#line 163
            for(m=0; m < yksize; m++) {
#line 163
                for(n=0; n < xksize; n++) {
#line 163
                    if(*kpixelPtr > kmax) kmax = *kpixelPtr;
#line 163
                    if(*kpixelPtr < kmin) kmin = *kpixelPtr;
#line 163
                    kpixelPtr++;
#line 163
                }
#line 163
                klinePtr = klinePtr + xSize;
#line 163
                kpixelPtr = klinePtr;
#line 163
            }
#line 163
/*
#line 163
 * Put the result somewhere!
#line 163
 */
#line 163
            pixelOutPtr = lineOutPtr + j;
#line 163
            *pixelOutPtr = kmax - kmin;
#line 163
/*
#line 163
 * Move to the next pixel position
#line 163
 */
#line 163
            pixelPtr++;
#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
        lineInPtr = lineInPtr + xSize;
#line 163
    }
#line 163
    return(0);
#line 163
}
#line 163

#line 163

#line 163
static int
#line 163
movrange_I16(
#line 163
    void *in,		/* input data array	*/
#line 163
    size_t ySize,	/* ysize		*/
#line 163
    size_t xSize,	/* xsize		*/
#line 163
    size_t yksize,	/* ysize of the kernel	*/
#line 163
    size_t xksize,	/* xsize of the kernel	*/
#line 163
    void *out		/* output data array	*/
#line 163
)
#line 163

#line 163
{
#line 163
    size_t xlag;	/* number of x steps across the input data	*/
#line 163
    size_t ylag;	/* number of y steps across the input data	*/
#line 163
    size_t resultOffset;	/* amount to offset result wrt kernel	*/
#line 163
    Nap_i16 *pixelPtr;	/* current input pixelpointer	*/
#line 163
    Nap_i16 *lineInPtr;	/* current input line pointer 	*/ 
#line 163
    Nap_i16 *pixelOutPtr;	/* current output pixel pointer	*/ 
#line 163
    Nap_i16 *lineOutPtr;	/* current output line pointer	*/ 
#line 163
    Nap_i16 *kpixelPtr;	/* pixel pointer  current window area */
#line 163
    Nap_i16 *klinePtr;	/* line pointer inthe window area */
#line 163
    Nap_i16 kmax;	/* current maximum kernel value		*/
#line 163
    Nap_i16 kmin;	/* current minimum kernel value		*/
#line 163
    int i,j;	/* integer x,y positions in the data space	*/
#line 163
    int m,n,xwo,ywo;
#line 163

#line 163
    if(xSize + 1 < xksize || ySize + 1 < yksize) {
#line 163
        return(-1);
#line 163
    }
#line 163

#line 163
    xlag = xSize - xksize + 1;
#line 163
    ylag = ySize - yksize + 1;
#line 163

#line 163
/*
#line 163
 * Put the result as close to the center of the
#line 163
 * sliding window as possible
#line 163
 */
#line 163
    xwo = (xksize - 1)/2;
#line 163
    ywo = (yksize - 1)/2;
#line 163
    resultOffset = ywo*xSize + xwo;
#line 163

#line 163
/*
#line 163
 * Clear regions the window is not going to write to.
#line 163
 */
#line 163

#line 163
    lineOutPtr = out;
#line 163
    for(i=0; i < ySize; i++) {
#line 163
        pixelOutPtr = lineOutPtr;
#line 163
        if(i < ywo || i >= (ylag + ywo)) {
#line 163
            for(j=0; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_I16_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
        } else {
#line 163
            for(j=0; j < xwo; j++) {
#line 163
                *pixelOutPtr = NAP_I16_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
            pixelOutPtr = lineOutPtr + xlag + xwo;
#line 163
            for(j=xlag+xwo; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_I16_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163

#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
    }
#line 163

#line 163
    lineInPtr = in;
#line 163
    lineOutPtr = out;
#line 163
    lineOutPtr = lineOutPtr + resultOffset;
#line 163
    for(i=0; i < ylag; i++) {
#line 163
        pixelPtr = lineInPtr;
#line 163
        for(j=0; j < xlag; j++) {
#line 163
/*
#line 163
 * At this point we are positioned at some i,j pixel
#line 163
 * in the input data array. The i,j represents the
#line 163
 * top left corner of the operator kernel.
#line 163
 */
#line 163
            m = 0;
#line 163
            klinePtr = pixelPtr;
#line 163
            kpixelPtr = pixelPtr;
#line 163
/* case here */
#line 163
            kmax = kmin = *kpixelPtr;
#line 163
            for(m=0; m < yksize; m++) {
#line 163
                for(n=0; n < xksize; n++) {
#line 163
                    if(*kpixelPtr > kmax) kmax = *kpixelPtr;
#line 163
                    if(*kpixelPtr < kmin) kmin = *kpixelPtr;
#line 163
                    kpixelPtr++;
#line 163
                }
#line 163
                klinePtr = klinePtr + xSize;
#line 163
                kpixelPtr = klinePtr;
#line 163
            }
#line 163
/*
#line 163
 * Put the result somewhere!
#line 163
 */
#line 163
            pixelOutPtr = lineOutPtr + j;
#line 163
            *pixelOutPtr = kmax - kmin;
#line 163
/*
#line 163
 * Move to the next pixel position
#line 163
 */
#line 163
            pixelPtr++;
#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
        lineInPtr = lineInPtr + xSize;
#line 163
    }
#line 163
    return(0);
#line 163
}
#line 163

#line 163

#line 163
static int
#line 163
movrange_I32(
#line 163
    void *in,		/* input data array	*/
#line 163
    size_t ySize,	/* ysize		*/
#line 163
    size_t xSize,	/* xsize		*/
#line 163
    size_t yksize,	/* ysize of the kernel	*/
#line 163
    size_t xksize,	/* xsize of the kernel	*/
#line 163
    void *out		/* output data array	*/
#line 163
)
#line 163

#line 163
{
#line 163
    size_t xlag;	/* number of x steps across the input data	*/
#line 163
    size_t ylag;	/* number of y steps across the input data	*/
#line 163
    size_t resultOffset;	/* amount to offset result wrt kernel	*/
#line 163
    Nap_i32 *pixelPtr;	/* current input pixelpointer	*/
#line 163
    Nap_i32 *lineInPtr;	/* current input line pointer 	*/ 
#line 163
    Nap_i32 *pixelOutPtr;	/* current output pixel pointer	*/ 
#line 163
    Nap_i32 *lineOutPtr;	/* current output line pointer	*/ 
#line 163
    Nap_i32 *kpixelPtr;	/* pixel pointer  current window area */
#line 163
    Nap_i32 *klinePtr;	/* line pointer inthe window area */
#line 163
    Nap_i32 kmax;	/* current maximum kernel value		*/
#line 163
    Nap_i32 kmin;	/* current minimum kernel value		*/
#line 163
    int i,j;	/* integer x,y positions in the data space	*/
#line 163
    int m,n,xwo,ywo;
#line 163

#line 163
    if(xSize + 1 < xksize || ySize + 1 < yksize) {
#line 163
        return(-1);
#line 163
    }
#line 163

#line 163
    xlag = xSize - xksize + 1;
#line 163
    ylag = ySize - yksize + 1;
#line 163

#line 163
/*
#line 163
 * Put the result as close to the center of the
#line 163
 * sliding window as possible
#line 163
 */
#line 163
    xwo = (xksize - 1)/2;
#line 163
    ywo = (yksize - 1)/2;
#line 163
    resultOffset = ywo*xSize + xwo;
#line 163

#line 163
/*
#line 163
 * Clear regions the window is not going to write to.
#line 163
 */
#line 163

#line 163
    lineOutPtr = out;
#line 163
    for(i=0; i < ySize; i++) {
#line 163
        pixelOutPtr = lineOutPtr;
#line 163
        if(i < ywo || i >= (ylag + ywo)) {
#line 163
            for(j=0; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_I32_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
        } else {
#line 163
            for(j=0; j < xwo; j++) {
#line 163
                *pixelOutPtr = NAP_I32_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
            pixelOutPtr = lineOutPtr + xlag + xwo;
#line 163
            for(j=xlag+xwo; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_I32_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163

#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
    }
#line 163

#line 163
    lineInPtr = in;
#line 163
    lineOutPtr = out;
#line 163
    lineOutPtr = lineOutPtr + resultOffset;
#line 163
    for(i=0; i < ylag; i++) {
#line 163
        pixelPtr = lineInPtr;
#line 163
        for(j=0; j < xlag; j++) {
#line 163
/*
#line 163
 * At this point we are positioned at some i,j pixel
#line 163
 * in the input data array. The i,j represents the
#line 163
 * top left corner of the operator kernel.
#line 163
 */
#line 163
            m = 0;
#line 163
            klinePtr = pixelPtr;
#line 163
            kpixelPtr = pixelPtr;
#line 163
/* case here */
#line 163
            kmax = kmin = *kpixelPtr;
#line 163
            for(m=0; m < yksize; m++) {
#line 163
                for(n=0; n < xksize; n++) {
#line 163
                    if(*kpixelPtr > kmax) kmax = *kpixelPtr;
#line 163
                    if(*kpixelPtr < kmin) kmin = *kpixelPtr;
#line 163
                    kpixelPtr++;
#line 163
                }
#line 163
                klinePtr = klinePtr + xSize;
#line 163
                kpixelPtr = klinePtr;
#line 163
            }
#line 163
/*
#line 163
 * Put the result somewhere!
#line 163
 */
#line 163
            pixelOutPtr = lineOutPtr + j;
#line 163
            *pixelOutPtr = kmax - kmin;
#line 163
/*
#line 163
 * Move to the next pixel position
#line 163
 */
#line 163
            pixelPtr++;
#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
        lineInPtr = lineInPtr + xSize;
#line 163
    }
#line 163
    return(0);
#line 163
}
#line 163

#line 163

#line 163

#line 163

#line 163

#line 163
static int
#line 163
movrange_F32(
#line 163
    void *in,		/* input data array	*/
#line 163
    size_t ySize,	/* ysize		*/
#line 163
    size_t xSize,	/* xsize		*/
#line 163
    size_t yksize,	/* ysize of the kernel	*/
#line 163
    size_t xksize,	/* xsize of the kernel	*/
#line 163
    void *out		/* output data array	*/
#line 163
)
#line 163

#line 163
{
#line 163
    size_t xlag;	/* number of x steps across the input data	*/
#line 163
    size_t ylag;	/* number of y steps across the input data	*/
#line 163
    size_t resultOffset;	/* amount to offset result wrt kernel	*/
#line 163
    Nap_f32 *pixelPtr;	/* current input pixelpointer	*/
#line 163
    Nap_f32 *lineInPtr;	/* current input line pointer 	*/ 
#line 163
    Nap_f32 *pixelOutPtr;	/* current output pixel pointer	*/ 
#line 163
    Nap_f32 *lineOutPtr;	/* current output line pointer	*/ 
#line 163
    Nap_f32 *kpixelPtr;	/* pixel pointer  current window area */
#line 163
    Nap_f32 *klinePtr;	/* line pointer inthe window area */
#line 163
    Nap_f32 kmax;	/* current maximum kernel value		*/
#line 163
    Nap_f32 kmin;	/* current minimum kernel value		*/
#line 163
    int i,j;	/* integer x,y positions in the data space	*/
#line 163
    int m,n,xwo,ywo;
#line 163

#line 163
    if(xSize + 1 < xksize || ySize + 1 < yksize) {
#line 163
        return(-1);
#line 163
    }
#line 163

#line 163
    xlag = xSize - xksize + 1;
#line 163
    ylag = ySize - yksize + 1;
#line 163

#line 163
/*
#line 163
 * Put the result as close to the center of the
#line 163
 * sliding window as possible
#line 163
 */
#line 163
    xwo = (xksize - 1)/2;
#line 163
    ywo = (yksize - 1)/2;
#line 163
    resultOffset = ywo*xSize + xwo;
#line 163

#line 163
/*
#line 163
 * Clear regions the window is not going to write to.
#line 163
 */
#line 163

#line 163
    lineOutPtr = out;
#line 163
    for(i=0; i < ySize; i++) {
#line 163
        pixelOutPtr = lineOutPtr;
#line 163
        if(i < ywo || i >= (ylag + ywo)) {
#line 163
            for(j=0; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_F32_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
        } else {
#line 163
            for(j=0; j < xwo; j++) {
#line 163
                *pixelOutPtr = NAP_F32_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
            pixelOutPtr = lineOutPtr + xlag + xwo;
#line 163
            for(j=xlag+xwo; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_F32_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163

#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
    }
#line 163

#line 163
    lineInPtr = in;
#line 163
    lineOutPtr = out;
#line 163
    lineOutPtr = lineOutPtr + resultOffset;
#line 163
    for(i=0; i < ylag; i++) {
#line 163
        pixelPtr = lineInPtr;
#line 163
        for(j=0; j < xlag; j++) {
#line 163
/*
#line 163
 * At this point we are positioned at some i,j pixel
#line 163
 * in the input data array. The i,j represents the
#line 163
 * top left corner of the operator kernel.
#line 163
 */
#line 163
            m = 0;
#line 163
            klinePtr = pixelPtr;
#line 163
            kpixelPtr = pixelPtr;
#line 163
/* case here */
#line 163
            kmax = kmin = *kpixelPtr;
#line 163
            for(m=0; m < yksize; m++) {
#line 163
                for(n=0; n < xksize; n++) {
#line 163
                    if(*kpixelPtr > kmax) kmax = *kpixelPtr;
#line 163
                    if(*kpixelPtr < kmin) kmin = *kpixelPtr;
#line 163
                    kpixelPtr++;
#line 163
                }
#line 163
                klinePtr = klinePtr + xSize;
#line 163
                kpixelPtr = klinePtr;
#line 163
            }
#line 163
/*
#line 163
 * Put the result somewhere!
#line 163
 */
#line 163
            pixelOutPtr = lineOutPtr + j;
#line 163
            *pixelOutPtr = kmax - kmin;
#line 163
/*
#line 163
 * Move to the next pixel position
#line 163
 */
#line 163
            pixelPtr++;
#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
        lineInPtr = lineInPtr + xSize;
#line 163
    }
#line 163
    return(0);
#line 163
}
#line 163

#line 163

#line 163
static int
#line 163
movrange_F64(
#line 163
    void *in,		/* input data array	*/
#line 163
    size_t ySize,	/* ysize		*/
#line 163
    size_t xSize,	/* xsize		*/
#line 163
    size_t yksize,	/* ysize of the kernel	*/
#line 163
    size_t xksize,	/* xsize of the kernel	*/
#line 163
    void *out		/* output data array	*/
#line 163
)
#line 163

#line 163
{
#line 163
    size_t xlag;	/* number of x steps across the input data	*/
#line 163
    size_t ylag;	/* number of y steps across the input data	*/
#line 163
    size_t resultOffset;	/* amount to offset result wrt kernel	*/
#line 163
    Nap_f64 *pixelPtr;	/* current input pixelpointer	*/
#line 163
    Nap_f64 *lineInPtr;	/* current input line pointer 	*/ 
#line 163
    Nap_f64 *pixelOutPtr;	/* current output pixel pointer	*/ 
#line 163
    Nap_f64 *lineOutPtr;	/* current output line pointer	*/ 
#line 163
    Nap_f64 *kpixelPtr;	/* pixel pointer  current window area */
#line 163
    Nap_f64 *klinePtr;	/* line pointer inthe window area */
#line 163
    Nap_f64 kmax;	/* current maximum kernel value		*/
#line 163
    Nap_f64 kmin;	/* current minimum kernel value		*/
#line 163
    int i,j;	/* integer x,y positions in the data space	*/
#line 163
    int m,n,xwo,ywo;
#line 163

#line 163
    if(xSize + 1 < xksize || ySize + 1 < yksize) {
#line 163
        return(-1);
#line 163
    }
#line 163

#line 163
    xlag = xSize - xksize + 1;
#line 163
    ylag = ySize - yksize + 1;
#line 163

#line 163
/*
#line 163
 * Put the result as close to the center of the
#line 163
 * sliding window as possible
#line 163
 */
#line 163
    xwo = (xksize - 1)/2;
#line 163
    ywo = (yksize - 1)/2;
#line 163
    resultOffset = ywo*xSize + xwo;
#line 163

#line 163
/*
#line 163
 * Clear regions the window is not going to write to.
#line 163
 */
#line 163

#line 163
    lineOutPtr = out;
#line 163
    for(i=0; i < ySize; i++) {
#line 163
        pixelOutPtr = lineOutPtr;
#line 163
        if(i < ywo || i >= (ylag + ywo)) {
#line 163
            for(j=0; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_F64_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
        } else {
#line 163
            for(j=0; j < xwo; j++) {
#line 163
                *pixelOutPtr = NAP_F64_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163
            pixelOutPtr = lineOutPtr + xlag + xwo;
#line 163
            for(j=xlag+xwo; j < xSize; j++) {
#line 163
                *pixelOutPtr = NAP_F64_NULL;
#line 163
                pixelOutPtr++;
#line 163
            }
#line 163

#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
    }
#line 163

#line 163
    lineInPtr = in;
#line 163
    lineOutPtr = out;
#line 163
    lineOutPtr = lineOutPtr + resultOffset;
#line 163
    for(i=0; i < ylag; i++) {
#line 163
        pixelPtr = lineInPtr;
#line 163
        for(j=0; j < xlag; j++) {
#line 163
/*
#line 163
 * At this point we are positioned at some i,j pixel
#line 163
 * in the input data array. The i,j represents the
#line 163
 * top left corner of the operator kernel.
#line 163
 */
#line 163
            m = 0;
#line 163
            klinePtr = pixelPtr;
#line 163
            kpixelPtr = pixelPtr;
#line 163
/* case here */
#line 163
            kmax = kmin = *kpixelPtr;
#line 163
            for(m=0; m < yksize; m++) {
#line 163
                for(n=0; n < xksize; n++) {
#line 163
                    if(*kpixelPtr > kmax) kmax = *kpixelPtr;
#line 163
                    if(*kpixelPtr < kmin) kmin = *kpixelPtr;
#line 163
                    kpixelPtr++;
#line 163
                }
#line 163
                klinePtr = klinePtr + xSize;
#line 163
                kpixelPtr = klinePtr;
#line 163
            }
#line 163
/*
#line 163
 * Put the result somewhere!
#line 163
 */
#line 163
            pixelOutPtr = lineOutPtr + j;
#line 163
            *pixelOutPtr = kmax - kmin;
#line 163
/*
#line 163
 * Move to the next pixel position
#line 163
 */
#line 163
            pixelPtr++;
#line 163
        }
#line 163
        lineOutPtr = lineOutPtr + xSize;
#line 163
        lineInPtr = lineInPtr + xSize;
#line 163
    }
#line 163
    return(0);
#line 163
}
#line 163

#line 163

#line 163


EXTERN char *
Nap_moving_range(
    NapClientData       *nap_cd,
    Nap_NAO		*box_nao)	/* points to user's arguments	*/
{
    Nap_NAO		*in_nao;	/* input array			*/ 
    Nap_NAO		*winShape;	/* window shape			*/ 
    Nap_NAO		*result;	/* output array			*/ 
    Nap_dataType	dataType;
    size_t		shape[3];	/* input data shape -> output   */
    size_t		rank;		/* input data rank -> output	*/
    size_t		yWinSize;	/* sliding window dimension	*/
    size_t		xWinSize;	/* sliding window dimension	*/
    int			i;		/* loop counter			*/
    int			status;


    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    CHECK2NULL(box_nao->rank == 1, "Nap_moving_range: Argument rank not 1");
    CHECK2NULL(box_nao->nels == 2,
             "Nap_moving_range: Usage should be 'maxdiff(data,windowShape)' ");
    in_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    assert(in_nao);
    dataType = in_nao->dataType;
    rank = in_nao->rank;
    CHECK2NULL(rank == 2, "Nap_moving_range: input NAO rank not 2");

    winShape = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(winShape->nels == 2, "Nap_moving_range: window dimensions not 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */
    winShape = Nap_CastNAO(nap_cd, winShape, NAP_I32);
    Nap_IncrRefCount(nap_cd, winShape);

    yWinSize = winShape->data.I32[0];
    xWinSize = winShape->data.I32[1];

    Nap_DecrRefCount(nap_cd, winShape);

    for(i=0; i < rank; i++) {
        shape[i] = in_nao->shape[i];
    }
    result = Nap_NewNAO(nap_cd, dataType, rank, shape);
    CHECK2NULL(result, "Nap_moving_range: error calling Nap_NewNAO");
/*
 * Copy and attach all the input data CV's
 * to the output nao "result".
 */
    status = Nap_CopyDims(nap_cd, in_nao, result);
    CHECK2NULL(status == TCL_OK, "m4Name: Error Calling Nap_CopyDims");

    switch (dataType) {
        
#line 223

#line 223

#line 223

#line 223
        case NAP_U8:
#line 223
	    movrange_U8(in_nao->data.U8, shape[0], shape[1],
#line 223
		    yWinSize,xWinSize, result->data.U8); 
#line 223
            break;
#line 223

#line 223

#line 223
        case NAP_U16:
#line 223
	    movrange_U16(in_nao->data.U16, shape[0], shape[1],
#line 223
		    yWinSize,xWinSize, result->data.U16); 
#line 223
            break;
#line 223

#line 223

#line 223
        case NAP_U32:
#line 223
	    movrange_U32(in_nao->data.U32, shape[0], shape[1],
#line 223
		    yWinSize,xWinSize, result->data.U32); 
#line 223
            break;
#line 223

#line 223

#line 223

#line 223

#line 223
        case NAP_I8:
#line 223
	    movrange_I8(in_nao->data.I8, shape[0], shape[1],
#line 223
		    yWinSize,xWinSize, result->data.I8); 
#line 223
            break;
#line 223

#line 223

#line 223
        case NAP_I16:
#line 223
	    movrange_I16(in_nao->data.I16, shape[0], shape[1],
#line 223
		    yWinSize,xWinSize, result->data.I16); 
#line 223
            break;
#line 223

#line 223

#line 223
        case NAP_I32:
#line 223
	    movrange_I32(in_nao->data.I32, shape[0], shape[1],
#line 223
		    yWinSize,xWinSize, result->data.I32); 
#line 223
            break;
#line 223

#line 223

#line 223

#line 223

#line 223

#line 223
        case NAP_F32:
#line 223
	    movrange_F32(in_nao->data.F32, shape[0], shape[1],
#line 223
		    yWinSize,xWinSize, result->data.F32); 
#line 223
            break;
#line 223

#line 223

#line 223
        case NAP_F64:
#line 223
	    movrange_F64(in_nao->data.F64, shape[0], shape[1],
#line 223
		    yWinSize,xWinSize, result->data.F64); 
#line 223
            break;
#line 223

#line 223

#line 223

        default:		/* Error		*/
            return NULL;
    }

    return result->id;
}

/* Nap_dilate --
 *
 * Perform a dilation operation.
 *
 * Method: Slide the structuring element over all elements in the
 * image undergoing analysis. Where the center of the structure
 * element encounters a non zero value, replicate that value
 * at all non zero structure element positions
 *
 *
 * P.J. Turner, CSIRO Atmospheric Research, August 1999
 */
 
#line 374 "/home/dav480/tcl/nap/generic/napSpatial.c,m4"


#line 375

#line 375

#line 375

#line 375
static int
#line 375
dilate_U8(
#line 375
    Nap_u8 *in,		/* input data array	*/
#line 375
    size_t ySize,	/* ysize		*/
#line 375
    size_t xSize,	/* xsize		*/
#line 375
    Nap_u8 *se,		/* structure element	*/
#line 375
    size_t ySeSize,	/* ysize of the structure element	*/
#line 375
    size_t xSeSize,	/* xsize of the structure element	*/
#line 375
    size_t ySeOrigin,	/* y structure element origin	*/
#line 375
    size_t xSeOrigin,	/* x structure element origin	*/
#line 375
    Nap_u8 *out		/* output data array	*/
#line 375
)
#line 375

#line 375
{
#line 375
    size_t xLag;	/* number of x steps across the input data	*/
#line 375
    size_t yLag;	/* number of y steps across the input data	*/
#line 375
    Nap_u8 *imagePixelInPtr;	/* image pixel pointer	*/ 
#line 375
    Nap_u8 *imageLineInPtr;		/* image line pointer 	*/ 
#line 375
    Nap_u8 *imagePixelOutPtr;	/* output pixel pointer	*/ 
#line 375
    Nap_u8 *imageLineOutPtr;	/* output line pointer	*/ 
#line 375
    Nap_u8 *sePixelPtr;		/* pixel pointer se	*/
#line 375
    Nap_u8 *seLinePtr;		/* line pointer se	*/
#line 375
    Nap_u8 *seImageLineInPtr;	/* image line pointer se */ 
#line 375
    Nap_u8 *seImageLineOutPtr; 	/* output line pointer se */
#line 375
    Nap_u8 *seImagePixelOutPtr;	/* output pixel pointer se */
#line 375
    Nap_u8 seImageOriginValue;	/* image value at se origin */
#line 375
    int i,j;	/* integer x,y positions in the data space	*/
#line 375
    int m,n;
#line 375
   
#line 375
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 375
        return(-1);
#line 375
    }
#line 375

#line 375
    xLag = xSize - xSeSize + 1;
#line 375
    yLag = ySize - ySeSize + 1;
#line 375

#line 375
/* 
#line 375
 * We have to zero everything in the output first !
#line 375
 */
#line 375
    
#line 375
    imageLineOutPtr = out;
#line 375
    for(i=0; i < ySize; i++) {
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xSize; j++) {
#line 375
            *imagePixelOutPtr = 0.0;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375

#line 375
/*
#line 375
 * Calculate the result offset !
#line 375
 */
#line 375

#line 375
    imageLineInPtr = in;
#line 375
    imageLineOutPtr = out;
#line 375

#line 375
    for(i=0; i < yLag; i++) {
#line 375
        imagePixelInPtr = imageLineInPtr;
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xLag; j++) {
#line 375
/*
#line 375
 * At this point we are positioned at some i,j pixel
#line 375
 * in the input data array. The i,j represents the
#line 375
 * top left corner of the operator kernel.
#line 375
 *
#line 375
 * Test to see if the origin structure element position
#line 375
 * in the image is > 0. If this test is true set all the
#line 375
 * values in the image corresponding to no zero values in the structure
#line 375
 * element to the image value.
#line 375
 */
#line 375

#line 375
/* 
#line 375
 * START of Structure element Block!
#line 375
 */
#line 375

#line 375
            seImageLineInPtr = imagePixelInPtr;
#line 375
            seImageLineOutPtr = imagePixelOutPtr;
#line 375

#line 375
            seImageOriginValue = *(seImageLineInPtr + ySeOrigin*xSize + xSeOrigin);
#line 375
            if(seImageOriginValue > 0.0) {
#line 375
                seLinePtr = se;
#line 375
                for(m=0; m < ySeSize; m++) {
#line 375
                    seImagePixelOutPtr = seImageLineOutPtr;
#line 375
                    sePixelPtr = seLinePtr;
#line 375
                    for(n=0; n < xSeSize; n++) {
#line 375
                        if(*sePixelPtr > 0.0) {
#line 375
                            *seImagePixelOutPtr = seImageOriginValue;
#line 375
                        }
#line 375
                        sePixelPtr++;
#line 375
                        seImagePixelOutPtr++;
#line 375
                    }
#line 375
                    seLinePtr = seLinePtr + xSeSize;
#line 375
                    seImageLineOutPtr = seImageLineOutPtr + xSize;
#line 375
                }
#line 375
            }
#line 375

#line 375
/*
#line 375
 * END of Structure Element Block !
#line 375
 */
#line 375

#line 375
/*
#line 375
 * Move to the next image pixel position
#line 375
 */
#line 375
            imagePixelInPtr++;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
/*
#line 375
 * increment according to line length
#line 375
 */
#line 375
        imageLineInPtr =  imageLineInPtr  + xSize;
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375
    return(0);
#line 375
}
#line 375

#line 375

#line 375
static int
#line 375
dilate_U16(
#line 375
    Nap_u16 *in,		/* input data array	*/
#line 375
    size_t ySize,	/* ysize		*/
#line 375
    size_t xSize,	/* xsize		*/
#line 375
    Nap_u16 *se,		/* structure element	*/
#line 375
    size_t ySeSize,	/* ysize of the structure element	*/
#line 375
    size_t xSeSize,	/* xsize of the structure element	*/
#line 375
    size_t ySeOrigin,	/* y structure element origin	*/
#line 375
    size_t xSeOrigin,	/* x structure element origin	*/
#line 375
    Nap_u16 *out		/* output data array	*/
#line 375
)
#line 375

#line 375
{
#line 375
    size_t xLag;	/* number of x steps across the input data	*/
#line 375
    size_t yLag;	/* number of y steps across the input data	*/
#line 375
    Nap_u16 *imagePixelInPtr;	/* image pixel pointer	*/ 
#line 375
    Nap_u16 *imageLineInPtr;		/* image line pointer 	*/ 
#line 375
    Nap_u16 *imagePixelOutPtr;	/* output pixel pointer	*/ 
#line 375
    Nap_u16 *imageLineOutPtr;	/* output line pointer	*/ 
#line 375
    Nap_u16 *sePixelPtr;		/* pixel pointer se	*/
#line 375
    Nap_u16 *seLinePtr;		/* line pointer se	*/
#line 375
    Nap_u16 *seImageLineInPtr;	/* image line pointer se */ 
#line 375
    Nap_u16 *seImageLineOutPtr; 	/* output line pointer se */
#line 375
    Nap_u16 *seImagePixelOutPtr;	/* output pixel pointer se */
#line 375
    Nap_u16 seImageOriginValue;	/* image value at se origin */
#line 375
    int i,j;	/* integer x,y positions in the data space	*/
#line 375
    int m,n;
#line 375
   
#line 375
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 375
        return(-1);
#line 375
    }
#line 375

#line 375
    xLag = xSize - xSeSize + 1;
#line 375
    yLag = ySize - ySeSize + 1;
#line 375

#line 375
/* 
#line 375
 * We have to zero everything in the output first !
#line 375
 */
#line 375
    
#line 375
    imageLineOutPtr = out;
#line 375
    for(i=0; i < ySize; i++) {
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xSize; j++) {
#line 375
            *imagePixelOutPtr = 0.0;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375

#line 375
/*
#line 375
 * Calculate the result offset !
#line 375
 */
#line 375

#line 375
    imageLineInPtr = in;
#line 375
    imageLineOutPtr = out;
#line 375

#line 375
    for(i=0; i < yLag; i++) {
#line 375
        imagePixelInPtr = imageLineInPtr;
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xLag; j++) {
#line 375
/*
#line 375
 * At this point we are positioned at some i,j pixel
#line 375
 * in the input data array. The i,j represents the
#line 375
 * top left corner of the operator kernel.
#line 375
 *
#line 375
 * Test to see if the origin structure element position
#line 375
 * in the image is > 0. If this test is true set all the
#line 375
 * values in the image corresponding to no zero values in the structure
#line 375
 * element to the image value.
#line 375
 */
#line 375

#line 375
/* 
#line 375
 * START of Structure element Block!
#line 375
 */
#line 375

#line 375
            seImageLineInPtr = imagePixelInPtr;
#line 375
            seImageLineOutPtr = imagePixelOutPtr;
#line 375

#line 375
            seImageOriginValue = *(seImageLineInPtr + ySeOrigin*xSize + xSeOrigin);
#line 375
            if(seImageOriginValue > 0.0) {
#line 375
                seLinePtr = se;
#line 375
                for(m=0; m < ySeSize; m++) {
#line 375
                    seImagePixelOutPtr = seImageLineOutPtr;
#line 375
                    sePixelPtr = seLinePtr;
#line 375
                    for(n=0; n < xSeSize; n++) {
#line 375
                        if(*sePixelPtr > 0.0) {
#line 375
                            *seImagePixelOutPtr = seImageOriginValue;
#line 375
                        }
#line 375
                        sePixelPtr++;
#line 375
                        seImagePixelOutPtr++;
#line 375
                    }
#line 375
                    seLinePtr = seLinePtr + xSeSize;
#line 375
                    seImageLineOutPtr = seImageLineOutPtr + xSize;
#line 375
                }
#line 375
            }
#line 375

#line 375
/*
#line 375
 * END of Structure Element Block !
#line 375
 */
#line 375

#line 375
/*
#line 375
 * Move to the next image pixel position
#line 375
 */
#line 375
            imagePixelInPtr++;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
/*
#line 375
 * increment according to line length
#line 375
 */
#line 375
        imageLineInPtr =  imageLineInPtr  + xSize;
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375
    return(0);
#line 375
}
#line 375

#line 375

#line 375
static int
#line 375
dilate_U32(
#line 375
    Nap_u32 *in,		/* input data array	*/
#line 375
    size_t ySize,	/* ysize		*/
#line 375
    size_t xSize,	/* xsize		*/
#line 375
    Nap_u32 *se,		/* structure element	*/
#line 375
    size_t ySeSize,	/* ysize of the structure element	*/
#line 375
    size_t xSeSize,	/* xsize of the structure element	*/
#line 375
    size_t ySeOrigin,	/* y structure element origin	*/
#line 375
    size_t xSeOrigin,	/* x structure element origin	*/
#line 375
    Nap_u32 *out		/* output data array	*/
#line 375
)
#line 375

#line 375
{
#line 375
    size_t xLag;	/* number of x steps across the input data	*/
#line 375
    size_t yLag;	/* number of y steps across the input data	*/
#line 375
    Nap_u32 *imagePixelInPtr;	/* image pixel pointer	*/ 
#line 375
    Nap_u32 *imageLineInPtr;		/* image line pointer 	*/ 
#line 375
    Nap_u32 *imagePixelOutPtr;	/* output pixel pointer	*/ 
#line 375
    Nap_u32 *imageLineOutPtr;	/* output line pointer	*/ 
#line 375
    Nap_u32 *sePixelPtr;		/* pixel pointer se	*/
#line 375
    Nap_u32 *seLinePtr;		/* line pointer se	*/
#line 375
    Nap_u32 *seImageLineInPtr;	/* image line pointer se */ 
#line 375
    Nap_u32 *seImageLineOutPtr; 	/* output line pointer se */
#line 375
    Nap_u32 *seImagePixelOutPtr;	/* output pixel pointer se */
#line 375
    Nap_u32 seImageOriginValue;	/* image value at se origin */
#line 375
    int i,j;	/* integer x,y positions in the data space	*/
#line 375
    int m,n;
#line 375
   
#line 375
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 375
        return(-1);
#line 375
    }
#line 375

#line 375
    xLag = xSize - xSeSize + 1;
#line 375
    yLag = ySize - ySeSize + 1;
#line 375

#line 375
/* 
#line 375
 * We have to zero everything in the output first !
#line 375
 */
#line 375
    
#line 375
    imageLineOutPtr = out;
#line 375
    for(i=0; i < ySize; i++) {
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xSize; j++) {
#line 375
            *imagePixelOutPtr = 0.0;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375

#line 375
/*
#line 375
 * Calculate the result offset !
#line 375
 */
#line 375

#line 375
    imageLineInPtr = in;
#line 375
    imageLineOutPtr = out;
#line 375

#line 375
    for(i=0; i < yLag; i++) {
#line 375
        imagePixelInPtr = imageLineInPtr;
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xLag; j++) {
#line 375
/*
#line 375
 * At this point we are positioned at some i,j pixel
#line 375
 * in the input data array. The i,j represents the
#line 375
 * top left corner of the operator kernel.
#line 375
 *
#line 375
 * Test to see if the origin structure element position
#line 375
 * in the image is > 0. If this test is true set all the
#line 375
 * values in the image corresponding to no zero values in the structure
#line 375
 * element to the image value.
#line 375
 */
#line 375

#line 375
/* 
#line 375
 * START of Structure element Block!
#line 375
 */
#line 375

#line 375
            seImageLineInPtr = imagePixelInPtr;
#line 375
            seImageLineOutPtr = imagePixelOutPtr;
#line 375

#line 375
            seImageOriginValue = *(seImageLineInPtr + ySeOrigin*xSize + xSeOrigin);
#line 375
            if(seImageOriginValue > 0.0) {
#line 375
                seLinePtr = se;
#line 375
                for(m=0; m < ySeSize; m++) {
#line 375
                    seImagePixelOutPtr = seImageLineOutPtr;
#line 375
                    sePixelPtr = seLinePtr;
#line 375
                    for(n=0; n < xSeSize; n++) {
#line 375
                        if(*sePixelPtr > 0.0) {
#line 375
                            *seImagePixelOutPtr = seImageOriginValue;
#line 375
                        }
#line 375
                        sePixelPtr++;
#line 375
                        seImagePixelOutPtr++;
#line 375
                    }
#line 375
                    seLinePtr = seLinePtr + xSeSize;
#line 375
                    seImageLineOutPtr = seImageLineOutPtr + xSize;
#line 375
                }
#line 375
            }
#line 375

#line 375
/*
#line 375
 * END of Structure Element Block !
#line 375
 */
#line 375

#line 375
/*
#line 375
 * Move to the next image pixel position
#line 375
 */
#line 375
            imagePixelInPtr++;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
/*
#line 375
 * increment according to line length
#line 375
 */
#line 375
        imageLineInPtr =  imageLineInPtr  + xSize;
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375
    return(0);
#line 375
}
#line 375

#line 375

#line 375

#line 375

#line 375
static int
#line 375
dilate_I8(
#line 375
    Nap_i8 *in,		/* input data array	*/
#line 375
    size_t ySize,	/* ysize		*/
#line 375
    size_t xSize,	/* xsize		*/
#line 375
    Nap_i8 *se,		/* structure element	*/
#line 375
    size_t ySeSize,	/* ysize of the structure element	*/
#line 375
    size_t xSeSize,	/* xsize of the structure element	*/
#line 375
    size_t ySeOrigin,	/* y structure element origin	*/
#line 375
    size_t xSeOrigin,	/* x structure element origin	*/
#line 375
    Nap_i8 *out		/* output data array	*/
#line 375
)
#line 375

#line 375
{
#line 375
    size_t xLag;	/* number of x steps across the input data	*/
#line 375
    size_t yLag;	/* number of y steps across the input data	*/
#line 375
    Nap_i8 *imagePixelInPtr;	/* image pixel pointer	*/ 
#line 375
    Nap_i8 *imageLineInPtr;		/* image line pointer 	*/ 
#line 375
    Nap_i8 *imagePixelOutPtr;	/* output pixel pointer	*/ 
#line 375
    Nap_i8 *imageLineOutPtr;	/* output line pointer	*/ 
#line 375
    Nap_i8 *sePixelPtr;		/* pixel pointer se	*/
#line 375
    Nap_i8 *seLinePtr;		/* line pointer se	*/
#line 375
    Nap_i8 *seImageLineInPtr;	/* image line pointer se */ 
#line 375
    Nap_i8 *seImageLineOutPtr; 	/* output line pointer se */
#line 375
    Nap_i8 *seImagePixelOutPtr;	/* output pixel pointer se */
#line 375
    Nap_i8 seImageOriginValue;	/* image value at se origin */
#line 375
    int i,j;	/* integer x,y positions in the data space	*/
#line 375
    int m,n;
#line 375
   
#line 375
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 375
        return(-1);
#line 375
    }
#line 375

#line 375
    xLag = xSize - xSeSize + 1;
#line 375
    yLag = ySize - ySeSize + 1;
#line 375

#line 375
/* 
#line 375
 * We have to zero everything in the output first !
#line 375
 */
#line 375
    
#line 375
    imageLineOutPtr = out;
#line 375
    for(i=0; i < ySize; i++) {
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xSize; j++) {
#line 375
            *imagePixelOutPtr = 0.0;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375

#line 375
/*
#line 375
 * Calculate the result offset !
#line 375
 */
#line 375

#line 375
    imageLineInPtr = in;
#line 375
    imageLineOutPtr = out;
#line 375

#line 375
    for(i=0; i < yLag; i++) {
#line 375
        imagePixelInPtr = imageLineInPtr;
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xLag; j++) {
#line 375
/*
#line 375
 * At this point we are positioned at some i,j pixel
#line 375
 * in the input data array. The i,j represents the
#line 375
 * top left corner of the operator kernel.
#line 375
 *
#line 375
 * Test to see if the origin structure element position
#line 375
 * in the image is > 0. If this test is true set all the
#line 375
 * values in the image corresponding to no zero values in the structure
#line 375
 * element to the image value.
#line 375
 */
#line 375

#line 375
/* 
#line 375
 * START of Structure element Block!
#line 375
 */
#line 375

#line 375
            seImageLineInPtr = imagePixelInPtr;
#line 375
            seImageLineOutPtr = imagePixelOutPtr;
#line 375

#line 375
            seImageOriginValue = *(seImageLineInPtr + ySeOrigin*xSize + xSeOrigin);
#line 375
            if(seImageOriginValue > 0.0) {
#line 375
                seLinePtr = se;
#line 375
                for(m=0; m < ySeSize; m++) {
#line 375
                    seImagePixelOutPtr = seImageLineOutPtr;
#line 375
                    sePixelPtr = seLinePtr;
#line 375
                    for(n=0; n < xSeSize; n++) {
#line 375
                        if(*sePixelPtr > 0.0) {
#line 375
                            *seImagePixelOutPtr = seImageOriginValue;
#line 375
                        }
#line 375
                        sePixelPtr++;
#line 375
                        seImagePixelOutPtr++;
#line 375
                    }
#line 375
                    seLinePtr = seLinePtr + xSeSize;
#line 375
                    seImageLineOutPtr = seImageLineOutPtr + xSize;
#line 375
                }
#line 375
            }
#line 375

#line 375
/*
#line 375
 * END of Structure Element Block !
#line 375
 */
#line 375

#line 375
/*
#line 375
 * Move to the next image pixel position
#line 375
 */
#line 375
            imagePixelInPtr++;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
/*
#line 375
 * increment according to line length
#line 375
 */
#line 375
        imageLineInPtr =  imageLineInPtr  + xSize;
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375
    return(0);
#line 375
}
#line 375

#line 375

#line 375
static int
#line 375
dilate_I16(
#line 375
    Nap_i16 *in,		/* input data array	*/
#line 375
    size_t ySize,	/* ysize		*/
#line 375
    size_t xSize,	/* xsize		*/
#line 375
    Nap_i16 *se,		/* structure element	*/
#line 375
    size_t ySeSize,	/* ysize of the structure element	*/
#line 375
    size_t xSeSize,	/* xsize of the structure element	*/
#line 375
    size_t ySeOrigin,	/* y structure element origin	*/
#line 375
    size_t xSeOrigin,	/* x structure element origin	*/
#line 375
    Nap_i16 *out		/* output data array	*/
#line 375
)
#line 375

#line 375
{
#line 375
    size_t xLag;	/* number of x steps across the input data	*/
#line 375
    size_t yLag;	/* number of y steps across the input data	*/
#line 375
    Nap_i16 *imagePixelInPtr;	/* image pixel pointer	*/ 
#line 375
    Nap_i16 *imageLineInPtr;		/* image line pointer 	*/ 
#line 375
    Nap_i16 *imagePixelOutPtr;	/* output pixel pointer	*/ 
#line 375
    Nap_i16 *imageLineOutPtr;	/* output line pointer	*/ 
#line 375
    Nap_i16 *sePixelPtr;		/* pixel pointer se	*/
#line 375
    Nap_i16 *seLinePtr;		/* line pointer se	*/
#line 375
    Nap_i16 *seImageLineInPtr;	/* image line pointer se */ 
#line 375
    Nap_i16 *seImageLineOutPtr; 	/* output line pointer se */
#line 375
    Nap_i16 *seImagePixelOutPtr;	/* output pixel pointer se */
#line 375
    Nap_i16 seImageOriginValue;	/* image value at se origin */
#line 375
    int i,j;	/* integer x,y positions in the data space	*/
#line 375
    int m,n;
#line 375
   
#line 375
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 375
        return(-1);
#line 375
    }
#line 375

#line 375
    xLag = xSize - xSeSize + 1;
#line 375
    yLag = ySize - ySeSize + 1;
#line 375

#line 375
/* 
#line 375
 * We have to zero everything in the output first !
#line 375
 */
#line 375
    
#line 375
    imageLineOutPtr = out;
#line 375
    for(i=0; i < ySize; i++) {
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xSize; j++) {
#line 375
            *imagePixelOutPtr = 0.0;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375

#line 375
/*
#line 375
 * Calculate the result offset !
#line 375
 */
#line 375

#line 375
    imageLineInPtr = in;
#line 375
    imageLineOutPtr = out;
#line 375

#line 375
    for(i=0; i < yLag; i++) {
#line 375
        imagePixelInPtr = imageLineInPtr;
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xLag; j++) {
#line 375
/*
#line 375
 * At this point we are positioned at some i,j pixel
#line 375
 * in the input data array. The i,j represents the
#line 375
 * top left corner of the operator kernel.
#line 375
 *
#line 375
 * Test to see if the origin structure element position
#line 375
 * in the image is > 0. If this test is true set all the
#line 375
 * values in the image corresponding to no zero values in the structure
#line 375
 * element to the image value.
#line 375
 */
#line 375

#line 375
/* 
#line 375
 * START of Structure element Block!
#line 375
 */
#line 375

#line 375
            seImageLineInPtr = imagePixelInPtr;
#line 375
            seImageLineOutPtr = imagePixelOutPtr;
#line 375

#line 375
            seImageOriginValue = *(seImageLineInPtr + ySeOrigin*xSize + xSeOrigin);
#line 375
            if(seImageOriginValue > 0.0) {
#line 375
                seLinePtr = se;
#line 375
                for(m=0; m < ySeSize; m++) {
#line 375
                    seImagePixelOutPtr = seImageLineOutPtr;
#line 375
                    sePixelPtr = seLinePtr;
#line 375
                    for(n=0; n < xSeSize; n++) {
#line 375
                        if(*sePixelPtr > 0.0) {
#line 375
                            *seImagePixelOutPtr = seImageOriginValue;
#line 375
                        }
#line 375
                        sePixelPtr++;
#line 375
                        seImagePixelOutPtr++;
#line 375
                    }
#line 375
                    seLinePtr = seLinePtr + xSeSize;
#line 375
                    seImageLineOutPtr = seImageLineOutPtr + xSize;
#line 375
                }
#line 375
            }
#line 375

#line 375
/*
#line 375
 * END of Structure Element Block !
#line 375
 */
#line 375

#line 375
/*
#line 375
 * Move to the next image pixel position
#line 375
 */
#line 375
            imagePixelInPtr++;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
/*
#line 375
 * increment according to line length
#line 375
 */
#line 375
        imageLineInPtr =  imageLineInPtr  + xSize;
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375
    return(0);
#line 375
}
#line 375

#line 375

#line 375
static int
#line 375
dilate_I32(
#line 375
    Nap_i32 *in,		/* input data array	*/
#line 375
    size_t ySize,	/* ysize		*/
#line 375
    size_t xSize,	/* xsize		*/
#line 375
    Nap_i32 *se,		/* structure element	*/
#line 375
    size_t ySeSize,	/* ysize of the structure element	*/
#line 375
    size_t xSeSize,	/* xsize of the structure element	*/
#line 375
    size_t ySeOrigin,	/* y structure element origin	*/
#line 375
    size_t xSeOrigin,	/* x structure element origin	*/
#line 375
    Nap_i32 *out		/* output data array	*/
#line 375
)
#line 375

#line 375
{
#line 375
    size_t xLag;	/* number of x steps across the input data	*/
#line 375
    size_t yLag;	/* number of y steps across the input data	*/
#line 375
    Nap_i32 *imagePixelInPtr;	/* image pixel pointer	*/ 
#line 375
    Nap_i32 *imageLineInPtr;		/* image line pointer 	*/ 
#line 375
    Nap_i32 *imagePixelOutPtr;	/* output pixel pointer	*/ 
#line 375
    Nap_i32 *imageLineOutPtr;	/* output line pointer	*/ 
#line 375
    Nap_i32 *sePixelPtr;		/* pixel pointer se	*/
#line 375
    Nap_i32 *seLinePtr;		/* line pointer se	*/
#line 375
    Nap_i32 *seImageLineInPtr;	/* image line pointer se */ 
#line 375
    Nap_i32 *seImageLineOutPtr; 	/* output line pointer se */
#line 375
    Nap_i32 *seImagePixelOutPtr;	/* output pixel pointer se */
#line 375
    Nap_i32 seImageOriginValue;	/* image value at se origin */
#line 375
    int i,j;	/* integer x,y positions in the data space	*/
#line 375
    int m,n;
#line 375
   
#line 375
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 375
        return(-1);
#line 375
    }
#line 375

#line 375
    xLag = xSize - xSeSize + 1;
#line 375
    yLag = ySize - ySeSize + 1;
#line 375

#line 375
/* 
#line 375
 * We have to zero everything in the output first !
#line 375
 */
#line 375
    
#line 375
    imageLineOutPtr = out;
#line 375
    for(i=0; i < ySize; i++) {
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xSize; j++) {
#line 375
            *imagePixelOutPtr = 0.0;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375

#line 375
/*
#line 375
 * Calculate the result offset !
#line 375
 */
#line 375

#line 375
    imageLineInPtr = in;
#line 375
    imageLineOutPtr = out;
#line 375

#line 375
    for(i=0; i < yLag; i++) {
#line 375
        imagePixelInPtr = imageLineInPtr;
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xLag; j++) {
#line 375
/*
#line 375
 * At this point we are positioned at some i,j pixel
#line 375
 * in the input data array. The i,j represents the
#line 375
 * top left corner of the operator kernel.
#line 375
 *
#line 375
 * Test to see if the origin structure element position
#line 375
 * in the image is > 0. If this test is true set all the
#line 375
 * values in the image corresponding to no zero values in the structure
#line 375
 * element to the image value.
#line 375
 */
#line 375

#line 375
/* 
#line 375
 * START of Structure element Block!
#line 375
 */
#line 375

#line 375
            seImageLineInPtr = imagePixelInPtr;
#line 375
            seImageLineOutPtr = imagePixelOutPtr;
#line 375

#line 375
            seImageOriginValue = *(seImageLineInPtr + ySeOrigin*xSize + xSeOrigin);
#line 375
            if(seImageOriginValue > 0.0) {
#line 375
                seLinePtr = se;
#line 375
                for(m=0; m < ySeSize; m++) {
#line 375
                    seImagePixelOutPtr = seImageLineOutPtr;
#line 375
                    sePixelPtr = seLinePtr;
#line 375
                    for(n=0; n < xSeSize; n++) {
#line 375
                        if(*sePixelPtr > 0.0) {
#line 375
                            *seImagePixelOutPtr = seImageOriginValue;
#line 375
                        }
#line 375
                        sePixelPtr++;
#line 375
                        seImagePixelOutPtr++;
#line 375
                    }
#line 375
                    seLinePtr = seLinePtr + xSeSize;
#line 375
                    seImageLineOutPtr = seImageLineOutPtr + xSize;
#line 375
                }
#line 375
            }
#line 375

#line 375
/*
#line 375
 * END of Structure Element Block !
#line 375
 */
#line 375

#line 375
/*
#line 375
 * Move to the next image pixel position
#line 375
 */
#line 375
            imagePixelInPtr++;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
/*
#line 375
 * increment according to line length
#line 375
 */
#line 375
        imageLineInPtr =  imageLineInPtr  + xSize;
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375
    return(0);
#line 375
}
#line 375

#line 375

#line 375

#line 375

#line 375

#line 375
static int
#line 375
dilate_F32(
#line 375
    Nap_f32 *in,		/* input data array	*/
#line 375
    size_t ySize,	/* ysize		*/
#line 375
    size_t xSize,	/* xsize		*/
#line 375
    Nap_f32 *se,		/* structure element	*/
#line 375
    size_t ySeSize,	/* ysize of the structure element	*/
#line 375
    size_t xSeSize,	/* xsize of the structure element	*/
#line 375
    size_t ySeOrigin,	/* y structure element origin	*/
#line 375
    size_t xSeOrigin,	/* x structure element origin	*/
#line 375
    Nap_f32 *out		/* output data array	*/
#line 375
)
#line 375

#line 375
{
#line 375
    size_t xLag;	/* number of x steps across the input data	*/
#line 375
    size_t yLag;	/* number of y steps across the input data	*/
#line 375
    Nap_f32 *imagePixelInPtr;	/* image pixel pointer	*/ 
#line 375
    Nap_f32 *imageLineInPtr;		/* image line pointer 	*/ 
#line 375
    Nap_f32 *imagePixelOutPtr;	/* output pixel pointer	*/ 
#line 375
    Nap_f32 *imageLineOutPtr;	/* output line pointer	*/ 
#line 375
    Nap_f32 *sePixelPtr;		/* pixel pointer se	*/
#line 375
    Nap_f32 *seLinePtr;		/* line pointer se	*/
#line 375
    Nap_f32 *seImageLineInPtr;	/* image line pointer se */ 
#line 375
    Nap_f32 *seImageLineOutPtr; 	/* output line pointer se */
#line 375
    Nap_f32 *seImagePixelOutPtr;	/* output pixel pointer se */
#line 375
    Nap_f32 seImageOriginValue;	/* image value at se origin */
#line 375
    int i,j;	/* integer x,y positions in the data space	*/
#line 375
    int m,n;
#line 375
   
#line 375
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 375
        return(-1);
#line 375
    }
#line 375

#line 375
    xLag = xSize - xSeSize + 1;
#line 375
    yLag = ySize - ySeSize + 1;
#line 375

#line 375
/* 
#line 375
 * We have to zero everything in the output first !
#line 375
 */
#line 375
    
#line 375
    imageLineOutPtr = out;
#line 375
    for(i=0; i < ySize; i++) {
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xSize; j++) {
#line 375
            *imagePixelOutPtr = 0.0;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375

#line 375
/*
#line 375
 * Calculate the result offset !
#line 375
 */
#line 375

#line 375
    imageLineInPtr = in;
#line 375
    imageLineOutPtr = out;
#line 375

#line 375
    for(i=0; i < yLag; i++) {
#line 375
        imagePixelInPtr = imageLineInPtr;
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xLag; j++) {
#line 375
/*
#line 375
 * At this point we are positioned at some i,j pixel
#line 375
 * in the input data array. The i,j represents the
#line 375
 * top left corner of the operator kernel.
#line 375
 *
#line 375
 * Test to see if the origin structure element position
#line 375
 * in the image is > 0. If this test is true set all the
#line 375
 * values in the image corresponding to no zero values in the structure
#line 375
 * element to the image value.
#line 375
 */
#line 375

#line 375
/* 
#line 375
 * START of Structure element Block!
#line 375
 */
#line 375

#line 375
            seImageLineInPtr = imagePixelInPtr;
#line 375
            seImageLineOutPtr = imagePixelOutPtr;
#line 375

#line 375
            seImageOriginValue = *(seImageLineInPtr + ySeOrigin*xSize + xSeOrigin);
#line 375
            if(seImageOriginValue > 0.0) {
#line 375
                seLinePtr = se;
#line 375
                for(m=0; m < ySeSize; m++) {
#line 375
                    seImagePixelOutPtr = seImageLineOutPtr;
#line 375
                    sePixelPtr = seLinePtr;
#line 375
                    for(n=0; n < xSeSize; n++) {
#line 375
                        if(*sePixelPtr > 0.0) {
#line 375
                            *seImagePixelOutPtr = seImageOriginValue;
#line 375
                        }
#line 375
                        sePixelPtr++;
#line 375
                        seImagePixelOutPtr++;
#line 375
                    }
#line 375
                    seLinePtr = seLinePtr + xSeSize;
#line 375
                    seImageLineOutPtr = seImageLineOutPtr + xSize;
#line 375
                }
#line 375
            }
#line 375

#line 375
/*
#line 375
 * END of Structure Element Block !
#line 375
 */
#line 375

#line 375
/*
#line 375
 * Move to the next image pixel position
#line 375
 */
#line 375
            imagePixelInPtr++;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
/*
#line 375
 * increment according to line length
#line 375
 */
#line 375
        imageLineInPtr =  imageLineInPtr  + xSize;
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375
    return(0);
#line 375
}
#line 375

#line 375

#line 375
static int
#line 375
dilate_F64(
#line 375
    Nap_f64 *in,		/* input data array	*/
#line 375
    size_t ySize,	/* ysize		*/
#line 375
    size_t xSize,	/* xsize		*/
#line 375
    Nap_f64 *se,		/* structure element	*/
#line 375
    size_t ySeSize,	/* ysize of the structure element	*/
#line 375
    size_t xSeSize,	/* xsize of the structure element	*/
#line 375
    size_t ySeOrigin,	/* y structure element origin	*/
#line 375
    size_t xSeOrigin,	/* x structure element origin	*/
#line 375
    Nap_f64 *out		/* output data array	*/
#line 375
)
#line 375

#line 375
{
#line 375
    size_t xLag;	/* number of x steps across the input data	*/
#line 375
    size_t yLag;	/* number of y steps across the input data	*/
#line 375
    Nap_f64 *imagePixelInPtr;	/* image pixel pointer	*/ 
#line 375
    Nap_f64 *imageLineInPtr;		/* image line pointer 	*/ 
#line 375
    Nap_f64 *imagePixelOutPtr;	/* output pixel pointer	*/ 
#line 375
    Nap_f64 *imageLineOutPtr;	/* output line pointer	*/ 
#line 375
    Nap_f64 *sePixelPtr;		/* pixel pointer se	*/
#line 375
    Nap_f64 *seLinePtr;		/* line pointer se	*/
#line 375
    Nap_f64 *seImageLineInPtr;	/* image line pointer se */ 
#line 375
    Nap_f64 *seImageLineOutPtr; 	/* output line pointer se */
#line 375
    Nap_f64 *seImagePixelOutPtr;	/* output pixel pointer se */
#line 375
    Nap_f64 seImageOriginValue;	/* image value at se origin */
#line 375
    int i,j;	/* integer x,y positions in the data space	*/
#line 375
    int m,n;
#line 375
   
#line 375
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 375
        return(-1);
#line 375
    }
#line 375

#line 375
    xLag = xSize - xSeSize + 1;
#line 375
    yLag = ySize - ySeSize + 1;
#line 375

#line 375
/* 
#line 375
 * We have to zero everything in the output first !
#line 375
 */
#line 375
    
#line 375
    imageLineOutPtr = out;
#line 375
    for(i=0; i < ySize; i++) {
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xSize; j++) {
#line 375
            *imagePixelOutPtr = 0.0;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375

#line 375
/*
#line 375
 * Calculate the result offset !
#line 375
 */
#line 375

#line 375
    imageLineInPtr = in;
#line 375
    imageLineOutPtr = out;
#line 375

#line 375
    for(i=0; i < yLag; i++) {
#line 375
        imagePixelInPtr = imageLineInPtr;
#line 375
        imagePixelOutPtr = imageLineOutPtr;
#line 375
        for(j=0; j < xLag; j++) {
#line 375
/*
#line 375
 * At this point we are positioned at some i,j pixel
#line 375
 * in the input data array. The i,j represents the
#line 375
 * top left corner of the operator kernel.
#line 375
 *
#line 375
 * Test to see if the origin structure element position
#line 375
 * in the image is > 0. If this test is true set all the
#line 375
 * values in the image corresponding to no zero values in the structure
#line 375
 * element to the image value.
#line 375
 */
#line 375

#line 375
/* 
#line 375
 * START of Structure element Block!
#line 375
 */
#line 375

#line 375
            seImageLineInPtr = imagePixelInPtr;
#line 375
            seImageLineOutPtr = imagePixelOutPtr;
#line 375

#line 375
            seImageOriginValue = *(seImageLineInPtr + ySeOrigin*xSize + xSeOrigin);
#line 375
            if(seImageOriginValue > 0.0) {
#line 375
                seLinePtr = se;
#line 375
                for(m=0; m < ySeSize; m++) {
#line 375
                    seImagePixelOutPtr = seImageLineOutPtr;
#line 375
                    sePixelPtr = seLinePtr;
#line 375
                    for(n=0; n < xSeSize; n++) {
#line 375
                        if(*sePixelPtr > 0.0) {
#line 375
                            *seImagePixelOutPtr = seImageOriginValue;
#line 375
                        }
#line 375
                        sePixelPtr++;
#line 375
                        seImagePixelOutPtr++;
#line 375
                    }
#line 375
                    seLinePtr = seLinePtr + xSeSize;
#line 375
                    seImageLineOutPtr = seImageLineOutPtr + xSize;
#line 375
                }
#line 375
            }
#line 375

#line 375
/*
#line 375
 * END of Structure Element Block !
#line 375
 */
#line 375

#line 375
/*
#line 375
 * Move to the next image pixel position
#line 375
 */
#line 375
            imagePixelInPtr++;
#line 375
            imagePixelOutPtr++;
#line 375
        }
#line 375
/*
#line 375
 * increment according to line length
#line 375
 */
#line 375
        imageLineInPtr =  imageLineInPtr  + xSize;
#line 375
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 375
    }
#line 375
    return(0);
#line 375
}
#line 375

#line 375

#line 375


EXTERN char *
Nap_dilate(
    NapClientData       *nap_cd,
    Nap_NAO		*box_nao)	/* points to user's arguments	*/
{
    Nap_NAO		*in_nao;	/* input array			*/ 
    Nap_NAO		*se_nao;	/* structure element		*/ 
    Nap_NAO		*org_nao;	/* position of se origin	*/
    Nap_NAO		*result;	/* output array			*/ 
    Nap_dataType	dataType;
    size_t		ySize;	/* input data shape -> output   */
    size_t		xSize;	/* input data shape -> output   */
    size_t		rank;		/* input data rank -> output	*/
    size_t		ySeSize;	/* structure element dimension	*/
    size_t		xSeSize;	/* structure element dimension	*/
    size_t		ySeOrigin;	/* structure element dimension	*/
    size_t		shape[3];	/* structure element dimension	*/
    int			status;


    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    CHECK2NULL(box_nao->rank == 1, "Nap_dilate: Argument rank not 1");
    CHECK2NULL(box_nao->nels == 3,
             "Nap_dilate: Usage should be 'dilate(data,structureElement,Origin)' ");
    in_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    CHECK2NULL(in_nao, "Nap_dilate: Error calling Nap_GetNaoFromSlot");
    dataType = in_nao->dataType;
    rank = in_nao->rank;
    shape[0] = ySize = in_nao->shape[0];
    shape[1] = xSize = in_nao->shape[1];

    CHECK2NULL(rank == 2, "Nap_dilate: input NAO rank not 2");

    se_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(se_nao->rank <= 2, "Nap_dilate: structure element dimensions > 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */
    se_nao = Nap_CastNAO(nap_cd, se_nao, dataType);
    Nap_IncrRefCount(nap_cd, se_nao);

    if(se_nao->rank == 1) { 
        xSeSize = se_nao->shape[0];
        ySeSize = 1;
    } else {
        ySeSize = se_nao->shape[0];
        xSeSize = se_nao->shape[1];
    }

    org_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[2]);
    CHECK2NULL(org_nao->nels == 2, "Nap_dilate: origin values not 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */

    org_nao = Nap_CastNAO(nap_cd, org_nao, NAP_I32);
    Nap_IncrRefCount(nap_cd, org_nao);
    CHECK2NULL(org_nao->data.I32[0] >= 0 && org_nao->data.I32[0] < ySeSize,
	    "Nap_dilate: SE y coord outside SE");
    CHECK2NULL(org_nao->data.I32[1] >= 0 && org_nao->data.I32[1] < xSeSize,
	    "Nap_dilate: SE x coord outside SE");

    ySeOrigin = org_nao->data.I32[0];
    Nap_DecrRefCount(nap_cd, org_nao);
    result = Nap_NewNAO(nap_cd, dataType, rank, shape);
    CHECK2NULL(result, "Nap_dilate: error calling Nap_NewNAO");

/*
 * Copy and attach all the input data CV's
 * to the output nao "result".
 */
    status = Nap_CopyDims(nap_cd, in_nao, result);
    CHECK2NULL(status == TCL_OK, "m4Name: Error Calling Nap_CopyDims");

    switch (dataType) {
        
#line 461

#line 461

#line 461

#line 461
        case NAP_U8:
#line 461
	    dilate_U8(in_nao->data.U8, ySize, xSize, se_nao->data.U8, ySeSize, xSeSize, ySeOrigin,
#line 461
		    ySeOrigin, result->data.U8); 
#line 461
            break;
#line 461

#line 461

#line 461
        case NAP_U16:
#line 461
	    dilate_U16(in_nao->data.U16, ySize, xSize, se_nao->data.U16, ySeSize, xSeSize, ySeOrigin,
#line 461
		    ySeOrigin, result->data.U16); 
#line 461
            break;
#line 461

#line 461

#line 461
        case NAP_U32:
#line 461
	    dilate_U32(in_nao->data.U32, ySize, xSize, se_nao->data.U32, ySeSize, xSeSize, ySeOrigin,
#line 461
		    ySeOrigin, result->data.U32); 
#line 461
            break;
#line 461

#line 461

#line 461

#line 461

#line 461
        case NAP_I8:
#line 461
	    dilate_I8(in_nao->data.I8, ySize, xSize, se_nao->data.I8, ySeSize, xSeSize, ySeOrigin,
#line 461
		    ySeOrigin, result->data.I8); 
#line 461
            break;
#line 461

#line 461

#line 461
        case NAP_I16:
#line 461
	    dilate_I16(in_nao->data.I16, ySize, xSize, se_nao->data.I16, ySeSize, xSeSize, ySeOrigin,
#line 461
		    ySeOrigin, result->data.I16); 
#line 461
            break;
#line 461

#line 461

#line 461
        case NAP_I32:
#line 461
	    dilate_I32(in_nao->data.I32, ySize, xSize, se_nao->data.I32, ySeSize, xSeSize, ySeOrigin,
#line 461
		    ySeOrigin, result->data.I32); 
#line 461
            break;
#line 461

#line 461

#line 461

#line 461

#line 461

#line 461
        case NAP_F32:
#line 461
	    dilate_F32(in_nao->data.F32, ySize, xSize, se_nao->data.F32, ySeSize, xSeSize, ySeOrigin,
#line 461
		    ySeOrigin, result->data.F32); 
#line 461
            break;
#line 461

#line 461

#line 461
        case NAP_F64:
#line 461
	    dilate_F64(in_nao->data.F64, ySize, xSize, se_nao->data.F64, ySeSize, xSeSize, ySeOrigin,
#line 461
		    ySeOrigin, result->data.F64); 
#line 461
            break;
#line 461

#line 461

#line 461

        default:		/* Error		*/
            return NULL;
    }

    Nap_DecrRefCount(nap_cd, se_nao);

    return result->id;
}

/* Nap_erode --
 *
 * Perform a erosion operation.
 *
 * Method: Slide the structuring element over all elements in the
 * image undergoing analysis. Where the center of the structure
 * element encounters a non zero value, replicate that value
 * at all non zero structure element positions
 *
 *
 * P.J. Turner, CSIRO Atmospheric Research, August 1999
 */
 
#line 632 "/home/dav480/tcl/nap/generic/napSpatial.c,m4"


#line 633

#line 633

#line 633

#line 633
static int
#line 633
erode_U8(
#line 633
    Nap_u8 *in,	/* input data array			*/
#line 633
    size_t ySize,		/* ysize				*/
#line 633
    size_t xSize,		/* xsize				*/
#line 633
    Nap_u8 *se,	/* structure element			*/
#line 633
    size_t ySeSize,		/* ysize of the structure element	*/
#line 633
    size_t xSeSize,		/* xsize of the structure element	*/
#line 633
    size_t ySeOrigin,		/* y structure element origin		*/
#line 633
    size_t xSeOrigin,		/* x structure element origin		*/
#line 633
    Nap_u8 *out	/* output data arra		y	*/
#line 633
)
#line 633

#line 633
{
#line 633
    size_t xLag;	/* number of x steps across the input data	*/
#line 633
    size_t yLag;	/* number of y steps across the input data	*/
#line 633
    Nap_u8 *imagePixelInPtr; 	/* input pixel		*/ 
#line 633
    Nap_u8 *imageLineInPtr; 	/* input line  		*/ 
#line 633
    Nap_u8 *imagePixelOutPtr; 	/* output pixel		*/ 
#line 633
    Nap_u8 *imageLineOutPtr; 	/* output line 		*/ 
#line 633
    Nap_u8 *sePixelPtr;		/* SE pixel 		*/
#line 633
    Nap_u8 *seLinePtr;		/* SE line 		*/
#line 633
    Nap_u8 *seImageLineInPtr;  /* SE image line   in 	*/ 
#line 633
    Nap_u8 *seImagePixelInPtr; /* SE image pixel  in	*/
#line 633
    size_t seImageOriginOffset; 	/* image value the SE origin	*/
#line 633
    Nap_u8 *fPtr;		/* temporary pointer		*/
#line 633
    int erodeFlag;	/* true implies set the output to 0		*/
#line 633
    int i,j;	/* integer x,y positions in the data space	*/
#line 633
    int m,n;
#line 633
   
#line 633
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 633
        return(-1);
#line 633
    }
#line 633

#line 633
    xLag = xSize - xSeSize + 1;
#line 633
    yLag = ySize - ySeSize + 1;
#line 633

#line 633
/*
#line 633
 * We have to zero everything in the output first !
#line 633
 */
#line 633

#line 633
    imageLineOutPtr = out;
#line 633
    for(i=0; i < ySize; i++) {
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xSize; j++) {
#line 633
            *imagePixelOutPtr = 0.0;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633

#line 633
/*
#line 633
 * Calculate the result offset !
#line 633
 */
#line 633
   
#line 633

#line 633
    imageLineInPtr = in;
#line 633
    imageLineOutPtr = out;
#line 633
    seImageOriginOffset =  ySeOrigin*xSize + xSeOrigin;
#line 633

#line 633
    for(i=0; i < yLag; i++) {
#line 633
        imagePixelInPtr = imageLineInPtr;
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xLag; j++) {
#line 633
/*
#line 633
 * At this point we are positioned at some i,j pixel
#line 633
 * in the input data array. The i,j represents the
#line 633
 * top left corner of the operator kernel.
#line 633
 *
#line 633
 * Test to see if the origin structure element position
#line 633
 * in the image is > 0. If this test is true set all the
#line 633
 * values in the image corresponding to no zero values in the structure
#line 633
 * element to the image value.
#line 633
 */
#line 633

#line 633
/* 
#line 633
 * START of Structure element Block!
#line 633
 */
#line 633

#line 633
            seImageLineInPtr = imagePixelInPtr;
#line 633

#line 633
            seLinePtr = se;
#line 633
            erodeFlag = 0;
#line 633
            for(m=0; m < ySeSize; m++) {
#line 633
                seImagePixelInPtr = seImageLineInPtr;
#line 633
                sePixelPtr = seLinePtr;
#line 633
                for(n=0; n < xSeSize; n++) {
#line 633
                    if(*sePixelPtr > 0.0) {
#line 633
                        if(*seImagePixelInPtr <= 0.0) {
#line 633
                            erodeFlag++;
#line 633
                        }
#line 633
                    }
#line 633
                    sePixelPtr++;
#line 633
                    seImagePixelInPtr++;
#line 633
                }
#line 633
                seLinePtr = seLinePtr + xSeSize;
#line 633
                seImageLineInPtr = seImageLineInPtr + xSize;
#line 633
            }
#line 633

#line 633
/*
#line 633
 * Not sure what to do here! The problem is that if the
#line 633
 * structure element origin is zero and the corresponding
#line 633
 * image element is zero we get no element where we should get one.
#line 633
 */
#line 633
            if(erodeFlag > 0) {
#line 633
                *(imagePixelOutPtr + seImageOriginOffset) = 0.0; 
#line 633
            } else {
#line 633
                fPtr = (imagePixelOutPtr + seImageOriginOffset);
#line 633
                *fPtr = *(imagePixelInPtr + seImageOriginOffset);
#line 633
               if(*fPtr <= 0.0) {
#line 633
                   *fPtr = 1.0;
#line 633
               } 
#line 633
            }
#line 633

#line 633
/*
#line 633
 * END of Structure Element Block !
#line 633
 */
#line 633

#line 633
/*
#line 633
 * Move to the next image pixel position
#line 633
 */
#line 633
            imagePixelInPtr++;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
/*
#line 633
 * increment according to line length
#line 633
 */
#line 633
        imageLineInPtr = imageLineInPtr + xSize;
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633
    return(0);
#line 633
}
#line 633

#line 633

#line 633

#line 633
static int
#line 633
erode_U16(
#line 633
    Nap_u16 *in,	/* input data array			*/
#line 633
    size_t ySize,		/* ysize				*/
#line 633
    size_t xSize,		/* xsize				*/
#line 633
    Nap_u16 *se,	/* structure element			*/
#line 633
    size_t ySeSize,		/* ysize of the structure element	*/
#line 633
    size_t xSeSize,		/* xsize of the structure element	*/
#line 633
    size_t ySeOrigin,		/* y structure element origin		*/
#line 633
    size_t xSeOrigin,		/* x structure element origin		*/
#line 633
    Nap_u16 *out	/* output data arra		y	*/
#line 633
)
#line 633

#line 633
{
#line 633
    size_t xLag;	/* number of x steps across the input data	*/
#line 633
    size_t yLag;	/* number of y steps across the input data	*/
#line 633
    Nap_u16 *imagePixelInPtr; 	/* input pixel		*/ 
#line 633
    Nap_u16 *imageLineInPtr; 	/* input line  		*/ 
#line 633
    Nap_u16 *imagePixelOutPtr; 	/* output pixel		*/ 
#line 633
    Nap_u16 *imageLineOutPtr; 	/* output line 		*/ 
#line 633
    Nap_u16 *sePixelPtr;		/* SE pixel 		*/
#line 633
    Nap_u16 *seLinePtr;		/* SE line 		*/
#line 633
    Nap_u16 *seImageLineInPtr;  /* SE image line   in 	*/ 
#line 633
    Nap_u16 *seImagePixelInPtr; /* SE image pixel  in	*/
#line 633
    size_t seImageOriginOffset; 	/* image value the SE origin	*/
#line 633
    Nap_u16 *fPtr;		/* temporary pointer		*/
#line 633
    int erodeFlag;	/* true implies set the output to 0		*/
#line 633
    int i,j;	/* integer x,y positions in the data space	*/
#line 633
    int m,n;
#line 633
   
#line 633
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 633
        return(-1);
#line 633
    }
#line 633

#line 633
    xLag = xSize - xSeSize + 1;
#line 633
    yLag = ySize - ySeSize + 1;
#line 633

#line 633
/*
#line 633
 * We have to zero everything in the output first !
#line 633
 */
#line 633

#line 633
    imageLineOutPtr = out;
#line 633
    for(i=0; i < ySize; i++) {
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xSize; j++) {
#line 633
            *imagePixelOutPtr = 0.0;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633

#line 633
/*
#line 633
 * Calculate the result offset !
#line 633
 */
#line 633
   
#line 633

#line 633
    imageLineInPtr = in;
#line 633
    imageLineOutPtr = out;
#line 633
    seImageOriginOffset =  ySeOrigin*xSize + xSeOrigin;
#line 633

#line 633
    for(i=0; i < yLag; i++) {
#line 633
        imagePixelInPtr = imageLineInPtr;
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xLag; j++) {
#line 633
/*
#line 633
 * At this point we are positioned at some i,j pixel
#line 633
 * in the input data array. The i,j represents the
#line 633
 * top left corner of the operator kernel.
#line 633
 *
#line 633
 * Test to see if the origin structure element position
#line 633
 * in the image is > 0. If this test is true set all the
#line 633
 * values in the image corresponding to no zero values in the structure
#line 633
 * element to the image value.
#line 633
 */
#line 633

#line 633
/* 
#line 633
 * START of Structure element Block!
#line 633
 */
#line 633

#line 633
            seImageLineInPtr = imagePixelInPtr;
#line 633

#line 633
            seLinePtr = se;
#line 633
            erodeFlag = 0;
#line 633
            for(m=0; m < ySeSize; m++) {
#line 633
                seImagePixelInPtr = seImageLineInPtr;
#line 633
                sePixelPtr = seLinePtr;
#line 633
                for(n=0; n < xSeSize; n++) {
#line 633
                    if(*sePixelPtr > 0.0) {
#line 633
                        if(*seImagePixelInPtr <= 0.0) {
#line 633
                            erodeFlag++;
#line 633
                        }
#line 633
                    }
#line 633
                    sePixelPtr++;
#line 633
                    seImagePixelInPtr++;
#line 633
                }
#line 633
                seLinePtr = seLinePtr + xSeSize;
#line 633
                seImageLineInPtr = seImageLineInPtr + xSize;
#line 633
            }
#line 633

#line 633
/*
#line 633
 * Not sure what to do here! The problem is that if the
#line 633
 * structure element origin is zero and the corresponding
#line 633
 * image element is zero we get no element where we should get one.
#line 633
 */
#line 633
            if(erodeFlag > 0) {
#line 633
                *(imagePixelOutPtr + seImageOriginOffset) = 0.0; 
#line 633
            } else {
#line 633
                fPtr = (imagePixelOutPtr + seImageOriginOffset);
#line 633
                *fPtr = *(imagePixelInPtr + seImageOriginOffset);
#line 633
               if(*fPtr <= 0.0) {
#line 633
                   *fPtr = 1.0;
#line 633
               } 
#line 633
            }
#line 633

#line 633
/*
#line 633
 * END of Structure Element Block !
#line 633
 */
#line 633

#line 633
/*
#line 633
 * Move to the next image pixel position
#line 633
 */
#line 633
            imagePixelInPtr++;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
/*
#line 633
 * increment according to line length
#line 633
 */
#line 633
        imageLineInPtr = imageLineInPtr + xSize;
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633
    return(0);
#line 633
}
#line 633

#line 633

#line 633

#line 633
static int
#line 633
erode_U32(
#line 633
    Nap_u32 *in,	/* input data array			*/
#line 633
    size_t ySize,		/* ysize				*/
#line 633
    size_t xSize,		/* xsize				*/
#line 633
    Nap_u32 *se,	/* structure element			*/
#line 633
    size_t ySeSize,		/* ysize of the structure element	*/
#line 633
    size_t xSeSize,		/* xsize of the structure element	*/
#line 633
    size_t ySeOrigin,		/* y structure element origin		*/
#line 633
    size_t xSeOrigin,		/* x structure element origin		*/
#line 633
    Nap_u32 *out	/* output data arra		y	*/
#line 633
)
#line 633

#line 633
{
#line 633
    size_t xLag;	/* number of x steps across the input data	*/
#line 633
    size_t yLag;	/* number of y steps across the input data	*/
#line 633
    Nap_u32 *imagePixelInPtr; 	/* input pixel		*/ 
#line 633
    Nap_u32 *imageLineInPtr; 	/* input line  		*/ 
#line 633
    Nap_u32 *imagePixelOutPtr; 	/* output pixel		*/ 
#line 633
    Nap_u32 *imageLineOutPtr; 	/* output line 		*/ 
#line 633
    Nap_u32 *sePixelPtr;		/* SE pixel 		*/
#line 633
    Nap_u32 *seLinePtr;		/* SE line 		*/
#line 633
    Nap_u32 *seImageLineInPtr;  /* SE image line   in 	*/ 
#line 633
    Nap_u32 *seImagePixelInPtr; /* SE image pixel  in	*/
#line 633
    size_t seImageOriginOffset; 	/* image value the SE origin	*/
#line 633
    Nap_u32 *fPtr;		/* temporary pointer		*/
#line 633
    int erodeFlag;	/* true implies set the output to 0		*/
#line 633
    int i,j;	/* integer x,y positions in the data space	*/
#line 633
    int m,n;
#line 633
   
#line 633
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 633
        return(-1);
#line 633
    }
#line 633

#line 633
    xLag = xSize - xSeSize + 1;
#line 633
    yLag = ySize - ySeSize + 1;
#line 633

#line 633
/*
#line 633
 * We have to zero everything in the output first !
#line 633
 */
#line 633

#line 633
    imageLineOutPtr = out;
#line 633
    for(i=0; i < ySize; i++) {
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xSize; j++) {
#line 633
            *imagePixelOutPtr = 0.0;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633

#line 633
/*
#line 633
 * Calculate the result offset !
#line 633
 */
#line 633
   
#line 633

#line 633
    imageLineInPtr = in;
#line 633
    imageLineOutPtr = out;
#line 633
    seImageOriginOffset =  ySeOrigin*xSize + xSeOrigin;
#line 633

#line 633
    for(i=0; i < yLag; i++) {
#line 633
        imagePixelInPtr = imageLineInPtr;
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xLag; j++) {
#line 633
/*
#line 633
 * At this point we are positioned at some i,j pixel
#line 633
 * in the input data array. The i,j represents the
#line 633
 * top left corner of the operator kernel.
#line 633
 *
#line 633
 * Test to see if the origin structure element position
#line 633
 * in the image is > 0. If this test is true set all the
#line 633
 * values in the image corresponding to no zero values in the structure
#line 633
 * element to the image value.
#line 633
 */
#line 633

#line 633
/* 
#line 633
 * START of Structure element Block!
#line 633
 */
#line 633

#line 633
            seImageLineInPtr = imagePixelInPtr;
#line 633

#line 633
            seLinePtr = se;
#line 633
            erodeFlag = 0;
#line 633
            for(m=0; m < ySeSize; m++) {
#line 633
                seImagePixelInPtr = seImageLineInPtr;
#line 633
                sePixelPtr = seLinePtr;
#line 633
                for(n=0; n < xSeSize; n++) {
#line 633
                    if(*sePixelPtr > 0.0) {
#line 633
                        if(*seImagePixelInPtr <= 0.0) {
#line 633
                            erodeFlag++;
#line 633
                        }
#line 633
                    }
#line 633
                    sePixelPtr++;
#line 633
                    seImagePixelInPtr++;
#line 633
                }
#line 633
                seLinePtr = seLinePtr + xSeSize;
#line 633
                seImageLineInPtr = seImageLineInPtr + xSize;
#line 633
            }
#line 633

#line 633
/*
#line 633
 * Not sure what to do here! The problem is that if the
#line 633
 * structure element origin is zero and the corresponding
#line 633
 * image element is zero we get no element where we should get one.
#line 633
 */
#line 633
            if(erodeFlag > 0) {
#line 633
                *(imagePixelOutPtr + seImageOriginOffset) = 0.0; 
#line 633
            } else {
#line 633
                fPtr = (imagePixelOutPtr + seImageOriginOffset);
#line 633
                *fPtr = *(imagePixelInPtr + seImageOriginOffset);
#line 633
               if(*fPtr <= 0.0) {
#line 633
                   *fPtr = 1.0;
#line 633
               } 
#line 633
            }
#line 633

#line 633
/*
#line 633
 * END of Structure Element Block !
#line 633
 */
#line 633

#line 633
/*
#line 633
 * Move to the next image pixel position
#line 633
 */
#line 633
            imagePixelInPtr++;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
/*
#line 633
 * increment according to line length
#line 633
 */
#line 633
        imageLineInPtr = imageLineInPtr + xSize;
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633
    return(0);
#line 633
}
#line 633

#line 633

#line 633

#line 633

#line 633

#line 633
static int
#line 633
erode_I8(
#line 633
    Nap_i8 *in,	/* input data array			*/
#line 633
    size_t ySize,		/* ysize				*/
#line 633
    size_t xSize,		/* xsize				*/
#line 633
    Nap_i8 *se,	/* structure element			*/
#line 633
    size_t ySeSize,		/* ysize of the structure element	*/
#line 633
    size_t xSeSize,		/* xsize of the structure element	*/
#line 633
    size_t ySeOrigin,		/* y structure element origin		*/
#line 633
    size_t xSeOrigin,		/* x structure element origin		*/
#line 633
    Nap_i8 *out	/* output data arra		y	*/
#line 633
)
#line 633

#line 633
{
#line 633
    size_t xLag;	/* number of x steps across the input data	*/
#line 633
    size_t yLag;	/* number of y steps across the input data	*/
#line 633
    Nap_i8 *imagePixelInPtr; 	/* input pixel		*/ 
#line 633
    Nap_i8 *imageLineInPtr; 	/* input line  		*/ 
#line 633
    Nap_i8 *imagePixelOutPtr; 	/* output pixel		*/ 
#line 633
    Nap_i8 *imageLineOutPtr; 	/* output line 		*/ 
#line 633
    Nap_i8 *sePixelPtr;		/* SE pixel 		*/
#line 633
    Nap_i8 *seLinePtr;		/* SE line 		*/
#line 633
    Nap_i8 *seImageLineInPtr;  /* SE image line   in 	*/ 
#line 633
    Nap_i8 *seImagePixelInPtr; /* SE image pixel  in	*/
#line 633
    size_t seImageOriginOffset; 	/* image value the SE origin	*/
#line 633
    Nap_i8 *fPtr;		/* temporary pointer		*/
#line 633
    int erodeFlag;	/* true implies set the output to 0		*/
#line 633
    int i,j;	/* integer x,y positions in the data space	*/
#line 633
    int m,n;
#line 633
   
#line 633
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 633
        return(-1);
#line 633
    }
#line 633

#line 633
    xLag = xSize - xSeSize + 1;
#line 633
    yLag = ySize - ySeSize + 1;
#line 633

#line 633
/*
#line 633
 * We have to zero everything in the output first !
#line 633
 */
#line 633

#line 633
    imageLineOutPtr = out;
#line 633
    for(i=0; i < ySize; i++) {
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xSize; j++) {
#line 633
            *imagePixelOutPtr = 0.0;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633

#line 633
/*
#line 633
 * Calculate the result offset !
#line 633
 */
#line 633
   
#line 633

#line 633
    imageLineInPtr = in;
#line 633
    imageLineOutPtr = out;
#line 633
    seImageOriginOffset =  ySeOrigin*xSize + xSeOrigin;
#line 633

#line 633
    for(i=0; i < yLag; i++) {
#line 633
        imagePixelInPtr = imageLineInPtr;
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xLag; j++) {
#line 633
/*
#line 633
 * At this point we are positioned at some i,j pixel
#line 633
 * in the input data array. The i,j represents the
#line 633
 * top left corner of the operator kernel.
#line 633
 *
#line 633
 * Test to see if the origin structure element position
#line 633
 * in the image is > 0. If this test is true set all the
#line 633
 * values in the image corresponding to no zero values in the structure
#line 633
 * element to the image value.
#line 633
 */
#line 633

#line 633
/* 
#line 633
 * START of Structure element Block!
#line 633
 */
#line 633

#line 633
            seImageLineInPtr = imagePixelInPtr;
#line 633

#line 633
            seLinePtr = se;
#line 633
            erodeFlag = 0;
#line 633
            for(m=0; m < ySeSize; m++) {
#line 633
                seImagePixelInPtr = seImageLineInPtr;
#line 633
                sePixelPtr = seLinePtr;
#line 633
                for(n=0; n < xSeSize; n++) {
#line 633
                    if(*sePixelPtr > 0.0) {
#line 633
                        if(*seImagePixelInPtr <= 0.0) {
#line 633
                            erodeFlag++;
#line 633
                        }
#line 633
                    }
#line 633
                    sePixelPtr++;
#line 633
                    seImagePixelInPtr++;
#line 633
                }
#line 633
                seLinePtr = seLinePtr + xSeSize;
#line 633
                seImageLineInPtr = seImageLineInPtr + xSize;
#line 633
            }
#line 633

#line 633
/*
#line 633
 * Not sure what to do here! The problem is that if the
#line 633
 * structure element origin is zero and the corresponding
#line 633
 * image element is zero we get no element where we should get one.
#line 633
 */
#line 633
            if(erodeFlag > 0) {
#line 633
                *(imagePixelOutPtr + seImageOriginOffset) = 0.0; 
#line 633
            } else {
#line 633
                fPtr = (imagePixelOutPtr + seImageOriginOffset);
#line 633
                *fPtr = *(imagePixelInPtr + seImageOriginOffset);
#line 633
               if(*fPtr <= 0.0) {
#line 633
                   *fPtr = 1.0;
#line 633
               } 
#line 633
            }
#line 633

#line 633
/*
#line 633
 * END of Structure Element Block !
#line 633
 */
#line 633

#line 633
/*
#line 633
 * Move to the next image pixel position
#line 633
 */
#line 633
            imagePixelInPtr++;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
/*
#line 633
 * increment according to line length
#line 633
 */
#line 633
        imageLineInPtr = imageLineInPtr + xSize;
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633
    return(0);
#line 633
}
#line 633

#line 633

#line 633

#line 633
static int
#line 633
erode_I16(
#line 633
    Nap_i16 *in,	/* input data array			*/
#line 633
    size_t ySize,		/* ysize				*/
#line 633
    size_t xSize,		/* xsize				*/
#line 633
    Nap_i16 *se,	/* structure element			*/
#line 633
    size_t ySeSize,		/* ysize of the structure element	*/
#line 633
    size_t xSeSize,		/* xsize of the structure element	*/
#line 633
    size_t ySeOrigin,		/* y structure element origin		*/
#line 633
    size_t xSeOrigin,		/* x structure element origin		*/
#line 633
    Nap_i16 *out	/* output data arra		y	*/
#line 633
)
#line 633

#line 633
{
#line 633
    size_t xLag;	/* number of x steps across the input data	*/
#line 633
    size_t yLag;	/* number of y steps across the input data	*/
#line 633
    Nap_i16 *imagePixelInPtr; 	/* input pixel		*/ 
#line 633
    Nap_i16 *imageLineInPtr; 	/* input line  		*/ 
#line 633
    Nap_i16 *imagePixelOutPtr; 	/* output pixel		*/ 
#line 633
    Nap_i16 *imageLineOutPtr; 	/* output line 		*/ 
#line 633
    Nap_i16 *sePixelPtr;		/* SE pixel 		*/
#line 633
    Nap_i16 *seLinePtr;		/* SE line 		*/
#line 633
    Nap_i16 *seImageLineInPtr;  /* SE image line   in 	*/ 
#line 633
    Nap_i16 *seImagePixelInPtr; /* SE image pixel  in	*/
#line 633
    size_t seImageOriginOffset; 	/* image value the SE origin	*/
#line 633
    Nap_i16 *fPtr;		/* temporary pointer		*/
#line 633
    int erodeFlag;	/* true implies set the output to 0		*/
#line 633
    int i,j;	/* integer x,y positions in the data space	*/
#line 633
    int m,n;
#line 633
   
#line 633
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 633
        return(-1);
#line 633
    }
#line 633

#line 633
    xLag = xSize - xSeSize + 1;
#line 633
    yLag = ySize - ySeSize + 1;
#line 633

#line 633
/*
#line 633
 * We have to zero everything in the output first !
#line 633
 */
#line 633

#line 633
    imageLineOutPtr = out;
#line 633
    for(i=0; i < ySize; i++) {
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xSize; j++) {
#line 633
            *imagePixelOutPtr = 0.0;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633

#line 633
/*
#line 633
 * Calculate the result offset !
#line 633
 */
#line 633
   
#line 633

#line 633
    imageLineInPtr = in;
#line 633
    imageLineOutPtr = out;
#line 633
    seImageOriginOffset =  ySeOrigin*xSize + xSeOrigin;
#line 633

#line 633
    for(i=0; i < yLag; i++) {
#line 633
        imagePixelInPtr = imageLineInPtr;
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xLag; j++) {
#line 633
/*
#line 633
 * At this point we are positioned at some i,j pixel
#line 633
 * in the input data array. The i,j represents the
#line 633
 * top left corner of the operator kernel.
#line 633
 *
#line 633
 * Test to see if the origin structure element position
#line 633
 * in the image is > 0. If this test is true set all the
#line 633
 * values in the image corresponding to no zero values in the structure
#line 633
 * element to the image value.
#line 633
 */
#line 633

#line 633
/* 
#line 633
 * START of Structure element Block!
#line 633
 */
#line 633

#line 633
            seImageLineInPtr = imagePixelInPtr;
#line 633

#line 633
            seLinePtr = se;
#line 633
            erodeFlag = 0;
#line 633
            for(m=0; m < ySeSize; m++) {
#line 633
                seImagePixelInPtr = seImageLineInPtr;
#line 633
                sePixelPtr = seLinePtr;
#line 633
                for(n=0; n < xSeSize; n++) {
#line 633
                    if(*sePixelPtr > 0.0) {
#line 633
                        if(*seImagePixelInPtr <= 0.0) {
#line 633
                            erodeFlag++;
#line 633
                        }
#line 633
                    }
#line 633
                    sePixelPtr++;
#line 633
                    seImagePixelInPtr++;
#line 633
                }
#line 633
                seLinePtr = seLinePtr + xSeSize;
#line 633
                seImageLineInPtr = seImageLineInPtr + xSize;
#line 633
            }
#line 633

#line 633
/*
#line 633
 * Not sure what to do here! The problem is that if the
#line 633
 * structure element origin is zero and the corresponding
#line 633
 * image element is zero we get no element where we should get one.
#line 633
 */
#line 633
            if(erodeFlag > 0) {
#line 633
                *(imagePixelOutPtr + seImageOriginOffset) = 0.0; 
#line 633
            } else {
#line 633
                fPtr = (imagePixelOutPtr + seImageOriginOffset);
#line 633
                *fPtr = *(imagePixelInPtr + seImageOriginOffset);
#line 633
               if(*fPtr <= 0.0) {
#line 633
                   *fPtr = 1.0;
#line 633
               } 
#line 633
            }
#line 633

#line 633
/*
#line 633
 * END of Structure Element Block !
#line 633
 */
#line 633

#line 633
/*
#line 633
 * Move to the next image pixel position
#line 633
 */
#line 633
            imagePixelInPtr++;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
/*
#line 633
 * increment according to line length
#line 633
 */
#line 633
        imageLineInPtr = imageLineInPtr + xSize;
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633
    return(0);
#line 633
}
#line 633

#line 633

#line 633

#line 633
static int
#line 633
erode_I32(
#line 633
    Nap_i32 *in,	/* input data array			*/
#line 633
    size_t ySize,		/* ysize				*/
#line 633
    size_t xSize,		/* xsize				*/
#line 633
    Nap_i32 *se,	/* structure element			*/
#line 633
    size_t ySeSize,		/* ysize of the structure element	*/
#line 633
    size_t xSeSize,		/* xsize of the structure element	*/
#line 633
    size_t ySeOrigin,		/* y structure element origin		*/
#line 633
    size_t xSeOrigin,		/* x structure element origin		*/
#line 633
    Nap_i32 *out	/* output data arra		y	*/
#line 633
)
#line 633

#line 633
{
#line 633
    size_t xLag;	/* number of x steps across the input data	*/
#line 633
    size_t yLag;	/* number of y steps across the input data	*/
#line 633
    Nap_i32 *imagePixelInPtr; 	/* input pixel		*/ 
#line 633
    Nap_i32 *imageLineInPtr; 	/* input line  		*/ 
#line 633
    Nap_i32 *imagePixelOutPtr; 	/* output pixel		*/ 
#line 633
    Nap_i32 *imageLineOutPtr; 	/* output line 		*/ 
#line 633
    Nap_i32 *sePixelPtr;		/* SE pixel 		*/
#line 633
    Nap_i32 *seLinePtr;		/* SE line 		*/
#line 633
    Nap_i32 *seImageLineInPtr;  /* SE image line   in 	*/ 
#line 633
    Nap_i32 *seImagePixelInPtr; /* SE image pixel  in	*/
#line 633
    size_t seImageOriginOffset; 	/* image value the SE origin	*/
#line 633
    Nap_i32 *fPtr;		/* temporary pointer		*/
#line 633
    int erodeFlag;	/* true implies set the output to 0		*/
#line 633
    int i,j;	/* integer x,y positions in the data space	*/
#line 633
    int m,n;
#line 633
   
#line 633
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 633
        return(-1);
#line 633
    }
#line 633

#line 633
    xLag = xSize - xSeSize + 1;
#line 633
    yLag = ySize - ySeSize + 1;
#line 633

#line 633
/*
#line 633
 * We have to zero everything in the output first !
#line 633
 */
#line 633

#line 633
    imageLineOutPtr = out;
#line 633
    for(i=0; i < ySize; i++) {
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xSize; j++) {
#line 633
            *imagePixelOutPtr = 0.0;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633

#line 633
/*
#line 633
 * Calculate the result offset !
#line 633
 */
#line 633
   
#line 633

#line 633
    imageLineInPtr = in;
#line 633
    imageLineOutPtr = out;
#line 633
    seImageOriginOffset =  ySeOrigin*xSize + xSeOrigin;
#line 633

#line 633
    for(i=0; i < yLag; i++) {
#line 633
        imagePixelInPtr = imageLineInPtr;
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xLag; j++) {
#line 633
/*
#line 633
 * At this point we are positioned at some i,j pixel
#line 633
 * in the input data array. The i,j represents the
#line 633
 * top left corner of the operator kernel.
#line 633
 *
#line 633
 * Test to see if the origin structure element position
#line 633
 * in the image is > 0. If this test is true set all the
#line 633
 * values in the image corresponding to no zero values in the structure
#line 633
 * element to the image value.
#line 633
 */
#line 633

#line 633
/* 
#line 633
 * START of Structure element Block!
#line 633
 */
#line 633

#line 633
            seImageLineInPtr = imagePixelInPtr;
#line 633

#line 633
            seLinePtr = se;
#line 633
            erodeFlag = 0;
#line 633
            for(m=0; m < ySeSize; m++) {
#line 633
                seImagePixelInPtr = seImageLineInPtr;
#line 633
                sePixelPtr = seLinePtr;
#line 633
                for(n=0; n < xSeSize; n++) {
#line 633
                    if(*sePixelPtr > 0.0) {
#line 633
                        if(*seImagePixelInPtr <= 0.0) {
#line 633
                            erodeFlag++;
#line 633
                        }
#line 633
                    }
#line 633
                    sePixelPtr++;
#line 633
                    seImagePixelInPtr++;
#line 633
                }
#line 633
                seLinePtr = seLinePtr + xSeSize;
#line 633
                seImageLineInPtr = seImageLineInPtr + xSize;
#line 633
            }
#line 633

#line 633
/*
#line 633
 * Not sure what to do here! The problem is that if the
#line 633
 * structure element origin is zero and the corresponding
#line 633
 * image element is zero we get no element where we should get one.
#line 633
 */
#line 633
            if(erodeFlag > 0) {
#line 633
                *(imagePixelOutPtr + seImageOriginOffset) = 0.0; 
#line 633
            } else {
#line 633
                fPtr = (imagePixelOutPtr + seImageOriginOffset);
#line 633
                *fPtr = *(imagePixelInPtr + seImageOriginOffset);
#line 633
               if(*fPtr <= 0.0) {
#line 633
                   *fPtr = 1.0;
#line 633
               } 
#line 633
            }
#line 633

#line 633
/*
#line 633
 * END of Structure Element Block !
#line 633
 */
#line 633

#line 633
/*
#line 633
 * Move to the next image pixel position
#line 633
 */
#line 633
            imagePixelInPtr++;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
/*
#line 633
 * increment according to line length
#line 633
 */
#line 633
        imageLineInPtr = imageLineInPtr + xSize;
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633
    return(0);
#line 633
}
#line 633

#line 633

#line 633

#line 633

#line 633

#line 633

#line 633
static int
#line 633
erode_F32(
#line 633
    Nap_f32 *in,	/* input data array			*/
#line 633
    size_t ySize,		/* ysize				*/
#line 633
    size_t xSize,		/* xsize				*/
#line 633
    Nap_f32 *se,	/* structure element			*/
#line 633
    size_t ySeSize,		/* ysize of the structure element	*/
#line 633
    size_t xSeSize,		/* xsize of the structure element	*/
#line 633
    size_t ySeOrigin,		/* y structure element origin		*/
#line 633
    size_t xSeOrigin,		/* x structure element origin		*/
#line 633
    Nap_f32 *out	/* output data arra		y	*/
#line 633
)
#line 633

#line 633
{
#line 633
    size_t xLag;	/* number of x steps across the input data	*/
#line 633
    size_t yLag;	/* number of y steps across the input data	*/
#line 633
    Nap_f32 *imagePixelInPtr; 	/* input pixel		*/ 
#line 633
    Nap_f32 *imageLineInPtr; 	/* input line  		*/ 
#line 633
    Nap_f32 *imagePixelOutPtr; 	/* output pixel		*/ 
#line 633
    Nap_f32 *imageLineOutPtr; 	/* output line 		*/ 
#line 633
    Nap_f32 *sePixelPtr;		/* SE pixel 		*/
#line 633
    Nap_f32 *seLinePtr;		/* SE line 		*/
#line 633
    Nap_f32 *seImageLineInPtr;  /* SE image line   in 	*/ 
#line 633
    Nap_f32 *seImagePixelInPtr; /* SE image pixel  in	*/
#line 633
    size_t seImageOriginOffset; 	/* image value the SE origin	*/
#line 633
    Nap_f32 *fPtr;		/* temporary pointer		*/
#line 633
    int erodeFlag;	/* true implies set the output to 0		*/
#line 633
    int i,j;	/* integer x,y positions in the data space	*/
#line 633
    int m,n;
#line 633
   
#line 633
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 633
        return(-1);
#line 633
    }
#line 633

#line 633
    xLag = xSize - xSeSize + 1;
#line 633
    yLag = ySize - ySeSize + 1;
#line 633

#line 633
/*
#line 633
 * We have to zero everything in the output first !
#line 633
 */
#line 633

#line 633
    imageLineOutPtr = out;
#line 633
    for(i=0; i < ySize; i++) {
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xSize; j++) {
#line 633
            *imagePixelOutPtr = 0.0;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633

#line 633
/*
#line 633
 * Calculate the result offset !
#line 633
 */
#line 633
   
#line 633

#line 633
    imageLineInPtr = in;
#line 633
    imageLineOutPtr = out;
#line 633
    seImageOriginOffset =  ySeOrigin*xSize + xSeOrigin;
#line 633

#line 633
    for(i=0; i < yLag; i++) {
#line 633
        imagePixelInPtr = imageLineInPtr;
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xLag; j++) {
#line 633
/*
#line 633
 * At this point we are positioned at some i,j pixel
#line 633
 * in the input data array. The i,j represents the
#line 633
 * top left corner of the operator kernel.
#line 633
 *
#line 633
 * Test to see if the origin structure element position
#line 633
 * in the image is > 0. If this test is true set all the
#line 633
 * values in the image corresponding to no zero values in the structure
#line 633
 * element to the image value.
#line 633
 */
#line 633

#line 633
/* 
#line 633
 * START of Structure element Block!
#line 633
 */
#line 633

#line 633
            seImageLineInPtr = imagePixelInPtr;
#line 633

#line 633
            seLinePtr = se;
#line 633
            erodeFlag = 0;
#line 633
            for(m=0; m < ySeSize; m++) {
#line 633
                seImagePixelInPtr = seImageLineInPtr;
#line 633
                sePixelPtr = seLinePtr;
#line 633
                for(n=0; n < xSeSize; n++) {
#line 633
                    if(*sePixelPtr > 0.0) {
#line 633
                        if(*seImagePixelInPtr <= 0.0) {
#line 633
                            erodeFlag++;
#line 633
                        }
#line 633
                    }
#line 633
                    sePixelPtr++;
#line 633
                    seImagePixelInPtr++;
#line 633
                }
#line 633
                seLinePtr = seLinePtr + xSeSize;
#line 633
                seImageLineInPtr = seImageLineInPtr + xSize;
#line 633
            }
#line 633

#line 633
/*
#line 633
 * Not sure what to do here! The problem is that if the
#line 633
 * structure element origin is zero and the corresponding
#line 633
 * image element is zero we get no element where we should get one.
#line 633
 */
#line 633
            if(erodeFlag > 0) {
#line 633
                *(imagePixelOutPtr + seImageOriginOffset) = 0.0; 
#line 633
            } else {
#line 633
                fPtr = (imagePixelOutPtr + seImageOriginOffset);
#line 633
                *fPtr = *(imagePixelInPtr + seImageOriginOffset);
#line 633
               if(*fPtr <= 0.0) {
#line 633
                   *fPtr = 1.0;
#line 633
               } 
#line 633
            }
#line 633

#line 633
/*
#line 633
 * END of Structure Element Block !
#line 633
 */
#line 633

#line 633
/*
#line 633
 * Move to the next image pixel position
#line 633
 */
#line 633
            imagePixelInPtr++;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
/*
#line 633
 * increment according to line length
#line 633
 */
#line 633
        imageLineInPtr = imageLineInPtr + xSize;
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633
    return(0);
#line 633
}
#line 633

#line 633

#line 633

#line 633
static int
#line 633
erode_F64(
#line 633
    Nap_f64 *in,	/* input data array			*/
#line 633
    size_t ySize,		/* ysize				*/
#line 633
    size_t xSize,		/* xsize				*/
#line 633
    Nap_f64 *se,	/* structure element			*/
#line 633
    size_t ySeSize,		/* ysize of the structure element	*/
#line 633
    size_t xSeSize,		/* xsize of the structure element	*/
#line 633
    size_t ySeOrigin,		/* y structure element origin		*/
#line 633
    size_t xSeOrigin,		/* x structure element origin		*/
#line 633
    Nap_f64 *out	/* output data arra		y	*/
#line 633
)
#line 633

#line 633
{
#line 633
    size_t xLag;	/* number of x steps across the input data	*/
#line 633
    size_t yLag;	/* number of y steps across the input data	*/
#line 633
    Nap_f64 *imagePixelInPtr; 	/* input pixel		*/ 
#line 633
    Nap_f64 *imageLineInPtr; 	/* input line  		*/ 
#line 633
    Nap_f64 *imagePixelOutPtr; 	/* output pixel		*/ 
#line 633
    Nap_f64 *imageLineOutPtr; 	/* output line 		*/ 
#line 633
    Nap_f64 *sePixelPtr;		/* SE pixel 		*/
#line 633
    Nap_f64 *seLinePtr;		/* SE line 		*/
#line 633
    Nap_f64 *seImageLineInPtr;  /* SE image line   in 	*/ 
#line 633
    Nap_f64 *seImagePixelInPtr; /* SE image pixel  in	*/
#line 633
    size_t seImageOriginOffset; 	/* image value the SE origin	*/
#line 633
    Nap_f64 *fPtr;		/* temporary pointer		*/
#line 633
    int erodeFlag;	/* true implies set the output to 0		*/
#line 633
    int i,j;	/* integer x,y positions in the data space	*/
#line 633
    int m,n;
#line 633
   
#line 633
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
#line 633
        return(-1);
#line 633
    }
#line 633

#line 633
    xLag = xSize - xSeSize + 1;
#line 633
    yLag = ySize - ySeSize + 1;
#line 633

#line 633
/*
#line 633
 * We have to zero everything in the output first !
#line 633
 */
#line 633

#line 633
    imageLineOutPtr = out;
#line 633
    for(i=0; i < ySize; i++) {
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xSize; j++) {
#line 633
            *imagePixelOutPtr = 0.0;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633

#line 633
/*
#line 633
 * Calculate the result offset !
#line 633
 */
#line 633
   
#line 633

#line 633
    imageLineInPtr = in;
#line 633
    imageLineOutPtr = out;
#line 633
    seImageOriginOffset =  ySeOrigin*xSize + xSeOrigin;
#line 633

#line 633
    for(i=0; i < yLag; i++) {
#line 633
        imagePixelInPtr = imageLineInPtr;
#line 633
        imagePixelOutPtr = imageLineOutPtr;
#line 633
        for(j=0; j < xLag; j++) {
#line 633
/*
#line 633
 * At this point we are positioned at some i,j pixel
#line 633
 * in the input data array. The i,j represents the
#line 633
 * top left corner of the operator kernel.
#line 633
 *
#line 633
 * Test to see if the origin structure element position
#line 633
 * in the image is > 0. If this test is true set all the
#line 633
 * values in the image corresponding to no zero values in the structure
#line 633
 * element to the image value.
#line 633
 */
#line 633

#line 633
/* 
#line 633
 * START of Structure element Block!
#line 633
 */
#line 633

#line 633
            seImageLineInPtr = imagePixelInPtr;
#line 633

#line 633
            seLinePtr = se;
#line 633
            erodeFlag = 0;
#line 633
            for(m=0; m < ySeSize; m++) {
#line 633
                seImagePixelInPtr = seImageLineInPtr;
#line 633
                sePixelPtr = seLinePtr;
#line 633
                for(n=0; n < xSeSize; n++) {
#line 633
                    if(*sePixelPtr > 0.0) {
#line 633
                        if(*seImagePixelInPtr <= 0.0) {
#line 633
                            erodeFlag++;
#line 633
                        }
#line 633
                    }
#line 633
                    sePixelPtr++;
#line 633
                    seImagePixelInPtr++;
#line 633
                }
#line 633
                seLinePtr = seLinePtr + xSeSize;
#line 633
                seImageLineInPtr = seImageLineInPtr + xSize;
#line 633
            }
#line 633

#line 633
/*
#line 633
 * Not sure what to do here! The problem is that if the
#line 633
 * structure element origin is zero and the corresponding
#line 633
 * image element is zero we get no element where we should get one.
#line 633
 */
#line 633
            if(erodeFlag > 0) {
#line 633
                *(imagePixelOutPtr + seImageOriginOffset) = 0.0; 
#line 633
            } else {
#line 633
                fPtr = (imagePixelOutPtr + seImageOriginOffset);
#line 633
                *fPtr = *(imagePixelInPtr + seImageOriginOffset);
#line 633
               if(*fPtr <= 0.0) {
#line 633
                   *fPtr = 1.0;
#line 633
               } 
#line 633
            }
#line 633

#line 633
/*
#line 633
 * END of Structure Element Block !
#line 633
 */
#line 633

#line 633
/*
#line 633
 * Move to the next image pixel position
#line 633
 */
#line 633
            imagePixelInPtr++;
#line 633
            imagePixelOutPtr++;
#line 633
        }
#line 633
/*
#line 633
 * increment according to line length
#line 633
 */
#line 633
        imageLineInPtr = imageLineInPtr + xSize;
#line 633
        imageLineOutPtr = imageLineOutPtr + xSize;
#line 633
    }
#line 633
    return(0);
#line 633
}
#line 633

#line 633

#line 633

#line 633


EXTERN char *
Nap_erode(
    NapClientData       *nap_cd,
    Nap_NAO		*box_nao)	/* points to user's arguments	*/
{
    Nap_NAO		*in_nao;	/* input array			*/ 
    Nap_NAO		*se_nao;	/* structure element		*/ 
    Nap_NAO		*org_nao;	/* position of se origin	*/
    Nap_NAO		*result;	/* output array			*/ 
    Nap_dataType	dataType;
    size_t		ySize;	/* input data shape -> output   */
    size_t		xSize;	/* input data shape -> output   */
    size_t		rank;		/* input data rank -> output	*/
    size_t		ySeSize;	/* structure element dimension	*/
    size_t		xSeSize;	/* structure element dimension	*/
    size_t		ySeOrigin;	/* structure element dimension	*/
    size_t		shape[3];	/* structure element dimension	*/
    int			status;

    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    CHECK2NULL(box_nao->rank == 1, "Nap_erode: Argument rank not 1");
    CHECK2NULL(box_nao->nels == 3,
             "Nap_erode: Usage should be 'dilate(data,structureElement,Origin)' ");
    in_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    CHECK2NULL(in_nao, "Nap_erode: Error calling Nap_GetNaoFromSlot");
    dataType = in_nao->dataType;
    rank = in_nao->rank;
    shape[0] = ySize = in_nao->shape[0];
    shape[1] = xSize = in_nao->shape[1];

    CHECK2NULL(rank == 2, "Nap_erode: input NAO rank not 2");

    se_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(se_nao->rank <= 2, "Nap_erode: structure element dimensions > 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */
    se_nao = Nap_CastNAO(nap_cd, se_nao, dataType);
    Nap_IncrRefCount(nap_cd, se_nao);

    if(se_nao->rank == 1) { 
        xSeSize = se_nao->shape[0];
        ySeSize = 1;
    } else {
        ySeSize = se_nao->shape[0];
        xSeSize = se_nao->shape[1];
    }

    org_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[2]);
    CHECK2NULL(org_nao->nels == 2, "Nap_erode: origin values not 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */

    org_nao = Nap_CastNAO(nap_cd, org_nao, NAP_I32);
    Nap_IncrRefCount(nap_cd, org_nao);
    CHECK2NULL(org_nao->data.I32[0] >= 0 && org_nao->data.I32[0] < ySeSize,
	    "Nap_erode: SE y coord outside SE");
    CHECK2NULL(org_nao->data.I32[1] >= 0 && org_nao->data.I32[1] < xSeSize,
	    "Nap_erode: SE x coord outside SE");
    ySeOrigin = org_nao->data.I32[0];
    Nap_DecrRefCount(nap_cd, org_nao);
    result = Nap_NewNAO(nap_cd, dataType, rank, shape);
    CHECK2NULL(result, "Nap_erode: error calling Nap_NewNAO");

/*
 * Copy and attach all the input data CV's
 * to the output nao "result".
 */
    status = Nap_CopyDims(nap_cd, in_nao, result);
    CHECK2NULL(status == TCL_OK, "m4Name: Error Calling Nap_CopyDims");

    switch (dataType) {
        
#line 717

#line 717

#line 717

#line 717
        case NAP_U8:
#line 717
               erode_U8(in_nao->data.U8, ySize, xSize, se_nao->data.U8, ySeSize, xSeSize,
#line 717
			ySeOrigin, ySeOrigin, result->data.U8); 
#line 717
            break;
#line 717

#line 717

#line 717
        case NAP_U16:
#line 717
               erode_U16(in_nao->data.U16, ySize, xSize, se_nao->data.U16, ySeSize, xSeSize,
#line 717
			ySeOrigin, ySeOrigin, result->data.U16); 
#line 717
            break;
#line 717

#line 717

#line 717
        case NAP_U32:
#line 717
               erode_U32(in_nao->data.U32, ySize, xSize, se_nao->data.U32, ySeSize, xSeSize,
#line 717
			ySeOrigin, ySeOrigin, result->data.U32); 
#line 717
            break;
#line 717

#line 717

#line 717

#line 717

#line 717
        case NAP_I8:
#line 717
               erode_I8(in_nao->data.I8, ySize, xSize, se_nao->data.I8, ySeSize, xSeSize,
#line 717
			ySeOrigin, ySeOrigin, result->data.I8); 
#line 717
            break;
#line 717

#line 717

#line 717
        case NAP_I16:
#line 717
               erode_I16(in_nao->data.I16, ySize, xSize, se_nao->data.I16, ySeSize, xSeSize,
#line 717
			ySeOrigin, ySeOrigin, result->data.I16); 
#line 717
            break;
#line 717

#line 717

#line 717
        case NAP_I32:
#line 717
               erode_I32(in_nao->data.I32, ySize, xSize, se_nao->data.I32, ySeSize, xSeSize,
#line 717
			ySeOrigin, ySeOrigin, result->data.I32); 
#line 717
            break;
#line 717

#line 717

#line 717

#line 717

#line 717

#line 717
        case NAP_F32:
#line 717
               erode_F32(in_nao->data.F32, ySize, xSize, se_nao->data.F32, ySeSize, xSeSize,
#line 717
			ySeOrigin, ySeOrigin, result->data.F32); 
#line 717
            break;
#line 717

#line 717

#line 717
        case NAP_F64:
#line 717
               erode_F64(in_nao->data.F64, ySize, xSize, se_nao->data.F64, ySeSize, xSeSize,
#line 717
			ySeOrigin, ySeOrigin, result->data.F64); 
#line 717
            break;
#line 717

#line 717

#line 717

        default:		/* Error		*/
            return NULL;
    }

    Nap_DecrRefCount(nap_cd, se_nao);

    return result->id;
}
