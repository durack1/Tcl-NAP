#line 6 "/home/dav480/tcl/nap/generic/include.m4"

#line 5 "/home/dav480/tcl/nap/generic/napDyad.c,m4"
/* Do not edit this file (napDyad.c) */
/* It was produced from source file napDyad.c,m4 */

/* 
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napDyad.c,m4,v 1.146 2005/10/29 12:40:45 dav480 Exp $";
#endif /* not lint */

#include <udunits.h>

#include "nap.h"
#include "nap_check.h"

/*
 *  Nap_DataType2 --
 *	Gives data type of result from data type of two arguments.
 *	Both types should be numeric or character - else return NAP_NULL_TYPE.
 */



EXTERN Nap_dataType
Nap_DataType2(
    Nap_dataType        t1,		/* dataType of left arg */
    Nap_dataType        t2)		/* dataType of right arg */
{
    double		m;		/* max exact int float */
    double		max2;		/* max value spanning two types */
    double		min2;		/* min value spanning two types */
    Nap_dataType        tmax;
    Nap_dataType        tmin;
    Nap_dataType        result;

    if (Nap_TypeIsUnboxed(t1) && Nap_TypeIsUnboxed(t2)) {
	tmax = Max(t1, t2);
	tmin = Min(t1, t2);
	result = tmax;
	if (Nap_TypeIsInteger(tmax)) {
	    max2 = Max(Nap_MaxOf(t1), Nap_MaxOf(t2));
	    min2 = Min(Nap_MinOf(t1), Nap_MinOf(t2));
	    while (result < NAP_F64  &&  (min2 < Nap_MinOf(result)  ||  max2 > Nap_MaxOf(result))) {
		++result;
	    }
	} else if (Nap_TypeIsInteger(tmin)  &&  tmax == NAP_F32) {
	    m = ldexp(1.0, FLT_MANT_DIG) - 1.0;
	    if (Nap_MaxOf(tmin) > m) {
		result = NAP_F64;
	    }
	}
    } else {
	result = NAP_NULL_TYPE;
    }
    return result;
}

/*
 *  Nap_DyadArgs --
 *      Get left & right argument naos.
 *      Do padding & unit conversion if needed.
 *      Both have ref. count incremented.
 */



static int
Nap_DyadArgs(
    NapClientData       *nap_cd,
    char		*left,			/* id of left arg (in) */
    char		*right,			/* id of right arg (in) */
    char		*unitMode,		/* " ", "+", "*", "/", "%" or "p" (in) */
    Nap_NAO		**naoLeftPtr,		/* new left arg (out) */
    Nap_NAO		**naoRightPtr)		/* new right arg (out) */
{
    Nap_NAO		*naoLeft;		/* new left arg */
    Nap_NAO		*naoPtr;
    Nap_NAO		*naoRight;		/* new right arg */

    naoPtr = Nap_GetNaoFromId(nap_cd, left);
    CHECK2(naoPtr, "Nap_DyadArgs: Undefined left-hand operand");
    naoLeft = Nap_GetNumericNaoFromId(nap_cd, left);
    CHECK2(naoLeft, "Nap_DyadArgs: Non-numeric left-hand operand");
    Nap_IncrRefCount(nap_cd, naoPtr);
    Nap_IncrRefCount(nap_cd, naoLeft);
    Nap_DecrRefCount(nap_cd, naoPtr);
    CHECK2(Nap_IsUnboxed(naoLeft), "Nap_DyadArgs: Boxed left-hand operand");
    naoPtr = Nap_GetNaoFromId(nap_cd, right);
    CHECK2(naoPtr, "Nap_DyadArgs: Undefined right-hand operand");
    naoRight = Nap_GetNumericNaoFromId(nap_cd, right);
    CHECK2(naoRight, "Nap_DyadArgs: Non-numeric right-hand operand");
    Nap_IncrRefCount(nap_cd, naoPtr);
    Nap_IncrRefCount(nap_cd, naoRight);
    Nap_DecrRefCount(nap_cd, naoPtr);
    CHECK2(Nap_IsUnboxed(naoRight), "Nap_DyadArgs: Boxed right-hand operand");
    if (unitMode[0] == '+'  &&  naoLeft->unit  &&  naoRight->unit) {
	naoPtr = Nap_ConvertUnit(nap_cd, naoLeft, naoRight->unit);
	CHECK(naoPtr);
	Nap_IncrRefCount(nap_cd, naoPtr);
	Nap_DecrRefCount(nap_cd, naoLeft);
	naoLeft = naoPtr;
    }
    *naoLeftPtr  = naoLeft;
    *naoRightPtr = naoRight;
    return TCL_OK;
}


/*
 *  Nap_DyadInit --
 *      Define NAOs for arguments & result, etc.
 */



static int
Nap_DyadInit(
    NapClientData       *nap_cd,
    Nap_NAO		*nao1,			/* left arg (in) */
    Nap_NAO		*nao2,			/* right arg (in) */
    Nap_dataType        dataType1,		/* dataType for left arg (in) */
    Nap_dataType        dataType2,		/* dataType for right arg (in) */
    Nap_dataType        resultDataType,		/* (in) */
    int			resultHasMissingValue,	/* TRUE/FALSE (in) */
    char		*unitMode,		/* " ", "+", "*", "/", "%" or "p" (in) */
    Nap_NAO		**naoPtr1Ptr,		/* left arg (out) */
    Nap_NAO		**naoPtr2Ptr,		/* right arg (out) */
    Nap_NAO		**naoResultPtrPtr)	/* result (out) */
{
    Nap_NAO             *coordNaoPtr;           /* coordinate variable */
    char                *dimName;               /* dimension name */
    int			i;
    int			i1;
    int			i2;
    double		intercept;
    Nap_NAO		*naoMissingValuePtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoResultPtr;
    int                 rank;
    size_t              *shape;
    char                *str;
    double		slope;
    int			status;
    double		tmp_double;
    utUnit		unit1;
    utUnit		unit2;
    utUnit		unit3;
    utUnit		*unit_status;

    Nap_IncrRefCount(nap_cd, nao1);
    Nap_IncrRefCount(nap_cd, nao2);
    naoPtr1 = Nap_CastNAO(nap_cd, nao1, dataType1);
    Nap_IncrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, nao1);
    naoPtr2 = Nap_CastNAO(nap_cd, nao2, dataType2);
    Nap_IncrRefCount(nap_cd, naoPtr2);
    Nap_DecrRefCount(nap_cd, nao2);
    if (naoPtr1->rank > naoPtr2->rank) {
	rank = naoPtr1->rank;
	shape = naoPtr1->shape;
    } else {
	rank = naoPtr2->rank;
	shape = naoPtr2->shape;
    }
    for (i = 0; i < rank; i++) {
	i1 = naoPtr1->rank + i - rank;
	i2 = naoPtr2->rank + i - rank;
	CHECK4(i1 < 0  ||  i2 < 0  ||  naoPtr1->shape[i1] == naoPtr2->shape[i2],
		"Nap_DyadInit: Dimension %d of left operand has different size from "
		"dimension %d of right operand",
		i1, i2);
    }
    naoResultPtr = Nap_NewNAO(nap_cd, resultDataType, rank, shape);
    CHECK2(naoResultPtr, "Nap_DyadInit: Error calling Nap_NewNAO");
    if (resultHasMissingValue) {
	if (naoResultPtr->missingValueSlot == 0) {
	    naoMissingValuePtr = Nap_StandardMissingValueNAO(nap_cd, resultDataType);
	    status = Nap_SetMissing(nap_cd, naoResultPtr, naoMissingValuePtr->slot);
	    CHECK(status == TCL_OK);
	}
    } else {
	status = Nap_SetMissing(nap_cd, naoResultPtr, 0);
	CHECK(status == TCL_OK);
    }
    for (i = 0; i < rank; i++) {
	coordNaoPtr = NULL;
	dimName = NULL;
	i1 = nao1->rank + i - rank;
	i2 = nao2->rank + i - rank;
	if (i1 >= 0) {
	    coordNaoPtr = Nap_GetCoordVar(nap_cd, nao1, i1);
	    dimName = nao1->dimName[i1];
	}
	if (i2 >= 0) {
	    if (!coordNaoPtr) {
		coordNaoPtr = Nap_GetCoordVar(nap_cd, nao2, i2);
	    }
	    if (!dimName) {
		dimName = nao2->dimName[i2];
	    }
	}
	status = Nap_AttachCoordVar(nap_cd, naoResultPtr, coordNaoPtr, dimName, i);
	CHECK(status == TCL_OK);
    }

    switch (unitMode[0]) {
	case ' ':
	    break;
	case '+':
	    if (nao1->unit && ! nao2->unit) {
		naoResultPtr->unit = Nap_StrDup(nao1->unit);
	    } else if (nao2->unit) {
		naoResultPtr->unit = Nap_StrDup(nao2->unit);
	    }
	    break;
	case '*':
	    if (nao1->unit && nao2->unit) {
		status = utScan(nao1->unit, &unit1);
		CHECK2(status == 0, "Nap_DyadInit: Error decoding unit");
		status = utScan(nao2->unit, &unit2);
		CHECK2(status == 0, "Nap_DyadInit: Error decoding unit");
		unit_status = utMultiply(&unit1, &unit2, &unit3);
		CHECK2(unit_status, "Nap_DyadInit: Error in unit conversion");
		status = utPrint(&unit3, &str);
		CHECK2(status == 0, "Nap_DyadInit: Error in unit conversion");
		naoResultPtr->unit = Nap_StrDup(str);
	    }
	    break;
	case '/':
	    if (nao1->unit && nao2->unit) {
		status = utScan(nao1->unit, &unit1);
		CHECK2(status == 0, "Nap_DyadInit: Error decoding unit");
		status = utScan(nao2->unit, &unit2);
		CHECK2(status == 0, "Nap_DyadInit: Error decoding unit");
		unit_status = utDivide(&unit1, &unit2, &unit3);
		CHECK2(unit_status, "Nap_DyadInit: Error in unit conversion");
		status = utPrint(&unit3, &str);
		CHECK2(status == 0, "Nap_DyadInit: Error in unit conversion");
		naoResultPtr->unit = Nap_StrDup(str);
	    }
	    break;
	case '%':
	    if (nao1->unit) {
		naoResultPtr->unit = Nap_StrDup(nao1->unit);
	    }
	    break;
	case 'p':		/* 'p' = power (**) */
	    if (nao1->unit) {
		if (naoPtr2->rank == 0) {
		    status = Nap_F64ScalarValue(nap_cd, naoPtr2, &tmp_double);
		    CHECK(status == TCL_OK);
		    status = utScan(nao1->unit, &unit1);
		    CHECK2(status == 0, "Nap_DyadInit: Error decoding unit");
		    unit_status = utRaise(&unit1, tmp_double, &unit3);
		    CHECK2(unit_status, "Nap_DyadInit: Error in unit conversion");
		    status = utPrint(&unit3, &str);
		    CHECK2(status == 0, "Nap_DyadInit: Error in unit conversion");
		    naoResultPtr->unit = Nap_StrDup(str);
		}
	    }
	    break;
	default:                /* error */
	    CHECK3(0, "Nap_DyadInit: unitMode %s", unitMode);
	    assert(FALSE);
    }

    *naoPtr1Ptr = naoPtr1;
    *naoPtr2Ptr = naoPtr2;
    *naoResultPtrPtr = naoResultPtr;
    Nap_DecrRefCount(nap_cd, nao1);
    Nap_DecrRefCount(nap_cd, nao2);
    return TCL_OK;
}

#line 348 "/home/dav480/tcl/nap/generic/napDyad.c,m4"


#line 349
EXTERN char *
#line 349
Nap_Add(
#line 349
    NapClientData	*nap_cd,
#line 349
    char		*str1,			/* id of left arg (in) */
#line 349
    char		*str2)			/* id of right arg (in) */
#line 349
{
#line 349
    const int		resultHasMissingValue = TRUE;
#line 349
    size_t		i;
#line 349
    size_t		i1;			/* subscript of left arg */
#line 349
    size_t		i2;			/* subscript of right arg */
#line 349
    Nap_NAO		*naoResultPtr;
#line 349
    Nap_NAO		*naoPtr1;
#line 349
    Nap_NAO		*naoPtr2;
#line 349
    Nap_dataType        resultDataType;
#line 349
    int			status;
#line 349

#line 349
    status = Nap_DyadArgs(nap_cd, str1, str2, "+", &naoPtr1, &naoPtr2);
#line 349
    CHECK1NULL(status == TCL_OK);
#line 349
    resultDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 349
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 349
	    resultHasMissingValue, "+", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 349
    CHECK1NULL(status == TCL_OK);
#line 349
    switch (resultDataType) {
#line 349

#line 349
    
#line 349

#line 349

#line 349
		case NAP_U8:
#line 349
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 349
			i1 = i % naoPtr1->nels;
#line 349
			i2 = i % naoPtr2->nels;
#line 349
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 349
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 349
			} else {
#line 349
			    naoResultPtr->data.U8[i] = 
#line 349
				    naoPtr1->data.U8[i1] + naoPtr2->data.U8[i2];
#line 349
			}
#line 349
		    }
#line 349
		    break;
#line 349

#line 349
		case NAP_U16:
#line 349
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 349
			i1 = i % naoPtr1->nels;
#line 349
			i2 = i % naoPtr2->nels;
#line 349
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 349
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 349
			} else {
#line 349
			    naoResultPtr->data.U16[i] = 
#line 349
				    naoPtr1->data.U16[i1] + naoPtr2->data.U16[i2];
#line 349
			}
#line 349
		    }
#line 349
		    break;
#line 349

#line 349
		case NAP_U32:
#line 349
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 349
			i1 = i % naoPtr1->nels;
#line 349
			i2 = i % naoPtr2->nels;
#line 349
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 349
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 349
			} else {
#line 349
			    naoResultPtr->data.U32[i] = 
#line 349
				    naoPtr1->data.U32[i1] + naoPtr2->data.U32[i2];
#line 349
			}
#line 349
		    }
#line 349
		    break;
#line 349

#line 349

#line 349

#line 349
		case NAP_I8:
#line 349
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 349
			i1 = i % naoPtr1->nels;
#line 349
			i2 = i % naoPtr2->nels;
#line 349
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 349
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 349
			} else {
#line 349
			    naoResultPtr->data.I8[i] = 
#line 349
				    naoPtr1->data.I8[i1] + naoPtr2->data.I8[i2];
#line 349
			}
#line 349
		    }
#line 349
		    break;
#line 349

#line 349
		case NAP_I16:
#line 349
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 349
			i1 = i % naoPtr1->nels;
#line 349
			i2 = i % naoPtr2->nels;
#line 349
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 349
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 349
			} else {
#line 349
			    naoResultPtr->data.I16[i] = 
#line 349
				    naoPtr1->data.I16[i1] + naoPtr2->data.I16[i2];
#line 349
			}
#line 349
		    }
#line 349
		    break;
#line 349

#line 349
		case NAP_I32:
#line 349
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 349
			i1 = i % naoPtr1->nels;
#line 349
			i2 = i % naoPtr2->nels;
#line 349
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 349
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 349
			} else {
#line 349
			    naoResultPtr->data.I32[i] = 
#line 349
				    naoPtr1->data.I32[i1] + naoPtr2->data.I32[i2];
#line 349
			}
#line 349
		    }
#line 349
		    break;
#line 349

#line 349

#line 349

#line 349
    
#line 349
		case NAP_F32:
#line 349
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 349
			i1 = i % naoPtr1->nels;
#line 349
			i2 = i % naoPtr2->nels;
#line 349
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 349
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 349
			} else {
#line 349
			    naoResultPtr->data.F32[i] = 
#line 349
				    naoPtr1->data.F32[i1] + naoPtr2->data.F32[i2];
#line 349
			}
#line 349
		    }
#line 349
		    break;
#line 349

#line 349
    
#line 349
		case NAP_F64:
#line 349
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 349
			i1 = i % naoPtr1->nels;
#line 349
			i2 = i % naoPtr2->nels;
#line 349
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 349
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 349
			} else {
#line 349
			    naoResultPtr->data.F64[i] = 
#line 349
				    naoPtr1->data.F64[i1] + naoPtr2->data.F64[i2];
#line 349
			}
#line 349
		    }
#line 349
		    break;
#line 349
    default:            /* error */
#line 349
	assert(FALSE);
#line 349
    }
#line 349
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 349
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 349
    return naoResultPtr->id;
#line 349
}
#line 349


#line 350
EXTERN char *
#line 350
Nap_Sub(
#line 350
    NapClientData	*nap_cd,
#line 350
    char		*str1,			/* id of left arg (in) */
#line 350
    char		*str2)			/* id of right arg (in) */
#line 350
{
#line 350
    const int		resultHasMissingValue = TRUE;
#line 350
    size_t		i;
#line 350
    size_t		i1;			/* subscript of left arg */
#line 350
    size_t		i2;			/* subscript of right arg */
#line 350
    Nap_NAO		*naoResultPtr;
#line 350
    Nap_NAO		*naoPtr1;
#line 350
    Nap_NAO		*naoPtr2;
#line 350
    Nap_dataType        resultDataType;
#line 350
    int			status;
#line 350

#line 350
    status = Nap_DyadArgs(nap_cd, str1, str2, "+", &naoPtr1, &naoPtr2);
#line 350
    CHECK1NULL(status == TCL_OK);
#line 350
    resultDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 350
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 350
	    resultHasMissingValue, "+", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 350
    CHECK1NULL(status == TCL_OK);
#line 350
    switch (resultDataType) {
#line 350

#line 350
    
#line 350

#line 350

#line 350
		case NAP_U8:
#line 350
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 350
			i1 = i % naoPtr1->nels;
#line 350
			i2 = i % naoPtr2->nels;
#line 350
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 350
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 350
			} else {
#line 350
			    naoResultPtr->data.U8[i] = 
#line 350
				    naoPtr1->data.U8[i1] - naoPtr2->data.U8[i2];
#line 350
			}
#line 350
		    }
#line 350
		    break;
#line 350

#line 350
		case NAP_U16:
#line 350
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 350
			i1 = i % naoPtr1->nels;
#line 350
			i2 = i % naoPtr2->nels;
#line 350
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 350
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 350
			} else {
#line 350
			    naoResultPtr->data.U16[i] = 
#line 350
				    naoPtr1->data.U16[i1] - naoPtr2->data.U16[i2];
#line 350
			}
#line 350
		    }
#line 350
		    break;
#line 350

#line 350
		case NAP_U32:
#line 350
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 350
			i1 = i % naoPtr1->nels;
#line 350
			i2 = i % naoPtr2->nels;
#line 350
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 350
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 350
			} else {
#line 350
			    naoResultPtr->data.U32[i] = 
#line 350
				    naoPtr1->data.U32[i1] - naoPtr2->data.U32[i2];
#line 350
			}
#line 350
		    }
#line 350
		    break;
#line 350

#line 350

#line 350

#line 350
		case NAP_I8:
#line 350
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 350
			i1 = i % naoPtr1->nels;
#line 350
			i2 = i % naoPtr2->nels;
#line 350
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 350
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 350
			} else {
#line 350
			    naoResultPtr->data.I8[i] = 
#line 350
				    naoPtr1->data.I8[i1] - naoPtr2->data.I8[i2];
#line 350
			}
#line 350
		    }
#line 350
		    break;
#line 350

#line 350
		case NAP_I16:
#line 350
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 350
			i1 = i % naoPtr1->nels;
#line 350
			i2 = i % naoPtr2->nels;
#line 350
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 350
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 350
			} else {
#line 350
			    naoResultPtr->data.I16[i] = 
#line 350
				    naoPtr1->data.I16[i1] - naoPtr2->data.I16[i2];
#line 350
			}
#line 350
		    }
#line 350
		    break;
#line 350

#line 350
		case NAP_I32:
#line 350
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 350
			i1 = i % naoPtr1->nels;
#line 350
			i2 = i % naoPtr2->nels;
#line 350
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 350
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 350
			} else {
#line 350
			    naoResultPtr->data.I32[i] = 
#line 350
				    naoPtr1->data.I32[i1] - naoPtr2->data.I32[i2];
#line 350
			}
#line 350
		    }
#line 350
		    break;
#line 350

#line 350

#line 350

#line 350
    
#line 350
		case NAP_F32:
#line 350
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 350
			i1 = i % naoPtr1->nels;
#line 350
			i2 = i % naoPtr2->nels;
#line 350
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 350
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 350
			} else {
#line 350
			    naoResultPtr->data.F32[i] = 
#line 350
				    naoPtr1->data.F32[i1] - naoPtr2->data.F32[i2];
#line 350
			}
#line 350
		    }
#line 350
		    break;
#line 350

#line 350
    
#line 350
		case NAP_F64:
#line 350
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 350
			i1 = i % naoPtr1->nels;
#line 350
			i2 = i % naoPtr2->nels;
#line 350
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 350
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 350
			} else {
#line 350
			    naoResultPtr->data.F64[i] = 
#line 350
				    naoPtr1->data.F64[i1] - naoPtr2->data.F64[i2];
#line 350
			}
#line 350
		    }
#line 350
		    break;
#line 350
    default:            /* error */
#line 350
	assert(FALSE);
#line 350
    }
#line 350
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 350
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 350
    return naoResultPtr->id;
#line 350
}
#line 350


#line 351
EXTERN char *
#line 351
Nap_Mul(
#line 351
    NapClientData	*nap_cd,
#line 351
    char		*str1,			/* id of left arg (in) */
#line 351
    char		*str2)			/* id of right arg (in) */
#line 351
{
#line 351
    const int		resultHasMissingValue = TRUE;
#line 351
    size_t		i;
#line 351
    size_t		i1;			/* subscript of left arg */
#line 351
    size_t		i2;			/* subscript of right arg */
#line 351
    Nap_NAO		*naoResultPtr;
#line 351
    Nap_NAO		*naoPtr1;
#line 351
    Nap_NAO		*naoPtr2;
#line 351
    Nap_dataType        resultDataType;
#line 351
    int			status;
#line 351

#line 351
    status = Nap_DyadArgs(nap_cd, str1, str2, "*", &naoPtr1, &naoPtr2);
#line 351
    CHECK1NULL(status == TCL_OK);
#line 351
    resultDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 351
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 351
	    resultHasMissingValue, "*", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 351
    CHECK1NULL(status == TCL_OK);
#line 351
    switch (resultDataType) {
#line 351

#line 351
    
#line 351

#line 351

#line 351
		case NAP_U8:
#line 351
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 351
			i1 = i % naoPtr1->nels;
#line 351
			i2 = i % naoPtr2->nels;
#line 351
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 351
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 351
			} else {
#line 351
			    naoResultPtr->data.U8[i] = 
#line 351
				    naoPtr1->data.U8[i1] * naoPtr2->data.U8[i2];
#line 351
			}
#line 351
		    }
#line 351
		    break;
#line 351

#line 351
		case NAP_U16:
#line 351
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 351
			i1 = i % naoPtr1->nels;
#line 351
			i2 = i % naoPtr2->nels;
#line 351
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 351
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 351
			} else {
#line 351
			    naoResultPtr->data.U16[i] = 
#line 351
				    naoPtr1->data.U16[i1] * naoPtr2->data.U16[i2];
#line 351
			}
#line 351
		    }
#line 351
		    break;
#line 351

#line 351
		case NAP_U32:
#line 351
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 351
			i1 = i % naoPtr1->nels;
#line 351
			i2 = i % naoPtr2->nels;
#line 351
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 351
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 351
			} else {
#line 351
			    naoResultPtr->data.U32[i] = 
#line 351
				    naoPtr1->data.U32[i1] * naoPtr2->data.U32[i2];
#line 351
			}
#line 351
		    }
#line 351
		    break;
#line 351

#line 351

#line 351

#line 351
		case NAP_I8:
#line 351
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 351
			i1 = i % naoPtr1->nels;
#line 351
			i2 = i % naoPtr2->nels;
#line 351
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 351
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 351
			} else {
#line 351
			    naoResultPtr->data.I8[i] = 
#line 351
				    naoPtr1->data.I8[i1] * naoPtr2->data.I8[i2];
#line 351
			}
#line 351
		    }
#line 351
		    break;
#line 351

#line 351
		case NAP_I16:
#line 351
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 351
			i1 = i % naoPtr1->nels;
#line 351
			i2 = i % naoPtr2->nels;
#line 351
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 351
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 351
			} else {
#line 351
			    naoResultPtr->data.I16[i] = 
#line 351
				    naoPtr1->data.I16[i1] * naoPtr2->data.I16[i2];
#line 351
			}
#line 351
		    }
#line 351
		    break;
#line 351

#line 351
		case NAP_I32:
#line 351
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 351
			i1 = i % naoPtr1->nels;
#line 351
			i2 = i % naoPtr2->nels;
#line 351
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 351
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 351
			} else {
#line 351
			    naoResultPtr->data.I32[i] = 
#line 351
				    naoPtr1->data.I32[i1] * naoPtr2->data.I32[i2];
#line 351
			}
#line 351
		    }
#line 351
		    break;
#line 351

#line 351

#line 351

#line 351
    
#line 351
		case NAP_F32:
#line 351
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 351
			i1 = i % naoPtr1->nels;
#line 351
			i2 = i % naoPtr2->nels;
#line 351
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 351
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 351
			} else {
#line 351
			    naoResultPtr->data.F32[i] = 
#line 351
				    naoPtr1->data.F32[i1] * naoPtr2->data.F32[i2];
#line 351
			}
#line 351
		    }
#line 351
		    break;
#line 351

#line 351
    
#line 351
		case NAP_F64:
#line 351
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 351
			i1 = i % naoPtr1->nels;
#line 351
			i2 = i % naoPtr2->nels;
#line 351
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 351
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 351
			} else {
#line 351
			    naoResultPtr->data.F64[i] = 
#line 351
				    naoPtr1->data.F64[i1] * naoPtr2->data.F64[i2];
#line 351
			}
#line 351
		    }
#line 351
		    break;
#line 351
    default:            /* error */
#line 351
	assert(FALSE);
#line 351
    }
#line 351
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 351
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 351
    return naoResultPtr->id;
#line 351
}
#line 351


#line 352
EXTERN char *
#line 352
Nap_LesserOf(
#line 352
    NapClientData	*nap_cd,
#line 352
    char		*str1,			/* id of left arg (in) */
#line 352
    char		*str2)			/* id of right arg (in) */
#line 352
{
#line 352
    const int		resultHasMissingValue = TRUE;
#line 352
    size_t		i;
#line 352
    size_t		i1;			/* subscript of left arg */
#line 352
    size_t		i2;			/* subscript of right arg */
#line 352
    Nap_NAO		*naoResultPtr;
#line 352
    Nap_NAO		*naoPtr1;
#line 352
    Nap_NAO		*naoPtr2;
#line 352
    Nap_dataType        resultDataType;
#line 352
    int			status;
#line 352

#line 352
    status = Nap_DyadArgs(nap_cd, str1, str2, "+", &naoPtr1, &naoPtr2);
#line 352
    CHECK1NULL(status == TCL_OK);
#line 352
    resultDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 352
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 352
	    resultHasMissingValue, "+", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 352
    CHECK1NULL(status == TCL_OK);
#line 352
    switch (resultDataType) {
#line 352

#line 352
    
#line 352

#line 352

#line 352
		case NAP_U8:
#line 352
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 352
			i1 = i % naoPtr1->nels;
#line 352
			i2 = i % naoPtr2->nels;
#line 352
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 352
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 352
			} else {
#line 352
			    naoResultPtr->data.U8[i] = 
#line 352
				    Min(naoPtr1->data.U8[i1], naoPtr2->data.U8[i2]);
#line 352
			}
#line 352
		    }
#line 352
		    break;
#line 352

#line 352
		case NAP_U16:
#line 352
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 352
			i1 = i % naoPtr1->nels;
#line 352
			i2 = i % naoPtr2->nels;
#line 352
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 352
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 352
			} else {
#line 352
			    naoResultPtr->data.U16[i] = 
#line 352
				    Min(naoPtr1->data.U16[i1], naoPtr2->data.U16[i2]);
#line 352
			}
#line 352
		    }
#line 352
		    break;
#line 352

#line 352
		case NAP_U32:
#line 352
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 352
			i1 = i % naoPtr1->nels;
#line 352
			i2 = i % naoPtr2->nels;
#line 352
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 352
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 352
			} else {
#line 352
			    naoResultPtr->data.U32[i] = 
#line 352
				    Min(naoPtr1->data.U32[i1], naoPtr2->data.U32[i2]);
#line 352
			}
#line 352
		    }
#line 352
		    break;
#line 352

#line 352

#line 352

#line 352
		case NAP_I8:
#line 352
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 352
			i1 = i % naoPtr1->nels;
#line 352
			i2 = i % naoPtr2->nels;
#line 352
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 352
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 352
			} else {
#line 352
			    naoResultPtr->data.I8[i] = 
#line 352
				    Min(naoPtr1->data.I8[i1], naoPtr2->data.I8[i2]);
#line 352
			}
#line 352
		    }
#line 352
		    break;
#line 352

#line 352
		case NAP_I16:
#line 352
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 352
			i1 = i % naoPtr1->nels;
#line 352
			i2 = i % naoPtr2->nels;
#line 352
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 352
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 352
			} else {
#line 352
			    naoResultPtr->data.I16[i] = 
#line 352
				    Min(naoPtr1->data.I16[i1], naoPtr2->data.I16[i2]);
#line 352
			}
#line 352
		    }
#line 352
		    break;
#line 352

#line 352
		case NAP_I32:
#line 352
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 352
			i1 = i % naoPtr1->nels;
#line 352
			i2 = i % naoPtr2->nels;
#line 352
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 352
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 352
			} else {
#line 352
			    naoResultPtr->data.I32[i] = 
#line 352
				    Min(naoPtr1->data.I32[i1], naoPtr2->data.I32[i2]);
#line 352
			}
#line 352
		    }
#line 352
		    break;
#line 352

#line 352

#line 352

#line 352
    
#line 352
		case NAP_F32:
#line 352
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 352
			i1 = i % naoPtr1->nels;
#line 352
			i2 = i % naoPtr2->nels;
#line 352
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 352
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 352
			} else {
#line 352
			    naoResultPtr->data.F32[i] = 
#line 352
				    Min(naoPtr1->data.F32[i1], naoPtr2->data.F32[i2]);
#line 352
			}
#line 352
		    }
#line 352
		    break;
#line 352

#line 352
    
#line 352
		case NAP_F64:
#line 352
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 352
			i1 = i % naoPtr1->nels;
#line 352
			i2 = i % naoPtr2->nels;
#line 352
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 352
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 352
			} else {
#line 352
			    naoResultPtr->data.F64[i] = 
#line 352
				    Min(naoPtr1->data.F64[i1], naoPtr2->data.F64[i2]);
#line 352
			}
#line 352
		    }
#line 352
		    break;
#line 352
    default:            /* error */
#line 352
	assert(FALSE);
#line 352
    }
#line 352
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 352
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 352
    return naoResultPtr->id;
#line 352
}
#line 352


#line 353
EXTERN char *
#line 353
Nap_GreaterOf(
#line 353
    NapClientData	*nap_cd,
#line 353
    char		*str1,			/* id of left arg (in) */
#line 353
    char		*str2)			/* id of right arg (in) */
#line 353
{
#line 353
    const int		resultHasMissingValue = TRUE;
#line 353
    size_t		i;
#line 353
    size_t		i1;			/* subscript of left arg */
#line 353
    size_t		i2;			/* subscript of right arg */
#line 353
    Nap_NAO		*naoResultPtr;
#line 353
    Nap_NAO		*naoPtr1;
#line 353
    Nap_NAO		*naoPtr2;
#line 353
    Nap_dataType        resultDataType;
#line 353
    int			status;
#line 353

#line 353
    status = Nap_DyadArgs(nap_cd, str1, str2, "+", &naoPtr1, &naoPtr2);
#line 353
    CHECK1NULL(status == TCL_OK);
#line 353
    resultDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 353
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 353
	    resultHasMissingValue, "+", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 353
    CHECK1NULL(status == TCL_OK);
#line 353
    switch (resultDataType) {
#line 353

#line 353
    
#line 353

#line 353

#line 353
		case NAP_U8:
#line 353
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 353
			i1 = i % naoPtr1->nels;
#line 353
			i2 = i % naoPtr2->nels;
#line 353
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 353
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 353
			} else {
#line 353
			    naoResultPtr->data.U8[i] = 
#line 353
				    Max(naoPtr1->data.U8[i1], naoPtr2->data.U8[i2]);
#line 353
			}
#line 353
		    }
#line 353
		    break;
#line 353

#line 353
		case NAP_U16:
#line 353
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 353
			i1 = i % naoPtr1->nels;
#line 353
			i2 = i % naoPtr2->nels;
#line 353
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 353
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 353
			} else {
#line 353
			    naoResultPtr->data.U16[i] = 
#line 353
				    Max(naoPtr1->data.U16[i1], naoPtr2->data.U16[i2]);
#line 353
			}
#line 353
		    }
#line 353
		    break;
#line 353

#line 353
		case NAP_U32:
#line 353
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 353
			i1 = i % naoPtr1->nels;
#line 353
			i2 = i % naoPtr2->nels;
#line 353
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 353
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 353
			} else {
#line 353
			    naoResultPtr->data.U32[i] = 
#line 353
				    Max(naoPtr1->data.U32[i1], naoPtr2->data.U32[i2]);
#line 353
			}
#line 353
		    }
#line 353
		    break;
#line 353

#line 353

#line 353

#line 353
		case NAP_I8:
#line 353
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 353
			i1 = i % naoPtr1->nels;
#line 353
			i2 = i % naoPtr2->nels;
#line 353
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 353
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 353
			} else {
#line 353
			    naoResultPtr->data.I8[i] = 
#line 353
				    Max(naoPtr1->data.I8[i1], naoPtr2->data.I8[i2]);
#line 353
			}
#line 353
		    }
#line 353
		    break;
#line 353

#line 353
		case NAP_I16:
#line 353
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 353
			i1 = i % naoPtr1->nels;
#line 353
			i2 = i % naoPtr2->nels;
#line 353
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 353
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 353
			} else {
#line 353
			    naoResultPtr->data.I16[i] = 
#line 353
				    Max(naoPtr1->data.I16[i1], naoPtr2->data.I16[i2]);
#line 353
			}
#line 353
		    }
#line 353
		    break;
#line 353

#line 353
		case NAP_I32:
#line 353
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 353
			i1 = i % naoPtr1->nels;
#line 353
			i2 = i % naoPtr2->nels;
#line 353
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 353
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 353
			} else {
#line 353
			    naoResultPtr->data.I32[i] = 
#line 353
				    Max(naoPtr1->data.I32[i1], naoPtr2->data.I32[i2]);
#line 353
			}
#line 353
		    }
#line 353
		    break;
#line 353

#line 353

#line 353

#line 353
    
#line 353
		case NAP_F32:
#line 353
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 353
			i1 = i % naoPtr1->nels;
#line 353
			i2 = i % naoPtr2->nels;
#line 353
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 353
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 353
			} else {
#line 353
			    naoResultPtr->data.F32[i] = 
#line 353
				    Max(naoPtr1->data.F32[i1], naoPtr2->data.F32[i2]);
#line 353
			}
#line 353
		    }
#line 353
		    break;
#line 353

#line 353
    
#line 353
		case NAP_F64:
#line 353
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 353
			i1 = i % naoPtr1->nels;
#line 353
			i2 = i % naoPtr2->nels;
#line 353
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 353
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 353
			} else {
#line 353
			    naoResultPtr->data.F64[i] = 
#line 353
				    Max(naoPtr1->data.F64[i1], naoPtr2->data.F64[i2]);
#line 353
			}
#line 353
		    }
#line 353
		    break;
#line 353
    default:            /* error */
#line 353
	assert(FALSE);
#line 353
    }
#line 353
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 353
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 353
    return naoResultPtr->id;
#line 353
}
#line 353


#line 354
EXTERN char *
#line 354
Nap_Div(
#line 354
    NapClientData	*nap_cd,
#line 354
    char		*str1,			/* id of left arg (in) */
#line 354
    char		*str2)			/* id of right arg (in) */
#line 354
{
#line 354
    const int		resultHasMissingValue = TRUE;
#line 354
    size_t		i;
#line 354
    size_t		i1;			/* subscript of left arg */
#line 354
    size_t		i2;			/* subscript of right arg */
#line 354
    Nap_NAO		*naoResultPtr;
#line 354
    Nap_NAO		*naoPtr1;
#line 354
    Nap_NAO		*naoPtr2;
#line 354
    Nap_dataType        resultDataType;
#line 354
    int			status;
#line 354

#line 354
    status = Nap_DyadArgs(nap_cd, str1, str2, "/", &naoPtr1, &naoPtr2);
#line 354
    CHECK1NULL(status == TCL_OK);
#line 354
    resultDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 354
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 354
	    resultHasMissingValue, "/", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 354
    CHECK1NULL(status == TCL_OK);
#line 354
    switch (resultDataType) {
#line 354

#line 354
    
#line 354

#line 354

#line 354
		case NAP_U8:
#line 354
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 354
			i1 = i % naoPtr1->nels;
#line 354
			i2 = i % naoPtr2->nels;
#line 354
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 354
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 354
			} else {
#line 354
			    naoResultPtr->data.U8[i] = 
#line 354
				    naoPtr2->data.U8[i2]?naoPtr1->data.U8[i1]/naoPtr2->data.U8[i2]:nap_cd->U8MissingValueNao->data.U8[0];
#line 354
			}
#line 354
		    }
#line 354
		    break;
#line 354

#line 354
		case NAP_U16:
#line 354
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 354
			i1 = i % naoPtr1->nels;
#line 354
			i2 = i % naoPtr2->nels;
#line 354
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 354
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 354
			} else {
#line 354
			    naoResultPtr->data.U16[i] = 
#line 354
				    naoPtr2->data.U16[i2]?naoPtr1->data.U16[i1]/naoPtr2->data.U16[i2]:nap_cd->U16MissingValueNao->data.U16[0];
#line 354
			}
#line 354
		    }
#line 354
		    break;
#line 354

#line 354
		case NAP_U32:
#line 354
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 354
			i1 = i % naoPtr1->nels;
#line 354
			i2 = i % naoPtr2->nels;
#line 354
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 354
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 354
			} else {
#line 354
			    naoResultPtr->data.U32[i] = 
#line 354
				    naoPtr2->data.U32[i2]?naoPtr1->data.U32[i1]/naoPtr2->data.U32[i2]:nap_cd->U32MissingValueNao->data.U32[0];
#line 354
			}
#line 354
		    }
#line 354
		    break;
#line 354

#line 354

#line 354

#line 354
		case NAP_I8:
#line 354
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 354
			i1 = i % naoPtr1->nels;
#line 354
			i2 = i % naoPtr2->nels;
#line 354
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 354
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 354
			} else {
#line 354
			    naoResultPtr->data.I8[i] = 
#line 354
				    naoPtr2->data.I8[i2]?naoPtr1->data.I8[i1]/naoPtr2->data.I8[i2]:nap_cd->I8MissingValueNao->data.I8[0];
#line 354
			}
#line 354
		    }
#line 354
		    break;
#line 354

#line 354
		case NAP_I16:
#line 354
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 354
			i1 = i % naoPtr1->nels;
#line 354
			i2 = i % naoPtr2->nels;
#line 354
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 354
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 354
			} else {
#line 354
			    naoResultPtr->data.I16[i] = 
#line 354
				    naoPtr2->data.I16[i2]?naoPtr1->data.I16[i1]/naoPtr2->data.I16[i2]:nap_cd->I16MissingValueNao->data.I16[0];
#line 354
			}
#line 354
		    }
#line 354
		    break;
#line 354

#line 354
		case NAP_I32:
#line 354
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 354
			i1 = i % naoPtr1->nels;
#line 354
			i2 = i % naoPtr2->nels;
#line 354
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 354
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 354
			} else {
#line 354
			    naoResultPtr->data.I32[i] = 
#line 354
				    naoPtr2->data.I32[i2]?naoPtr1->data.I32[i1]/naoPtr2->data.I32[i2]:nap_cd->I32MissingValueNao->data.I32[0];
#line 354
			}
#line 354
		    }
#line 354
		    break;
#line 354

#line 354

#line 354

#line 354
    
#line 354
		case NAP_F32:
#line 354
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 354
			i1 = i % naoPtr1->nels;
#line 354
			i2 = i % naoPtr2->nels;
#line 354
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 354
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 354
			} else {
#line 354
			    naoResultPtr->data.F32[i] = 
#line 354
				    naoPtr1->data.F32[i1]/naoPtr2->data.F32[i2];
#line 354
			}
#line 354
		    }
#line 354
		    break;
#line 354

#line 354
    
#line 354
		case NAP_F64:
#line 354
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 354
			i1 = i % naoPtr1->nels;
#line 354
			i2 = i % naoPtr2->nels;
#line 354
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 354
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 354
			} else {
#line 354
			    naoResultPtr->data.F64[i] = 
#line 354
				    naoPtr1->data.F64[i1]/naoPtr2->data.F64[i2];
#line 354
			}
#line 354
		    }
#line 354
		    break;
#line 354
    default:            /* error */
#line 354
	assert(FALSE);
#line 354
    }
#line 354
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 354
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 354
    return naoResultPtr->id;
#line 354
}
#line 354


#line 355
EXTERN char *
#line 355
Nap_Rem(
#line 355
    NapClientData	*nap_cd,
#line 355
    char		*str1,			/* id of left arg (in) */
#line 355
    char		*str2)			/* id of right arg (in) */
#line 355
{
#line 355
    const int		resultHasMissingValue = TRUE;
#line 355
    size_t		i;
#line 355
    size_t		i1;			/* subscript of left arg */
#line 355
    size_t		i2;			/* subscript of right arg */
#line 355
    Nap_NAO		*naoResultPtr;
#line 355
    Nap_NAO		*naoPtr1;
#line 355
    Nap_NAO		*naoPtr2;
#line 355
    Nap_dataType        resultDataType;
#line 355
    int			status;
#line 355

#line 355
    status = Nap_DyadArgs(nap_cd, str1, str2, "%", &naoPtr1, &naoPtr2);
#line 355
    CHECK1NULL(status == TCL_OK);
#line 355
    resultDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 355
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 355
	    resultHasMissingValue, "%", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 355
    CHECK1NULL(status == TCL_OK);
#line 355
    switch (resultDataType) {
#line 355

#line 355
    
#line 355

#line 355

#line 355
		case NAP_U8:
#line 355
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 355
			i1 = i % naoPtr1->nels;
#line 355
			i2 = i % naoPtr2->nels;
#line 355
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 355
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 355
			} else {
#line 355
			    naoResultPtr->data.U8[i] = 
#line 355
				    Nap_mod(naoPtr1->data.U8[i1],naoPtr2->data.U8[i2]);
#line 355
			}
#line 355
		    }
#line 355
		    break;
#line 355

#line 355
		case NAP_U16:
#line 355
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 355
			i1 = i % naoPtr1->nels;
#line 355
			i2 = i % naoPtr2->nels;
#line 355
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 355
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 355
			} else {
#line 355
			    naoResultPtr->data.U16[i] = 
#line 355
				    Nap_mod(naoPtr1->data.U16[i1],naoPtr2->data.U16[i2]);
#line 355
			}
#line 355
		    }
#line 355
		    break;
#line 355

#line 355
		case NAP_U32:
#line 355
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 355
			i1 = i % naoPtr1->nels;
#line 355
			i2 = i % naoPtr2->nels;
#line 355
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 355
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 355
			} else {
#line 355
			    naoResultPtr->data.U32[i] = 
#line 355
				    Nap_mod(naoPtr1->data.U32[i1],naoPtr2->data.U32[i2]);
#line 355
			}
#line 355
		    }
#line 355
		    break;
#line 355

#line 355

#line 355

#line 355
		case NAP_I8:
#line 355
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 355
			i1 = i % naoPtr1->nels;
#line 355
			i2 = i % naoPtr2->nels;
#line 355
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 355
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 355
			} else {
#line 355
			    naoResultPtr->data.I8[i] = 
#line 355
				    Nap_mod(naoPtr1->data.I8[i1],naoPtr2->data.I8[i2]);
#line 355
			}
#line 355
		    }
#line 355
		    break;
#line 355

#line 355
		case NAP_I16:
#line 355
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 355
			i1 = i % naoPtr1->nels;
#line 355
			i2 = i % naoPtr2->nels;
#line 355
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 355
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 355
			} else {
#line 355
			    naoResultPtr->data.I16[i] = 
#line 355
				    Nap_mod(naoPtr1->data.I16[i1],naoPtr2->data.I16[i2]);
#line 355
			}
#line 355
		    }
#line 355
		    break;
#line 355

#line 355
		case NAP_I32:
#line 355
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 355
			i1 = i % naoPtr1->nels;
#line 355
			i2 = i % naoPtr2->nels;
#line 355
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 355
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 355
			} else {
#line 355
			    naoResultPtr->data.I32[i] = 
#line 355
				    Nap_mod(naoPtr1->data.I32[i1],naoPtr2->data.I32[i2]);
#line 355
			}
#line 355
		    }
#line 355
		    break;
#line 355

#line 355

#line 355

#line 355
    
#line 355
		case NAP_F32:
#line 355
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 355
			i1 = i % naoPtr1->nels;
#line 355
			i2 = i % naoPtr2->nels;
#line 355
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 355
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 355
			} else {
#line 355
			    naoResultPtr->data.F32[i] = 
#line 355
				    Nap_fmod_f32(naoPtr1->data.F32[i1], naoPtr2->data.F32[i2]);
#line 355
			}
#line 355
		    }
#line 355
		    break;
#line 355

#line 355
    
#line 355
		case NAP_F64:
#line 355
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 355
			i1 = i % naoPtr1->nels;
#line 355
			i2 = i % naoPtr2->nels;
#line 355
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 355
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 355
			} else {
#line 355
			    naoResultPtr->data.F64[i] = 
#line 355
				    Nap_fmod(naoPtr1->data.F64[i1], naoPtr2->data.F64[i2]);
#line 355
			}
#line 355
		    }
#line 355
		    break;
#line 355
    default:            /* error */
#line 355
	assert(FALSE);
#line 355
    }
#line 355
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 355
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 355
    return naoResultPtr->id;
#line 355
}
#line 355


#line 398 "/home/dav480/tcl/nap/generic/napDyad.c,m4"


#line 399
EXTERN char *
#line 399
Nap_Power(
#line 399
    NapClientData	*nap_cd,
#line 399
    char		*str1,			/* id of left arg (in) */
#line 399
    char		*str2)			/* id of right arg (in) */
#line 399
{
#line 399
    const int		resultHasMissingValue = TRUE;
#line 399
    size_t		i;
#line 399
    size_t		i1;			/* subscript of left arg */
#line 399
    size_t		i2;			/* subscript of right arg */
#line 399
    Nap_NAO		*naoResultPtr;
#line 399
    Nap_NAO		*naoPtr1;
#line 399
    Nap_NAO		*naoPtr2;
#line 399
    Nap_dataType        resultDataType;
#line 399
    int			status;
#line 399

#line 399
    status = Nap_DyadArgs(nap_cd, str1, str2, "p", &naoPtr1, &naoPtr2);
#line 399
    CHECK1NULL(status == TCL_OK);
#line 399
    resultDataType = Max(naoPtr1->dataType, naoPtr2->dataType);
#line 399
    resultDataType = Max(resultDataType, NAP_F32);
#line 399
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 399
	    resultHasMissingValue, "p", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 399
    CHECK1NULL(status == TCL_OK);
#line 399
    switch (resultDataType) {
#line 399

#line 399
    
#line 399

#line 399
		case NAP_F32:
#line 399
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 399
			i1 = i % naoPtr1->nels;
#line 399
			i2 = i % naoPtr2->nels;
#line 399
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 399
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 399
			} else {
#line 399
			    naoResultPtr->data.F32[i] = 
#line 399
				    Pow(naoPtr1->data.F32[i1], naoPtr2->data.F32[i2]);
#line 399
			}
#line 399
		    }
#line 399
		    break;
#line 399

#line 399
		case NAP_F64:
#line 399
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 399
			i1 = i % naoPtr1->nels;
#line 399
			i2 = i % naoPtr2->nels;
#line 399
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 399
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 399
			} else {
#line 399
			    naoResultPtr->data.F64[i] = 
#line 399
				    Pow(naoPtr1->data.F64[i1], naoPtr2->data.F64[i2]);
#line 399
			}
#line 399
		    }
#line 399
		    break;
#line 399

#line 399
    default:            /* error */
#line 399
	assert(FALSE);
#line 399
    }
#line 399
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 399
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 399
    return naoResultPtr->id;
#line 399
}
#line 399


#line 400
EXTERN char *
#line 400
Nap_Atan2(
#line 400
    NapClientData	*nap_cd,
#line 400
    char		*str1,			/* id of left arg (in) */
#line 400
    char		*str2)			/* id of right arg (in) */
#line 400
{
#line 400
    const int		resultHasMissingValue = TRUE;
#line 400
    size_t		i;
#line 400
    size_t		i1;			/* subscript of left arg */
#line 400
    size_t		i2;			/* subscript of right arg */
#line 400
    Nap_NAO		*naoResultPtr;
#line 400
    Nap_NAO		*naoPtr1;
#line 400
    Nap_NAO		*naoPtr2;
#line 400
    Nap_dataType        resultDataType;
#line 400
    int			status;
#line 400

#line 400
    status = Nap_DyadArgs(nap_cd, str1, str2, " ", &naoPtr1, &naoPtr2);
#line 400
    CHECK1NULL(status == TCL_OK);
#line 400
    resultDataType = Max(naoPtr1->dataType, naoPtr2->dataType);
#line 400
    resultDataType = Max(resultDataType, NAP_F32);
#line 400
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 400
	    resultHasMissingValue, " ", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 400
    CHECK1NULL(status == TCL_OK);
#line 400
    switch (resultDataType) {
#line 400

#line 400
    
#line 400

#line 400
		case NAP_F32:
#line 400
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 400
			i1 = i % naoPtr1->nels;
#line 400
			i2 = i % naoPtr2->nels;
#line 400
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 400
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 400
			} else {
#line 400
			    naoResultPtr->data.F32[i] = 
#line 400
				    atan2(naoPtr1->data.F32[i1], naoPtr2->data.F32[i2]);
#line 400
			}
#line 400
		    }
#line 400
		    break;
#line 400

#line 400
		case NAP_F64:
#line 400
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 400
			i1 = i % naoPtr1->nels;
#line 400
			i2 = i % naoPtr2->nels;
#line 400
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 400
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 400
			} else {
#line 400
			    naoResultPtr->data.F64[i] = 
#line 400
				    atan2(naoPtr1->data.F64[i1], naoPtr2->data.F64[i2]);
#line 400
			}
#line 400
		    }
#line 400
		    break;
#line 400

#line 400
    default:            /* error */
#line 400
	assert(FALSE);
#line 400
    }
#line 400
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 400
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 400
    return naoResultPtr->id;
#line 400
}
#line 400


#line 401
EXTERN char *
#line 401
Nap_Hypot(
#line 401
    NapClientData	*nap_cd,
#line 401
    char		*str1,			/* id of left arg (in) */
#line 401
    char		*str2)			/* id of right arg (in) */
#line 401
{
#line 401
    const int		resultHasMissingValue = TRUE;
#line 401
    size_t		i;
#line 401
    size_t		i1;			/* subscript of left arg */
#line 401
    size_t		i2;			/* subscript of right arg */
#line 401
    Nap_NAO		*naoResultPtr;
#line 401
    Nap_NAO		*naoPtr1;
#line 401
    Nap_NAO		*naoPtr2;
#line 401
    Nap_dataType        resultDataType;
#line 401
    int			status;
#line 401

#line 401
    status = Nap_DyadArgs(nap_cd, str1, str2, "+", &naoPtr1, &naoPtr2);
#line 401
    CHECK1NULL(status == TCL_OK);
#line 401
    resultDataType = Max(naoPtr1->dataType, naoPtr2->dataType);
#line 401
    resultDataType = Max(resultDataType, NAP_F32);
#line 401
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 401
	    resultHasMissingValue, "+", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 401
    CHECK1NULL(status == TCL_OK);
#line 401
    switch (resultDataType) {
#line 401

#line 401
    
#line 401

#line 401
		case NAP_F32:
#line 401
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 401
			i1 = i % naoPtr1->nels;
#line 401
			i2 = i % naoPtr2->nels;
#line 401
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 401
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 401
			} else {
#line 401
			    naoResultPtr->data.F32[i] = 
#line 401
				    hypot(naoPtr1->data.F32[i1], naoPtr2->data.F32[i2]);
#line 401
			}
#line 401
		    }
#line 401
		    break;
#line 401

#line 401
		case NAP_F64:
#line 401
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 401
			i1 = i % naoPtr1->nels;
#line 401
			i2 = i % naoPtr2->nels;
#line 401
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 401
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 401
			} else {
#line 401
			    naoResultPtr->data.F64[i] = 
#line 401
				    hypot(naoPtr1->data.F64[i1], naoPtr2->data.F64[i2]);
#line 401
			}
#line 401
		    }
#line 401
		    break;
#line 401

#line 401
    default:            /* error */
#line 401
	assert(FALSE);
#line 401
    }
#line 401
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 401
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 401
    return naoResultPtr->id;
#line 401
}
#line 401


#line 402
EXTERN char *
#line 402
Nap_Log(
#line 402
    NapClientData	*nap_cd,
#line 402
    char		*str1,			/* id of left arg (in) */
#line 402
    char		*str2)			/* id of right arg (in) */
#line 402
{
#line 402
    const int		resultHasMissingValue = TRUE;
#line 402
    size_t		i;
#line 402
    size_t		i1;			/* subscript of left arg */
#line 402
    size_t		i2;			/* subscript of right arg */
#line 402
    Nap_NAO		*naoResultPtr;
#line 402
    Nap_NAO		*naoPtr1;
#line 402
    Nap_NAO		*naoPtr2;
#line 402
    Nap_dataType        resultDataType;
#line 402
    int			status;
#line 402

#line 402
    status = Nap_DyadArgs(nap_cd, str1, str2, " ", &naoPtr1, &naoPtr2);
#line 402
    CHECK1NULL(status == TCL_OK);
#line 402
    resultDataType = Max(naoPtr1->dataType, naoPtr2->dataType);
#line 402
    resultDataType = Max(resultDataType, NAP_F32);
#line 402
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 402
	    resultHasMissingValue, " ", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 402
    CHECK1NULL(status == TCL_OK);
#line 402
    switch (resultDataType) {
#line 402

#line 402
    
#line 402

#line 402
		case NAP_F32:
#line 402
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 402
			i1 = i % naoPtr1->nels;
#line 402
			i2 = i % naoPtr2->nels;
#line 402
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 402
			    naoResultPtr->data.F32[i] = nap_cd->F32MissingValueNao->data.F32[0];
#line 402
			} else {
#line 402
			    naoResultPtr->data.F32[i] = 
#line 402
				    log(naoPtr1->data.F32[i1]) / log(naoPtr2->data.F32[i2]);
#line 402
			}
#line 402
		    }
#line 402
		    break;
#line 402

#line 402
		case NAP_F64:
#line 402
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 402
			i1 = i % naoPtr1->nels;
#line 402
			i2 = i % naoPtr2->nels;
#line 402
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 402
			    naoResultPtr->data.F64[i] = nap_cd->F64MissingValueNao->data.F64[0];
#line 402
			} else {
#line 402
			    naoResultPtr->data.F64[i] = 
#line 402
				    log(naoPtr1->data.F64[i1]) / log(naoPtr2->data.F64[i2]);
#line 402
			}
#line 402
		    }
#line 402
		    break;
#line 402

#line 402
    default:            /* error */
#line 402
	assert(FALSE);
#line 402
    }
#line 402
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 402
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 402
    return naoResultPtr->id;
#line 402
}
#line 402


#line 456 "/home/dav480/tcl/nap/generic/napDyad.c,m4"


#line 457
EXTERN char *
#line 457
Nap_And(
#line 457
    NapClientData	*nap_cd,
#line 457
    char		*str1,			/* id of left arg (in) */
#line 457
    char		*str2)			/* id of right arg (in) */
#line 457
{
#line 457
    const int		resultHasMissingValue = TRUE;
#line 457
    size_t		i;
#line 457
    size_t		i1;			/* subscript of left arg */
#line 457
    size_t		i2;			/* subscript of right arg */
#line 457
    Nap_NAO		*naoResultPtr;
#line 457
    Nap_NAO		*naoPtr1;
#line 457
    Nap_NAO		*naoPtr2;
#line 457
    int			status;
#line 457

#line 457
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 && $2", &naoPtr1, &naoPtr2);
#line 457
    CHECK1NULL(status == TCL_OK);
#line 457
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, naoPtr1->dataType, naoPtr2->dataType,
#line 457
	    NAP_I8, resultHasMissingValue, " ",
#line 457
	    &naoPtr1, &naoPtr2, &naoResultPtr);
#line 457
    CHECK1NULL(status == TCL_OK);
#line 457
    switch (naoPtr1->dataType) {
#line 457

#line 457
    
#line 457

#line 457

#line 457

#line 457
    case NAP_U8:
#line 457
	switch (naoPtr2->dataType) {
#line 457
	
#line 457

#line 457

#line 457

#line 457
		case NAP_U8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U8[i1] && naoPtr2->data.U8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U8[i1] && naoPtr2->data.U16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U8[i1] && naoPtr2->data.U32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457
		case NAP_I8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U8[i1] && naoPtr2->data.I8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U8[i1] && naoPtr2->data.I16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U8[i1] && naoPtr2->data.I32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457

#line 457
		case NAP_F32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U8[i1] && naoPtr2->data.F32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_F64:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U8[i1] && naoPtr2->data.F64[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457
	default:            /* error */
#line 457
	    assert(FALSE);
#line 457
	}
#line 457
	break;
#line 457

#line 457
    case NAP_U16:
#line 457
	switch (naoPtr2->dataType) {
#line 457
	
#line 457

#line 457

#line 457

#line 457
		case NAP_U8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U16[i1] && naoPtr2->data.U8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U16[i1] && naoPtr2->data.U16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U16[i1] && naoPtr2->data.U32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457
		case NAP_I8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U16[i1] && naoPtr2->data.I8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U16[i1] && naoPtr2->data.I16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U16[i1] && naoPtr2->data.I32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457

#line 457
		case NAP_F32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U16[i1] && naoPtr2->data.F32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_F64:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U16[i1] && naoPtr2->data.F64[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457
	default:            /* error */
#line 457
	    assert(FALSE);
#line 457
	}
#line 457
	break;
#line 457

#line 457
    case NAP_U32:
#line 457
	switch (naoPtr2->dataType) {
#line 457
	
#line 457

#line 457

#line 457

#line 457
		case NAP_U8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U32[i1] && naoPtr2->data.U8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U32[i1] && naoPtr2->data.U16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U32[i1] && naoPtr2->data.U32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457
		case NAP_I8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U32[i1] && naoPtr2->data.I8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U32[i1] && naoPtr2->data.I16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U32[i1] && naoPtr2->data.I32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457

#line 457
		case NAP_F32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U32[i1] && naoPtr2->data.F32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_F64:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.U32[i1] && naoPtr2->data.F64[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457
	default:            /* error */
#line 457
	    assert(FALSE);
#line 457
	}
#line 457
	break;
#line 457

#line 457

#line 457

#line 457
    case NAP_I8:
#line 457
	switch (naoPtr2->dataType) {
#line 457
	
#line 457

#line 457

#line 457

#line 457
		case NAP_U8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I8[i1] && naoPtr2->data.U8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I8[i1] && naoPtr2->data.U16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I8[i1] && naoPtr2->data.U32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457
		case NAP_I8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I8[i1] && naoPtr2->data.I8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I8[i1] && naoPtr2->data.I16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I8[i1] && naoPtr2->data.I32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457

#line 457
		case NAP_F32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I8[i1] && naoPtr2->data.F32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_F64:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I8[i1] && naoPtr2->data.F64[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457
	default:            /* error */
#line 457
	    assert(FALSE);
#line 457
	}
#line 457
	break;
#line 457

#line 457
    case NAP_I16:
#line 457
	switch (naoPtr2->dataType) {
#line 457
	
#line 457

#line 457

#line 457

#line 457
		case NAP_U8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I16[i1] && naoPtr2->data.U8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I16[i1] && naoPtr2->data.U16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I16[i1] && naoPtr2->data.U32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457
		case NAP_I8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I16[i1] && naoPtr2->data.I8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I16[i1] && naoPtr2->data.I16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I16[i1] && naoPtr2->data.I32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457

#line 457
		case NAP_F32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I16[i1] && naoPtr2->data.F32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_F64:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I16[i1] && naoPtr2->data.F64[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457
	default:            /* error */
#line 457
	    assert(FALSE);
#line 457
	}
#line 457
	break;
#line 457

#line 457
    case NAP_I32:
#line 457
	switch (naoPtr2->dataType) {
#line 457
	
#line 457

#line 457

#line 457

#line 457
		case NAP_U8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I32[i1] && naoPtr2->data.U8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I32[i1] && naoPtr2->data.U16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I32[i1] && naoPtr2->data.U32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457
		case NAP_I8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I32[i1] && naoPtr2->data.I8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I32[i1] && naoPtr2->data.I16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I32[i1] && naoPtr2->data.I32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457

#line 457
		case NAP_F32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I32[i1] && naoPtr2->data.F32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_F64:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.I32[i1] && naoPtr2->data.F64[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457
	default:            /* error */
#line 457
	    assert(FALSE);
#line 457
	}
#line 457
	break;
#line 457

#line 457

#line 457

#line 457

#line 457
    case NAP_F32:
#line 457
	switch (naoPtr2->dataType) {
#line 457
	
#line 457

#line 457

#line 457

#line 457
		case NAP_U8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F32[i1] && naoPtr2->data.U8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F32[i1] && naoPtr2->data.U16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F32[i1] && naoPtr2->data.U32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457
		case NAP_I8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F32[i1] && naoPtr2->data.I8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F32[i1] && naoPtr2->data.I16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F32[i1] && naoPtr2->data.I32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457

#line 457
		case NAP_F32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F32[i1] && naoPtr2->data.F32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_F64:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F32[i1] && naoPtr2->data.F64[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457
	default:            /* error */
#line 457
	    assert(FALSE);
#line 457
	}
#line 457
	break;
#line 457

#line 457
    case NAP_F64:
#line 457
	switch (naoPtr2->dataType) {
#line 457
	
#line 457

#line 457

#line 457

#line 457
		case NAP_U8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F64[i1] && naoPtr2->data.U8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F64[i1] && naoPtr2->data.U16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_U32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F64[i1] && naoPtr2->data.U32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457
		case NAP_I8:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F64[i1] && naoPtr2->data.I8[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I16:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F64[i1] && naoPtr2->data.I16[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_I32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F64[i1] && naoPtr2->data.I32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457

#line 457

#line 457
		case NAP_F32:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F64[i1] && naoPtr2->data.F32[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457
		case NAP_F64:
#line 457
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 457
			i1 = i % naoPtr1->nels;
#line 457
			i2 = i % naoPtr2->nels;
#line 457
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 457
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 457
			} else {
#line 457
			    naoResultPtr->data.I8[i] = 
#line 457
				    naoPtr1->data.F64[i1] && naoPtr2->data.F64[i2];
#line 457
			}
#line 457
		    }
#line 457
		    break;
#line 457

#line 457

#line 457
	default:            /* error */
#line 457
	    assert(FALSE);
#line 457
	}
#line 457
	break;
#line 457

#line 457

#line 457
    default:            /* error */
#line 457
	assert(FALSE);
#line 457
    }
#line 457
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 457
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 457
    return naoResultPtr->id;
#line 457
}
#line 457


#line 458
EXTERN char *
#line 458
Nap_Or(
#line 458
    NapClientData	*nap_cd,
#line 458
    char		*str1,			/* id of left arg (in) */
#line 458
    char		*str2)			/* id of right arg (in) */
#line 458
{
#line 458
    const int		resultHasMissingValue = TRUE;
#line 458
    size_t		i;
#line 458
    size_t		i1;			/* subscript of left arg */
#line 458
    size_t		i2;			/* subscript of right arg */
#line 458
    Nap_NAO		*naoResultPtr;
#line 458
    Nap_NAO		*naoPtr1;
#line 458
    Nap_NAO		*naoPtr2;
#line 458
    int			status;
#line 458

#line 458
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 || $2", &naoPtr1, &naoPtr2);
#line 458
    CHECK1NULL(status == TCL_OK);
#line 458
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, naoPtr1->dataType, naoPtr2->dataType,
#line 458
	    NAP_I8, resultHasMissingValue, " ",
#line 458
	    &naoPtr1, &naoPtr2, &naoResultPtr);
#line 458
    CHECK1NULL(status == TCL_OK);
#line 458
    switch (naoPtr1->dataType) {
#line 458

#line 458
    
#line 458

#line 458

#line 458

#line 458
    case NAP_U8:
#line 458
	switch (naoPtr2->dataType) {
#line 458
	
#line 458

#line 458

#line 458

#line 458
		case NAP_U8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U8[i1] || naoPtr2->data.U8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U8[i1] || naoPtr2->data.U16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U8[i1] || naoPtr2->data.U32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458
		case NAP_I8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U8[i1] || naoPtr2->data.I8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U8[i1] || naoPtr2->data.I16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U8[i1] || naoPtr2->data.I32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458

#line 458
		case NAP_F32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U8[i1] || naoPtr2->data.F32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_F64:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U8[i1] || naoPtr2->data.F64[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458
	default:            /* error */
#line 458
	    assert(FALSE);
#line 458
	}
#line 458
	break;
#line 458

#line 458
    case NAP_U16:
#line 458
	switch (naoPtr2->dataType) {
#line 458
	
#line 458

#line 458

#line 458

#line 458
		case NAP_U8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U16[i1] || naoPtr2->data.U8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U16[i1] || naoPtr2->data.U16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U16[i1] || naoPtr2->data.U32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458
		case NAP_I8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U16[i1] || naoPtr2->data.I8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U16[i1] || naoPtr2->data.I16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U16[i1] || naoPtr2->data.I32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458

#line 458
		case NAP_F32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U16[i1] || naoPtr2->data.F32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_F64:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U16[i1] || naoPtr2->data.F64[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458
	default:            /* error */
#line 458
	    assert(FALSE);
#line 458
	}
#line 458
	break;
#line 458

#line 458
    case NAP_U32:
#line 458
	switch (naoPtr2->dataType) {
#line 458
	
#line 458

#line 458

#line 458

#line 458
		case NAP_U8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U32[i1] || naoPtr2->data.U8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U32[i1] || naoPtr2->data.U16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U32[i1] || naoPtr2->data.U32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458
		case NAP_I8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U32[i1] || naoPtr2->data.I8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U32[i1] || naoPtr2->data.I16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U32[i1] || naoPtr2->data.I32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458

#line 458
		case NAP_F32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U32[i1] || naoPtr2->data.F32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_F64:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.U32[i1] || naoPtr2->data.F64[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458
	default:            /* error */
#line 458
	    assert(FALSE);
#line 458
	}
#line 458
	break;
#line 458

#line 458

#line 458

#line 458
    case NAP_I8:
#line 458
	switch (naoPtr2->dataType) {
#line 458
	
#line 458

#line 458

#line 458

#line 458
		case NAP_U8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I8[i1] || naoPtr2->data.U8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I8[i1] || naoPtr2->data.U16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I8[i1] || naoPtr2->data.U32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458
		case NAP_I8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I8[i1] || naoPtr2->data.I8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I8[i1] || naoPtr2->data.I16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I8[i1] || naoPtr2->data.I32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458

#line 458
		case NAP_F32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I8[i1] || naoPtr2->data.F32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_F64:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I8[i1] || naoPtr2->data.F64[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458
	default:            /* error */
#line 458
	    assert(FALSE);
#line 458
	}
#line 458
	break;
#line 458

#line 458
    case NAP_I16:
#line 458
	switch (naoPtr2->dataType) {
#line 458
	
#line 458

#line 458

#line 458

#line 458
		case NAP_U8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I16[i1] || naoPtr2->data.U8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I16[i1] || naoPtr2->data.U16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I16[i1] || naoPtr2->data.U32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458
		case NAP_I8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I16[i1] || naoPtr2->data.I8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I16[i1] || naoPtr2->data.I16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I16[i1] || naoPtr2->data.I32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458

#line 458
		case NAP_F32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I16[i1] || naoPtr2->data.F32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_F64:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I16[i1] || naoPtr2->data.F64[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458
	default:            /* error */
#line 458
	    assert(FALSE);
#line 458
	}
#line 458
	break;
#line 458

#line 458
    case NAP_I32:
#line 458
	switch (naoPtr2->dataType) {
#line 458
	
#line 458

#line 458

#line 458

#line 458
		case NAP_U8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I32[i1] || naoPtr2->data.U8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I32[i1] || naoPtr2->data.U16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I32[i1] || naoPtr2->data.U32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458
		case NAP_I8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I32[i1] || naoPtr2->data.I8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I32[i1] || naoPtr2->data.I16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I32[i1] || naoPtr2->data.I32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458

#line 458
		case NAP_F32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I32[i1] || naoPtr2->data.F32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_F64:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.I32[i1] || naoPtr2->data.F64[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458
	default:            /* error */
#line 458
	    assert(FALSE);
#line 458
	}
#line 458
	break;
#line 458

#line 458

#line 458

#line 458

#line 458
    case NAP_F32:
#line 458
	switch (naoPtr2->dataType) {
#line 458
	
#line 458

#line 458

#line 458

#line 458
		case NAP_U8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F32[i1] || naoPtr2->data.U8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F32[i1] || naoPtr2->data.U16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F32[i1] || naoPtr2->data.U32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458
		case NAP_I8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F32[i1] || naoPtr2->data.I8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F32[i1] || naoPtr2->data.I16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F32[i1] || naoPtr2->data.I32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458

#line 458
		case NAP_F32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F32[i1] || naoPtr2->data.F32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_F64:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F32[i1] || naoPtr2->data.F64[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458
	default:            /* error */
#line 458
	    assert(FALSE);
#line 458
	}
#line 458
	break;
#line 458

#line 458
    case NAP_F64:
#line 458
	switch (naoPtr2->dataType) {
#line 458
	
#line 458

#line 458

#line 458

#line 458
		case NAP_U8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F64[i1] || naoPtr2->data.U8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F64[i1] || naoPtr2->data.U16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_U32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F64[i1] || naoPtr2->data.U32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458
		case NAP_I8:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F64[i1] || naoPtr2->data.I8[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I16:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F64[i1] || naoPtr2->data.I16[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_I32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F64[i1] || naoPtr2->data.I32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458

#line 458

#line 458
		case NAP_F32:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F64[i1] || naoPtr2->data.F32[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458
		case NAP_F64:
#line 458
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 458
			i1 = i % naoPtr1->nels;
#line 458
			i2 = i % naoPtr2->nels;
#line 458
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 458
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 458
			} else {
#line 458
			    naoResultPtr->data.I8[i] = 
#line 458
				    naoPtr1->data.F64[i1] || naoPtr2->data.F64[i2];
#line 458
			}
#line 458
		    }
#line 458
		    break;
#line 458

#line 458

#line 458
	default:            /* error */
#line 458
	    assert(FALSE);
#line 458
	}
#line 458
	break;
#line 458

#line 458

#line 458
    default:            /* error */
#line 458
	assert(FALSE);
#line 458
    }
#line 458
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 458
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 458
    return naoResultPtr->id;
#line 458
}
#line 458


#line 503 "/home/dav480/tcl/nap/generic/napDyad.c,m4"


#line 504
EXTERN char *
#line 504
Nap_Eq(
#line 504
    NapClientData	*nap_cd,
#line 504
    char		*str1,			/* id of left arg (in) */
#line 504
    char		*str2)			/* id of right arg (in) */
#line 504
{
#line 504
    Nap_dataType	argDataType;
#line 504
    const int		resultHasMissingValue = FALSE;
#line 504
    size_t		i;
#line 504
    size_t		i1;			/* subscript of left arg */
#line 504
    size_t		i2;			/* subscript of right arg */
#line 504
    Nap_NAO		*naoResultPtr;
#line 504
    Nap_NAO		*naoPtr1;
#line 504
    Nap_NAO		*naoPtr2;
#line 504
    int			status;
#line 504

#line 504
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 == $2", &naoPtr1, &naoPtr2);
#line 504
    CHECK1NULL(status == TCL_OK);
#line 504
    argDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 504
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, argDataType, argDataType,
#line 504
	    NAP_I8, resultHasMissingValue, " ",
#line 504
	    &naoPtr1, &naoPtr2, &naoResultPtr);
#line 504
    CHECK1NULL(status == TCL_OK);
#line 504
    switch (argDataType) {
#line 504

#line 504

#line 504
    
#line 504

#line 504

#line 504
		case NAP_C8:
#line 504
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 504
			i1 = i % naoPtr1->nels;
#line 504
			i2 = i % naoPtr2->nels;
#line 504
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 504
			    naoResultPtr->data.I8[i] = 0;
#line 504
			} else {
#line 504
			    naoResultPtr->data.I8[i] = 
#line 504
				    naoPtr1->data.C8[i1] == naoPtr2->data.C8[i2];
#line 504
			}
#line 504
		    }
#line 504
		    break;
#line 504

#line 504

#line 504

#line 504

#line 504

#line 504
		case NAP_U8:
#line 504
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 504
			i1 = i % naoPtr1->nels;
#line 504
			i2 = i % naoPtr2->nels;
#line 504
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 504
			    naoResultPtr->data.I8[i] = 0;
#line 504
			} else {
#line 504
			    naoResultPtr->data.I8[i] = 
#line 504
				    naoPtr1->data.U8[i1] == naoPtr2->data.U8[i2];
#line 504
			}
#line 504
		    }
#line 504
		    break;
#line 504

#line 504
		case NAP_U16:
#line 504
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 504
			i1 = i % naoPtr1->nels;
#line 504
			i2 = i % naoPtr2->nels;
#line 504
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 504
			    naoResultPtr->data.I8[i] = 0;
#line 504
			} else {
#line 504
			    naoResultPtr->data.I8[i] = 
#line 504
				    naoPtr1->data.U16[i1] == naoPtr2->data.U16[i2];
#line 504
			}
#line 504
		    }
#line 504
		    break;
#line 504

#line 504
		case NAP_U32:
#line 504
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 504
			i1 = i % naoPtr1->nels;
#line 504
			i2 = i % naoPtr2->nels;
#line 504
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 504
			    naoResultPtr->data.I8[i] = 0;
#line 504
			} else {
#line 504
			    naoResultPtr->data.I8[i] = 
#line 504
				    naoPtr1->data.U32[i1] == naoPtr2->data.U32[i2];
#line 504
			}
#line 504
		    }
#line 504
		    break;
#line 504

#line 504

#line 504

#line 504
		case NAP_I8:
#line 504
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 504
			i1 = i % naoPtr1->nels;
#line 504
			i2 = i % naoPtr2->nels;
#line 504
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 504
			    naoResultPtr->data.I8[i] = 0;
#line 504
			} else {
#line 504
			    naoResultPtr->data.I8[i] = 
#line 504
				    naoPtr1->data.I8[i1] == naoPtr2->data.I8[i2];
#line 504
			}
#line 504
		    }
#line 504
		    break;
#line 504

#line 504
		case NAP_I16:
#line 504
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 504
			i1 = i % naoPtr1->nels;
#line 504
			i2 = i % naoPtr2->nels;
#line 504
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 504
			    naoResultPtr->data.I8[i] = 0;
#line 504
			} else {
#line 504
			    naoResultPtr->data.I8[i] = 
#line 504
				    naoPtr1->data.I16[i1] == naoPtr2->data.I16[i2];
#line 504
			}
#line 504
		    }
#line 504
		    break;
#line 504

#line 504
		case NAP_I32:
#line 504
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 504
			i1 = i % naoPtr1->nels;
#line 504
			i2 = i % naoPtr2->nels;
#line 504
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 504
			    naoResultPtr->data.I8[i] = 0;
#line 504
			} else {
#line 504
			    naoResultPtr->data.I8[i] = 
#line 504
				    naoPtr1->data.I32[i1] == naoPtr2->data.I32[i2];
#line 504
			}
#line 504
		    }
#line 504
		    break;
#line 504

#line 504

#line 504

#line 504

#line 504
		case NAP_F32:
#line 504
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 504
			i1 = i % naoPtr1->nels;
#line 504
			i2 = i % naoPtr2->nels;
#line 504
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 504
			    naoResultPtr->data.I8[i] = 0;
#line 504
			} else {
#line 504
			    naoResultPtr->data.I8[i] = 
#line 504
				    naoPtr1->data.F32[i1] == naoPtr2->data.F32[i2];
#line 504
			}
#line 504
		    }
#line 504
		    break;
#line 504

#line 504
		case NAP_F64:
#line 504
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 504
			i1 = i % naoPtr1->nels;
#line 504
			i2 = i % naoPtr2->nels;
#line 504
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 504
			    naoResultPtr->data.I8[i] = 0;
#line 504
			} else {
#line 504
			    naoResultPtr->data.I8[i] = 
#line 504
				    naoPtr1->data.F64[i1] == naoPtr2->data.F64[i2];
#line 504
			}
#line 504
		    }
#line 504
		    break;
#line 504

#line 504

#line 504

#line 504
    default:            /* error */
#line 504
	assert(FALSE);
#line 504
    }
#line 504
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 504
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 504
    return naoResultPtr->id;
#line 504
}
#line 504


#line 505
EXTERN char *
#line 505
Nap_Ne(
#line 505
    NapClientData	*nap_cd,
#line 505
    char		*str1,			/* id of left arg (in) */
#line 505
    char		*str2)			/* id of right arg (in) */
#line 505
{
#line 505
    Nap_dataType	argDataType;
#line 505
    const int		resultHasMissingValue = FALSE;
#line 505
    size_t		i;
#line 505
    size_t		i1;			/* subscript of left arg */
#line 505
    size_t		i2;			/* subscript of right arg */
#line 505
    Nap_NAO		*naoResultPtr;
#line 505
    Nap_NAO		*naoPtr1;
#line 505
    Nap_NAO		*naoPtr2;
#line 505
    int			status;
#line 505

#line 505
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 != $2", &naoPtr1, &naoPtr2);
#line 505
    CHECK1NULL(status == TCL_OK);
#line 505
    argDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 505
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, argDataType, argDataType,
#line 505
	    NAP_I8, resultHasMissingValue, " ",
#line 505
	    &naoPtr1, &naoPtr2, &naoResultPtr);
#line 505
    CHECK1NULL(status == TCL_OK);
#line 505
    switch (argDataType) {
#line 505

#line 505

#line 505
    
#line 505

#line 505

#line 505
		case NAP_C8:
#line 505
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 505
			i1 = i % naoPtr1->nels;
#line 505
			i2 = i % naoPtr2->nels;
#line 505
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 505
			    naoResultPtr->data.I8[i] = 1;
#line 505
			} else {
#line 505
			    naoResultPtr->data.I8[i] = 
#line 505
				    naoPtr1->data.C8[i1] != naoPtr2->data.C8[i2];
#line 505
			}
#line 505
		    }
#line 505
		    break;
#line 505

#line 505

#line 505

#line 505

#line 505

#line 505
		case NAP_U8:
#line 505
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 505
			i1 = i % naoPtr1->nels;
#line 505
			i2 = i % naoPtr2->nels;
#line 505
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 505
			    naoResultPtr->data.I8[i] = 1;
#line 505
			} else {
#line 505
			    naoResultPtr->data.I8[i] = 
#line 505
				    naoPtr1->data.U8[i1] != naoPtr2->data.U8[i2];
#line 505
			}
#line 505
		    }
#line 505
		    break;
#line 505

#line 505
		case NAP_U16:
#line 505
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 505
			i1 = i % naoPtr1->nels;
#line 505
			i2 = i % naoPtr2->nels;
#line 505
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 505
			    naoResultPtr->data.I8[i] = 1;
#line 505
			} else {
#line 505
			    naoResultPtr->data.I8[i] = 
#line 505
				    naoPtr1->data.U16[i1] != naoPtr2->data.U16[i2];
#line 505
			}
#line 505
		    }
#line 505
		    break;
#line 505

#line 505
		case NAP_U32:
#line 505
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 505
			i1 = i % naoPtr1->nels;
#line 505
			i2 = i % naoPtr2->nels;
#line 505
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 505
			    naoResultPtr->data.I8[i] = 1;
#line 505
			} else {
#line 505
			    naoResultPtr->data.I8[i] = 
#line 505
				    naoPtr1->data.U32[i1] != naoPtr2->data.U32[i2];
#line 505
			}
#line 505
		    }
#line 505
		    break;
#line 505

#line 505

#line 505

#line 505
		case NAP_I8:
#line 505
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 505
			i1 = i % naoPtr1->nels;
#line 505
			i2 = i % naoPtr2->nels;
#line 505
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 505
			    naoResultPtr->data.I8[i] = 1;
#line 505
			} else {
#line 505
			    naoResultPtr->data.I8[i] = 
#line 505
				    naoPtr1->data.I8[i1] != naoPtr2->data.I8[i2];
#line 505
			}
#line 505
		    }
#line 505
		    break;
#line 505

#line 505
		case NAP_I16:
#line 505
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 505
			i1 = i % naoPtr1->nels;
#line 505
			i2 = i % naoPtr2->nels;
#line 505
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 505
			    naoResultPtr->data.I8[i] = 1;
#line 505
			} else {
#line 505
			    naoResultPtr->data.I8[i] = 
#line 505
				    naoPtr1->data.I16[i1] != naoPtr2->data.I16[i2];
#line 505
			}
#line 505
		    }
#line 505
		    break;
#line 505

#line 505
		case NAP_I32:
#line 505
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 505
			i1 = i % naoPtr1->nels;
#line 505
			i2 = i % naoPtr2->nels;
#line 505
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 505
			    naoResultPtr->data.I8[i] = 1;
#line 505
			} else {
#line 505
			    naoResultPtr->data.I8[i] = 
#line 505
				    naoPtr1->data.I32[i1] != naoPtr2->data.I32[i2];
#line 505
			}
#line 505
		    }
#line 505
		    break;
#line 505

#line 505

#line 505

#line 505

#line 505
		case NAP_F32:
#line 505
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 505
			i1 = i % naoPtr1->nels;
#line 505
			i2 = i % naoPtr2->nels;
#line 505
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 505
			    naoResultPtr->data.I8[i] = 1;
#line 505
			} else {
#line 505
			    naoResultPtr->data.I8[i] = 
#line 505
				    naoPtr1->data.F32[i1] != naoPtr2->data.F32[i2];
#line 505
			}
#line 505
		    }
#line 505
		    break;
#line 505

#line 505
		case NAP_F64:
#line 505
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 505
			i1 = i % naoPtr1->nels;
#line 505
			i2 = i % naoPtr2->nels;
#line 505
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 505
			    naoResultPtr->data.I8[i] = 1;
#line 505
			} else {
#line 505
			    naoResultPtr->data.I8[i] = 
#line 505
				    naoPtr1->data.F64[i1] != naoPtr2->data.F64[i2];
#line 505
			}
#line 505
		    }
#line 505
		    break;
#line 505

#line 505

#line 505

#line 505
    default:            /* error */
#line 505
	assert(FALSE);
#line 505
    }
#line 505
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 505
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 505
    return naoResultPtr->id;
#line 505
}
#line 505


#line 506
EXTERN char *
#line 506
Nap_Lt(
#line 506
    NapClientData	*nap_cd,
#line 506
    char		*str1,			/* id of left arg (in) */
#line 506
    char		*str2)			/* id of right arg (in) */
#line 506
{
#line 506
    Nap_dataType	argDataType;
#line 506
    const int		resultHasMissingValue = FALSE;
#line 506
    size_t		i;
#line 506
    size_t		i1;			/* subscript of left arg */
#line 506
    size_t		i2;			/* subscript of right arg */
#line 506
    Nap_NAO		*naoResultPtr;
#line 506
    Nap_NAO		*naoPtr1;
#line 506
    Nap_NAO		*naoPtr2;
#line 506
    int			status;
#line 506

#line 506
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 <  $2", &naoPtr1, &naoPtr2);
#line 506
    CHECK1NULL(status == TCL_OK);
#line 506
    argDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 506
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, argDataType, argDataType,
#line 506
	    NAP_I8, resultHasMissingValue, " ",
#line 506
	    &naoPtr1, &naoPtr2, &naoResultPtr);
#line 506
    CHECK1NULL(status == TCL_OK);
#line 506
    switch (argDataType) {
#line 506

#line 506

#line 506
    
#line 506

#line 506

#line 506
		case NAP_C8:
#line 506
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 506
			i1 = i % naoPtr1->nels;
#line 506
			i2 = i % naoPtr2->nels;
#line 506
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 506
			    naoResultPtr->data.I8[i] = 0;
#line 506
			} else {
#line 506
			    naoResultPtr->data.I8[i] = 
#line 506
				    naoPtr1->data.C8[i1] <  naoPtr2->data.C8[i2];
#line 506
			}
#line 506
		    }
#line 506
		    break;
#line 506

#line 506

#line 506

#line 506

#line 506

#line 506
		case NAP_U8:
#line 506
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 506
			i1 = i % naoPtr1->nels;
#line 506
			i2 = i % naoPtr2->nels;
#line 506
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 506
			    naoResultPtr->data.I8[i] = 0;
#line 506
			} else {
#line 506
			    naoResultPtr->data.I8[i] = 
#line 506
				    naoPtr1->data.U8[i1] <  naoPtr2->data.U8[i2];
#line 506
			}
#line 506
		    }
#line 506
		    break;
#line 506

#line 506
		case NAP_U16:
#line 506
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 506
			i1 = i % naoPtr1->nels;
#line 506
			i2 = i % naoPtr2->nels;
#line 506
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 506
			    naoResultPtr->data.I8[i] = 0;
#line 506
			} else {
#line 506
			    naoResultPtr->data.I8[i] = 
#line 506
				    naoPtr1->data.U16[i1] <  naoPtr2->data.U16[i2];
#line 506
			}
#line 506
		    }
#line 506
		    break;
#line 506

#line 506
		case NAP_U32:
#line 506
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 506
			i1 = i % naoPtr1->nels;
#line 506
			i2 = i % naoPtr2->nels;
#line 506
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 506
			    naoResultPtr->data.I8[i] = 0;
#line 506
			} else {
#line 506
			    naoResultPtr->data.I8[i] = 
#line 506
				    naoPtr1->data.U32[i1] <  naoPtr2->data.U32[i2];
#line 506
			}
#line 506
		    }
#line 506
		    break;
#line 506

#line 506

#line 506

#line 506
		case NAP_I8:
#line 506
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 506
			i1 = i % naoPtr1->nels;
#line 506
			i2 = i % naoPtr2->nels;
#line 506
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 506
			    naoResultPtr->data.I8[i] = 0;
#line 506
			} else {
#line 506
			    naoResultPtr->data.I8[i] = 
#line 506
				    naoPtr1->data.I8[i1] <  naoPtr2->data.I8[i2];
#line 506
			}
#line 506
		    }
#line 506
		    break;
#line 506

#line 506
		case NAP_I16:
#line 506
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 506
			i1 = i % naoPtr1->nels;
#line 506
			i2 = i % naoPtr2->nels;
#line 506
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 506
			    naoResultPtr->data.I8[i] = 0;
#line 506
			} else {
#line 506
			    naoResultPtr->data.I8[i] = 
#line 506
				    naoPtr1->data.I16[i1] <  naoPtr2->data.I16[i2];
#line 506
			}
#line 506
		    }
#line 506
		    break;
#line 506

#line 506
		case NAP_I32:
#line 506
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 506
			i1 = i % naoPtr1->nels;
#line 506
			i2 = i % naoPtr2->nels;
#line 506
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 506
			    naoResultPtr->data.I8[i] = 0;
#line 506
			} else {
#line 506
			    naoResultPtr->data.I8[i] = 
#line 506
				    naoPtr1->data.I32[i1] <  naoPtr2->data.I32[i2];
#line 506
			}
#line 506
		    }
#line 506
		    break;
#line 506

#line 506

#line 506

#line 506

#line 506
		case NAP_F32:
#line 506
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 506
			i1 = i % naoPtr1->nels;
#line 506
			i2 = i % naoPtr2->nels;
#line 506
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 506
			    naoResultPtr->data.I8[i] = 0;
#line 506
			} else {
#line 506
			    naoResultPtr->data.I8[i] = 
#line 506
				    naoPtr1->data.F32[i1] <  naoPtr2->data.F32[i2];
#line 506
			}
#line 506
		    }
#line 506
		    break;
#line 506

#line 506
		case NAP_F64:
#line 506
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 506
			i1 = i % naoPtr1->nels;
#line 506
			i2 = i % naoPtr2->nels;
#line 506
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 506
			    naoResultPtr->data.I8[i] = 0;
#line 506
			} else {
#line 506
			    naoResultPtr->data.I8[i] = 
#line 506
				    naoPtr1->data.F64[i1] <  naoPtr2->data.F64[i2];
#line 506
			}
#line 506
		    }
#line 506
		    break;
#line 506

#line 506

#line 506

#line 506
    default:            /* error */
#line 506
	assert(FALSE);
#line 506
    }
#line 506
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 506
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 506
    return naoResultPtr->id;
#line 506
}
#line 506


#line 507
EXTERN char *
#line 507
Nap_Le(
#line 507
    NapClientData	*nap_cd,
#line 507
    char		*str1,			/* id of left arg (in) */
#line 507
    char		*str2)			/* id of right arg (in) */
#line 507
{
#line 507
    Nap_dataType	argDataType;
#line 507
    const int		resultHasMissingValue = FALSE;
#line 507
    size_t		i;
#line 507
    size_t		i1;			/* subscript of left arg */
#line 507
    size_t		i2;			/* subscript of right arg */
#line 507
    Nap_NAO		*naoResultPtr;
#line 507
    Nap_NAO		*naoPtr1;
#line 507
    Nap_NAO		*naoPtr2;
#line 507
    int			status;
#line 507

#line 507
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 <= $2", &naoPtr1, &naoPtr2);
#line 507
    CHECK1NULL(status == TCL_OK);
#line 507
    argDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 507
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, argDataType, argDataType,
#line 507
	    NAP_I8, resultHasMissingValue, " ",
#line 507
	    &naoPtr1, &naoPtr2, &naoResultPtr);
#line 507
    CHECK1NULL(status == TCL_OK);
#line 507
    switch (argDataType) {
#line 507

#line 507

#line 507
    
#line 507

#line 507

#line 507
		case NAP_C8:
#line 507
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 507
			i1 = i % naoPtr1->nels;
#line 507
			i2 = i % naoPtr2->nels;
#line 507
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 507
			    naoResultPtr->data.I8[i] = 0;
#line 507
			} else {
#line 507
			    naoResultPtr->data.I8[i] = 
#line 507
				    naoPtr1->data.C8[i1] <= naoPtr2->data.C8[i2];
#line 507
			}
#line 507
		    }
#line 507
		    break;
#line 507

#line 507

#line 507

#line 507

#line 507

#line 507
		case NAP_U8:
#line 507
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 507
			i1 = i % naoPtr1->nels;
#line 507
			i2 = i % naoPtr2->nels;
#line 507
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 507
			    naoResultPtr->data.I8[i] = 0;
#line 507
			} else {
#line 507
			    naoResultPtr->data.I8[i] = 
#line 507
				    naoPtr1->data.U8[i1] <= naoPtr2->data.U8[i2];
#line 507
			}
#line 507
		    }
#line 507
		    break;
#line 507

#line 507
		case NAP_U16:
#line 507
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 507
			i1 = i % naoPtr1->nels;
#line 507
			i2 = i % naoPtr2->nels;
#line 507
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 507
			    naoResultPtr->data.I8[i] = 0;
#line 507
			} else {
#line 507
			    naoResultPtr->data.I8[i] = 
#line 507
				    naoPtr1->data.U16[i1] <= naoPtr2->data.U16[i2];
#line 507
			}
#line 507
		    }
#line 507
		    break;
#line 507

#line 507
		case NAP_U32:
#line 507
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 507
			i1 = i % naoPtr1->nels;
#line 507
			i2 = i % naoPtr2->nels;
#line 507
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 507
			    naoResultPtr->data.I8[i] = 0;
#line 507
			} else {
#line 507
			    naoResultPtr->data.I8[i] = 
#line 507
				    naoPtr1->data.U32[i1] <= naoPtr2->data.U32[i2];
#line 507
			}
#line 507
		    }
#line 507
		    break;
#line 507

#line 507

#line 507

#line 507
		case NAP_I8:
#line 507
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 507
			i1 = i % naoPtr1->nels;
#line 507
			i2 = i % naoPtr2->nels;
#line 507
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 507
			    naoResultPtr->data.I8[i] = 0;
#line 507
			} else {
#line 507
			    naoResultPtr->data.I8[i] = 
#line 507
				    naoPtr1->data.I8[i1] <= naoPtr2->data.I8[i2];
#line 507
			}
#line 507
		    }
#line 507
		    break;
#line 507

#line 507
		case NAP_I16:
#line 507
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 507
			i1 = i % naoPtr1->nels;
#line 507
			i2 = i % naoPtr2->nels;
#line 507
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 507
			    naoResultPtr->data.I8[i] = 0;
#line 507
			} else {
#line 507
			    naoResultPtr->data.I8[i] = 
#line 507
				    naoPtr1->data.I16[i1] <= naoPtr2->data.I16[i2];
#line 507
			}
#line 507
		    }
#line 507
		    break;
#line 507

#line 507
		case NAP_I32:
#line 507
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 507
			i1 = i % naoPtr1->nels;
#line 507
			i2 = i % naoPtr2->nels;
#line 507
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 507
			    naoResultPtr->data.I8[i] = 0;
#line 507
			} else {
#line 507
			    naoResultPtr->data.I8[i] = 
#line 507
				    naoPtr1->data.I32[i1] <= naoPtr2->data.I32[i2];
#line 507
			}
#line 507
		    }
#line 507
		    break;
#line 507

#line 507

#line 507

#line 507

#line 507
		case NAP_F32:
#line 507
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 507
			i1 = i % naoPtr1->nels;
#line 507
			i2 = i % naoPtr2->nels;
#line 507
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 507
			    naoResultPtr->data.I8[i] = 0;
#line 507
			} else {
#line 507
			    naoResultPtr->data.I8[i] = 
#line 507
				    naoPtr1->data.F32[i1] <= naoPtr2->data.F32[i2];
#line 507
			}
#line 507
		    }
#line 507
		    break;
#line 507

#line 507
		case NAP_F64:
#line 507
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 507
			i1 = i % naoPtr1->nels;
#line 507
			i2 = i % naoPtr2->nels;
#line 507
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 507
			    naoResultPtr->data.I8[i] = 0;
#line 507
			} else {
#line 507
			    naoResultPtr->data.I8[i] = 
#line 507
				    naoPtr1->data.F64[i1] <= naoPtr2->data.F64[i2];
#line 507
			}
#line 507
		    }
#line 507
		    break;
#line 507

#line 507

#line 507

#line 507
    default:            /* error */
#line 507
	assert(FALSE);
#line 507
    }
#line 507
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 507
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 507
    return naoResultPtr->id;
#line 507
}
#line 507


#line 508
EXTERN char *
#line 508
Nap_Gt(
#line 508
    NapClientData	*nap_cd,
#line 508
    char		*str1,			/* id of left arg (in) */
#line 508
    char		*str2)			/* id of right arg (in) */
#line 508
{
#line 508
    Nap_dataType	argDataType;
#line 508
    const int		resultHasMissingValue = FALSE;
#line 508
    size_t		i;
#line 508
    size_t		i1;			/* subscript of left arg */
#line 508
    size_t		i2;			/* subscript of right arg */
#line 508
    Nap_NAO		*naoResultPtr;
#line 508
    Nap_NAO		*naoPtr1;
#line 508
    Nap_NAO		*naoPtr2;
#line 508
    int			status;
#line 508

#line 508
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 >  $2", &naoPtr1, &naoPtr2);
#line 508
    CHECK1NULL(status == TCL_OK);
#line 508
    argDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 508
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, argDataType, argDataType,
#line 508
	    NAP_I8, resultHasMissingValue, " ",
#line 508
	    &naoPtr1, &naoPtr2, &naoResultPtr);
#line 508
    CHECK1NULL(status == TCL_OK);
#line 508
    switch (argDataType) {
#line 508

#line 508

#line 508
    
#line 508

#line 508

#line 508
		case NAP_C8:
#line 508
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 508
			i1 = i % naoPtr1->nels;
#line 508
			i2 = i % naoPtr2->nels;
#line 508
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 508
			    naoResultPtr->data.I8[i] = 0;
#line 508
			} else {
#line 508
			    naoResultPtr->data.I8[i] = 
#line 508
				    naoPtr1->data.C8[i1] >  naoPtr2->data.C8[i2];
#line 508
			}
#line 508
		    }
#line 508
		    break;
#line 508

#line 508

#line 508

#line 508

#line 508

#line 508
		case NAP_U8:
#line 508
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 508
			i1 = i % naoPtr1->nels;
#line 508
			i2 = i % naoPtr2->nels;
#line 508
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 508
			    naoResultPtr->data.I8[i] = 0;
#line 508
			} else {
#line 508
			    naoResultPtr->data.I8[i] = 
#line 508
				    naoPtr1->data.U8[i1] >  naoPtr2->data.U8[i2];
#line 508
			}
#line 508
		    }
#line 508
		    break;
#line 508

#line 508
		case NAP_U16:
#line 508
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 508
			i1 = i % naoPtr1->nels;
#line 508
			i2 = i % naoPtr2->nels;
#line 508
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 508
			    naoResultPtr->data.I8[i] = 0;
#line 508
			} else {
#line 508
			    naoResultPtr->data.I8[i] = 
#line 508
				    naoPtr1->data.U16[i1] >  naoPtr2->data.U16[i2];
#line 508
			}
#line 508
		    }
#line 508
		    break;
#line 508

#line 508
		case NAP_U32:
#line 508
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 508
			i1 = i % naoPtr1->nels;
#line 508
			i2 = i % naoPtr2->nels;
#line 508
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 508
			    naoResultPtr->data.I8[i] = 0;
#line 508
			} else {
#line 508
			    naoResultPtr->data.I8[i] = 
#line 508
				    naoPtr1->data.U32[i1] >  naoPtr2->data.U32[i2];
#line 508
			}
#line 508
		    }
#line 508
		    break;
#line 508

#line 508

#line 508

#line 508
		case NAP_I8:
#line 508
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 508
			i1 = i % naoPtr1->nels;
#line 508
			i2 = i % naoPtr2->nels;
#line 508
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 508
			    naoResultPtr->data.I8[i] = 0;
#line 508
			} else {
#line 508
			    naoResultPtr->data.I8[i] = 
#line 508
				    naoPtr1->data.I8[i1] >  naoPtr2->data.I8[i2];
#line 508
			}
#line 508
		    }
#line 508
		    break;
#line 508

#line 508
		case NAP_I16:
#line 508
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 508
			i1 = i % naoPtr1->nels;
#line 508
			i2 = i % naoPtr2->nels;
#line 508
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 508
			    naoResultPtr->data.I8[i] = 0;
#line 508
			} else {
#line 508
			    naoResultPtr->data.I8[i] = 
#line 508
				    naoPtr1->data.I16[i1] >  naoPtr2->data.I16[i2];
#line 508
			}
#line 508
		    }
#line 508
		    break;
#line 508

#line 508
		case NAP_I32:
#line 508
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 508
			i1 = i % naoPtr1->nels;
#line 508
			i2 = i % naoPtr2->nels;
#line 508
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 508
			    naoResultPtr->data.I8[i] = 0;
#line 508
			} else {
#line 508
			    naoResultPtr->data.I8[i] = 
#line 508
				    naoPtr1->data.I32[i1] >  naoPtr2->data.I32[i2];
#line 508
			}
#line 508
		    }
#line 508
		    break;
#line 508

#line 508

#line 508

#line 508

#line 508
		case NAP_F32:
#line 508
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 508
			i1 = i % naoPtr1->nels;
#line 508
			i2 = i % naoPtr2->nels;
#line 508
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 508
			    naoResultPtr->data.I8[i] = 0;
#line 508
			} else {
#line 508
			    naoResultPtr->data.I8[i] = 
#line 508
				    naoPtr1->data.F32[i1] >  naoPtr2->data.F32[i2];
#line 508
			}
#line 508
		    }
#line 508
		    break;
#line 508

#line 508
		case NAP_F64:
#line 508
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 508
			i1 = i % naoPtr1->nels;
#line 508
			i2 = i % naoPtr2->nels;
#line 508
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 508
			    naoResultPtr->data.I8[i] = 0;
#line 508
			} else {
#line 508
			    naoResultPtr->data.I8[i] = 
#line 508
				    naoPtr1->data.F64[i1] >  naoPtr2->data.F64[i2];
#line 508
			}
#line 508
		    }
#line 508
		    break;
#line 508

#line 508

#line 508

#line 508
    default:            /* error */
#line 508
	assert(FALSE);
#line 508
    }
#line 508
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 508
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 508
    return naoResultPtr->id;
#line 508
}
#line 508


#line 509
EXTERN char *
#line 509
Nap_Ge(
#line 509
    NapClientData	*nap_cd,
#line 509
    char		*str1,			/* id of left arg (in) */
#line 509
    char		*str2)			/* id of right arg (in) */
#line 509
{
#line 509
    Nap_dataType	argDataType;
#line 509
    const int		resultHasMissingValue = FALSE;
#line 509
    size_t		i;
#line 509
    size_t		i1;			/* subscript of left arg */
#line 509
    size_t		i2;			/* subscript of right arg */
#line 509
    Nap_NAO		*naoResultPtr;
#line 509
    Nap_NAO		*naoPtr1;
#line 509
    Nap_NAO		*naoPtr2;
#line 509
    int			status;
#line 509

#line 509
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 >= $2", &naoPtr1, &naoPtr2);
#line 509
    CHECK1NULL(status == TCL_OK);
#line 509
    argDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
#line 509
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, argDataType, argDataType,
#line 509
	    NAP_I8, resultHasMissingValue, " ",
#line 509
	    &naoPtr1, &naoPtr2, &naoResultPtr);
#line 509
    CHECK1NULL(status == TCL_OK);
#line 509
    switch (argDataType) {
#line 509

#line 509

#line 509
    
#line 509

#line 509

#line 509
		case NAP_C8:
#line 509
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 509
			i1 = i % naoPtr1->nels;
#line 509
			i2 = i % naoPtr2->nels;
#line 509
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 509
			    naoResultPtr->data.I8[i] = 0;
#line 509
			} else {
#line 509
			    naoResultPtr->data.I8[i] = 
#line 509
				    naoPtr1->data.C8[i1] >= naoPtr2->data.C8[i2];
#line 509
			}
#line 509
		    }
#line 509
		    break;
#line 509

#line 509

#line 509

#line 509

#line 509

#line 509
		case NAP_U8:
#line 509
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 509
			i1 = i % naoPtr1->nels;
#line 509
			i2 = i % naoPtr2->nels;
#line 509
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 509
			    naoResultPtr->data.I8[i] = 0;
#line 509
			} else {
#line 509
			    naoResultPtr->data.I8[i] = 
#line 509
				    naoPtr1->data.U8[i1] >= naoPtr2->data.U8[i2];
#line 509
			}
#line 509
		    }
#line 509
		    break;
#line 509

#line 509
		case NAP_U16:
#line 509
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 509
			i1 = i % naoPtr1->nels;
#line 509
			i2 = i % naoPtr2->nels;
#line 509
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 509
			    naoResultPtr->data.I8[i] = 0;
#line 509
			} else {
#line 509
			    naoResultPtr->data.I8[i] = 
#line 509
				    naoPtr1->data.U16[i1] >= naoPtr2->data.U16[i2];
#line 509
			}
#line 509
		    }
#line 509
		    break;
#line 509

#line 509
		case NAP_U32:
#line 509
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 509
			i1 = i % naoPtr1->nels;
#line 509
			i2 = i % naoPtr2->nels;
#line 509
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 509
			    naoResultPtr->data.I8[i] = 0;
#line 509
			} else {
#line 509
			    naoResultPtr->data.I8[i] = 
#line 509
				    naoPtr1->data.U32[i1] >= naoPtr2->data.U32[i2];
#line 509
			}
#line 509
		    }
#line 509
		    break;
#line 509

#line 509

#line 509

#line 509
		case NAP_I8:
#line 509
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 509
			i1 = i % naoPtr1->nels;
#line 509
			i2 = i % naoPtr2->nels;
#line 509
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 509
			    naoResultPtr->data.I8[i] = 0;
#line 509
			} else {
#line 509
			    naoResultPtr->data.I8[i] = 
#line 509
				    naoPtr1->data.I8[i1] >= naoPtr2->data.I8[i2];
#line 509
			}
#line 509
		    }
#line 509
		    break;
#line 509

#line 509
		case NAP_I16:
#line 509
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 509
			i1 = i % naoPtr1->nels;
#line 509
			i2 = i % naoPtr2->nels;
#line 509
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 509
			    naoResultPtr->data.I8[i] = 0;
#line 509
			} else {
#line 509
			    naoResultPtr->data.I8[i] = 
#line 509
				    naoPtr1->data.I16[i1] >= naoPtr2->data.I16[i2];
#line 509
			}
#line 509
		    }
#line 509
		    break;
#line 509

#line 509
		case NAP_I32:
#line 509
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 509
			i1 = i % naoPtr1->nels;
#line 509
			i2 = i % naoPtr2->nels;
#line 509
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 509
			    naoResultPtr->data.I8[i] = 0;
#line 509
			} else {
#line 509
			    naoResultPtr->data.I8[i] = 
#line 509
				    naoPtr1->data.I32[i1] >= naoPtr2->data.I32[i2];
#line 509
			}
#line 509
		    }
#line 509
		    break;
#line 509

#line 509

#line 509

#line 509

#line 509
		case NAP_F32:
#line 509
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 509
			i1 = i % naoPtr1->nels;
#line 509
			i2 = i % naoPtr2->nels;
#line 509
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 509
			    naoResultPtr->data.I8[i] = 0;
#line 509
			} else {
#line 509
			    naoResultPtr->data.I8[i] = 
#line 509
				    naoPtr1->data.F32[i1] >= naoPtr2->data.F32[i2];
#line 509
			}
#line 509
		    }
#line 509
		    break;
#line 509

#line 509
		case NAP_F64:
#line 509
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 509
			i1 = i % naoPtr1->nels;
#line 509
			i2 = i % naoPtr2->nels;
#line 509
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 509
			    naoResultPtr->data.I8[i] = 0;
#line 509
			} else {
#line 509
			    naoResultPtr->data.I8[i] = 
#line 509
				    naoPtr1->data.F64[i1] >= naoPtr2->data.F64[i2];
#line 509
			}
#line 509
		    }
#line 509
		    break;
#line 509

#line 509

#line 509

#line 509
    default:            /* error */
#line 509
	assert(FALSE);
#line 509
    }
#line 509
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 509
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 509
    return naoResultPtr->id;
#line 509
}
#line 509


#line 550 "/home/dav480/tcl/nap/generic/napDyad.c,m4"


#line 551
EXTERN char *
#line 551
Nap_BitAnd(
#line 551
    NapClientData	*nap_cd,
#line 551
    char		*str1,			/* id of left arg (in) */
#line 551
    char		*str2)			/* id of right arg (in) */
#line 551
{
#line 551
    const int		resultHasMissingValue = FALSE;
#line 551
    size_t		i;
#line 551
    size_t		i1;			/* subscript of left arg */
#line 551
    size_t		i2;			/* subscript of right arg */
#line 551
    Nap_NAO		*naoResultPtr;
#line 551
    Nap_NAO		*naoPtr1;
#line 551
    Nap_NAO		*naoPtr2;
#line 551
    Nap_dataType        resultDataType;
#line 551
    int			status;
#line 551

#line 551
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 & $2", &naoPtr1, &naoPtr2);
#line 551
    CHECK1NULL(status == TCL_OK);
#line 551
    resultDataType = Min(NAP_U32, Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType));
#line 551
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 551
	    resultHasMissingValue, " ", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 551
    CHECK1NULL(status == TCL_OK);
#line 551
    switch (resultDataType) {
#line 551

#line 551
    
#line 551

#line 551

#line 551
		case NAP_U8:
#line 551
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 551
			i1 = i % naoPtr1->nels;
#line 551
			i2 = i % naoPtr2->nels;
#line 551
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 551
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 551
			} else {
#line 551
			    naoResultPtr->data.U8[i] = 
#line 551
				    naoPtr1->data.U8[i1] & naoPtr2->data.U8[i2];
#line 551
			}
#line 551
		    }
#line 551
		    break;
#line 551

#line 551
		case NAP_U16:
#line 551
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 551
			i1 = i % naoPtr1->nels;
#line 551
			i2 = i % naoPtr2->nels;
#line 551
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 551
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 551
			} else {
#line 551
			    naoResultPtr->data.U16[i] = 
#line 551
				    naoPtr1->data.U16[i1] & naoPtr2->data.U16[i2];
#line 551
			}
#line 551
		    }
#line 551
		    break;
#line 551

#line 551
		case NAP_U32:
#line 551
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 551
			i1 = i % naoPtr1->nels;
#line 551
			i2 = i % naoPtr2->nels;
#line 551
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 551
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 551
			} else {
#line 551
			    naoResultPtr->data.U32[i] = 
#line 551
				    naoPtr1->data.U32[i1] & naoPtr2->data.U32[i2];
#line 551
			}
#line 551
		    }
#line 551
		    break;
#line 551

#line 551

#line 551

#line 551
		case NAP_I8:
#line 551
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 551
			i1 = i % naoPtr1->nels;
#line 551
			i2 = i % naoPtr2->nels;
#line 551
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 551
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 551
			} else {
#line 551
			    naoResultPtr->data.I8[i] = 
#line 551
				    naoPtr1->data.I8[i1] & naoPtr2->data.I8[i2];
#line 551
			}
#line 551
		    }
#line 551
		    break;
#line 551

#line 551
		case NAP_I16:
#line 551
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 551
			i1 = i % naoPtr1->nels;
#line 551
			i2 = i % naoPtr2->nels;
#line 551
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 551
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 551
			} else {
#line 551
			    naoResultPtr->data.I16[i] = 
#line 551
				    naoPtr1->data.I16[i1] & naoPtr2->data.I16[i2];
#line 551
			}
#line 551
		    }
#line 551
		    break;
#line 551

#line 551
		case NAP_I32:
#line 551
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 551
			i1 = i % naoPtr1->nels;
#line 551
			i2 = i % naoPtr2->nels;
#line 551
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 551
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 551
			} else {
#line 551
			    naoResultPtr->data.I32[i] = 
#line 551
				    naoPtr1->data.I32[i1] & naoPtr2->data.I32[i2];
#line 551
			}
#line 551
		    }
#line 551
		    break;
#line 551

#line 551

#line 551
    default:            /* error */
#line 551
	assert(FALSE);
#line 551
    }
#line 551
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 551
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 551
    return naoResultPtr->id;
#line 551
}
#line 551


#line 552
EXTERN char *
#line 552
Nap_BitOr(
#line 552
    NapClientData	*nap_cd,
#line 552
    char		*str1,			/* id of left arg (in) */
#line 552
    char		*str2)			/* id of right arg (in) */
#line 552
{
#line 552
    const int		resultHasMissingValue = FALSE;
#line 552
    size_t		i;
#line 552
    size_t		i1;			/* subscript of left arg */
#line 552
    size_t		i2;			/* subscript of right arg */
#line 552
    Nap_NAO		*naoResultPtr;
#line 552
    Nap_NAO		*naoPtr1;
#line 552
    Nap_NAO		*naoPtr2;
#line 552
    Nap_dataType        resultDataType;
#line 552
    int			status;
#line 552

#line 552
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 | $2", &naoPtr1, &naoPtr2);
#line 552
    CHECK1NULL(status == TCL_OK);
#line 552
    resultDataType = Min(NAP_U32, Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType));
#line 552
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 552
	    resultHasMissingValue, " ", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 552
    CHECK1NULL(status == TCL_OK);
#line 552
    switch (resultDataType) {
#line 552

#line 552
    
#line 552

#line 552

#line 552
		case NAP_U8:
#line 552
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 552
			i1 = i % naoPtr1->nels;
#line 552
			i2 = i % naoPtr2->nels;
#line 552
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 552
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 552
			} else {
#line 552
			    naoResultPtr->data.U8[i] = 
#line 552
				    naoPtr1->data.U8[i1] | naoPtr2->data.U8[i2];
#line 552
			}
#line 552
		    }
#line 552
		    break;
#line 552

#line 552
		case NAP_U16:
#line 552
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 552
			i1 = i % naoPtr1->nels;
#line 552
			i2 = i % naoPtr2->nels;
#line 552
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 552
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 552
			} else {
#line 552
			    naoResultPtr->data.U16[i] = 
#line 552
				    naoPtr1->data.U16[i1] | naoPtr2->data.U16[i2];
#line 552
			}
#line 552
		    }
#line 552
		    break;
#line 552

#line 552
		case NAP_U32:
#line 552
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 552
			i1 = i % naoPtr1->nels;
#line 552
			i2 = i % naoPtr2->nels;
#line 552
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 552
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 552
			} else {
#line 552
			    naoResultPtr->data.U32[i] = 
#line 552
				    naoPtr1->data.U32[i1] | naoPtr2->data.U32[i2];
#line 552
			}
#line 552
		    }
#line 552
		    break;
#line 552

#line 552

#line 552

#line 552
		case NAP_I8:
#line 552
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 552
			i1 = i % naoPtr1->nels;
#line 552
			i2 = i % naoPtr2->nels;
#line 552
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 552
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 552
			} else {
#line 552
			    naoResultPtr->data.I8[i] = 
#line 552
				    naoPtr1->data.I8[i1] | naoPtr2->data.I8[i2];
#line 552
			}
#line 552
		    }
#line 552
		    break;
#line 552

#line 552
		case NAP_I16:
#line 552
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 552
			i1 = i % naoPtr1->nels;
#line 552
			i2 = i % naoPtr2->nels;
#line 552
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 552
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 552
			} else {
#line 552
			    naoResultPtr->data.I16[i] = 
#line 552
				    naoPtr1->data.I16[i1] | naoPtr2->data.I16[i2];
#line 552
			}
#line 552
		    }
#line 552
		    break;
#line 552

#line 552
		case NAP_I32:
#line 552
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 552
			i1 = i % naoPtr1->nels;
#line 552
			i2 = i % naoPtr2->nels;
#line 552
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 552
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 552
			} else {
#line 552
			    naoResultPtr->data.I32[i] = 
#line 552
				    naoPtr1->data.I32[i1] | naoPtr2->data.I32[i2];
#line 552
			}
#line 552
		    }
#line 552
		    break;
#line 552

#line 552

#line 552
    default:            /* error */
#line 552
	assert(FALSE);
#line 552
    }
#line 552
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 552
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 552
    return naoResultPtr->id;
#line 552
}
#line 552


#line 553
EXTERN char *
#line 553
Nap_BitXor(
#line 553
    NapClientData	*nap_cd,
#line 553
    char		*str1,			/* id of left arg (in) */
#line 553
    char		*str2)			/* id of right arg (in) */
#line 553
{
#line 553
    const int		resultHasMissingValue = FALSE;
#line 553
    size_t		i;
#line 553
    size_t		i1;			/* subscript of left arg */
#line 553
    size_t		i2;			/* subscript of right arg */
#line 553
    Nap_NAO		*naoResultPtr;
#line 553
    Nap_NAO		*naoPtr1;
#line 553
    Nap_NAO		*naoPtr2;
#line 553
    Nap_dataType        resultDataType;
#line 553
    int			status;
#line 553

#line 553
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 ^ $2", &naoPtr1, &naoPtr2);
#line 553
    CHECK1NULL(status == TCL_OK);
#line 553
    resultDataType = Min(NAP_U32, Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType));
#line 553
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
#line 553
	    resultHasMissingValue, " ", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 553
    CHECK1NULL(status == TCL_OK);
#line 553
    switch (resultDataType) {
#line 553

#line 553
    
#line 553

#line 553

#line 553
		case NAP_U8:
#line 553
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 553
			i1 = i % naoPtr1->nels;
#line 553
			i2 = i % naoPtr2->nels;
#line 553
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 553
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 553
			} else {
#line 553
			    naoResultPtr->data.U8[i] = 
#line 553
				    naoPtr1->data.U8[i1] ^ naoPtr2->data.U8[i2];
#line 553
			}
#line 553
		    }
#line 553
		    break;
#line 553

#line 553
		case NAP_U16:
#line 553
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 553
			i1 = i % naoPtr1->nels;
#line 553
			i2 = i % naoPtr2->nels;
#line 553
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 553
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 553
			} else {
#line 553
			    naoResultPtr->data.U16[i] = 
#line 553
				    naoPtr1->data.U16[i1] ^ naoPtr2->data.U16[i2];
#line 553
			}
#line 553
		    }
#line 553
		    break;
#line 553

#line 553
		case NAP_U32:
#line 553
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 553
			i1 = i % naoPtr1->nels;
#line 553
			i2 = i % naoPtr2->nels;
#line 553
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 553
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 553
			} else {
#line 553
			    naoResultPtr->data.U32[i] = 
#line 553
				    naoPtr1->data.U32[i1] ^ naoPtr2->data.U32[i2];
#line 553
			}
#line 553
		    }
#line 553
		    break;
#line 553

#line 553

#line 553

#line 553
		case NAP_I8:
#line 553
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 553
			i1 = i % naoPtr1->nels;
#line 553
			i2 = i % naoPtr2->nels;
#line 553
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 553
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 553
			} else {
#line 553
			    naoResultPtr->data.I8[i] = 
#line 553
				    naoPtr1->data.I8[i1] ^ naoPtr2->data.I8[i2];
#line 553
			}
#line 553
		    }
#line 553
		    break;
#line 553

#line 553
		case NAP_I16:
#line 553
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 553
			i1 = i % naoPtr1->nels;
#line 553
			i2 = i % naoPtr2->nels;
#line 553
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 553
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 553
			} else {
#line 553
			    naoResultPtr->data.I16[i] = 
#line 553
				    naoPtr1->data.I16[i1] ^ naoPtr2->data.I16[i2];
#line 553
			}
#line 553
		    }
#line 553
		    break;
#line 553

#line 553
		case NAP_I32:
#line 553
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 553
			i1 = i % naoPtr1->nels;
#line 553
			i2 = i % naoPtr2->nels;
#line 553
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 553
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 553
			} else {
#line 553
			    naoResultPtr->data.I32[i] = 
#line 553
				    naoPtr1->data.I32[i1] ^ naoPtr2->data.I32[i2];
#line 553
			}
#line 553
		    }
#line 553
		    break;
#line 553

#line 553

#line 553
    default:            /* error */
#line 553
	assert(FALSE);
#line 553
    }
#line 553
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 553
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 553
    return naoResultPtr->id;
#line 553
}
#line 553


#line 607 "/home/dav480/tcl/nap/generic/napDyad.c,m4"


#line 608
EXTERN char *
#line 608
Nap_ShiftLeft(
#line 608
    NapClientData	*nap_cd,
#line 608
    char		*str1,			/* id of left arg (in) */
#line 608
    char		*str2)			/* id of right arg (in) */
#line 608
{
#line 608
    const int		resultHasMissingValue = FALSE;
#line 608
    size_t		i;
#line 608
    size_t		i1;			/* subscript of left arg */
#line 608
    size_t		i2;			/* subscript of right arg */
#line 608
    Nap_NAO		*naoResultPtr;
#line 608
    Nap_NAO		*naoPtr1;
#line 608
    Nap_NAO		*naoPtr2;
#line 608
    int			status;
#line 608

#line 608
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 << $2", &naoPtr1, &naoPtr2);
#line 608
    CHECK1NULL(status == TCL_OK);
#line 608
    CHECK2NULL(Nap_TypeIsInteger(naoPtr1->dataType) && Nap_TypeIsInteger(naoPtr2->dataType), 	    "Nap_ShiftLeft: Shift operator has non-integer argument");
#line 608
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, naoPtr1->dataType, naoPtr2->dataType,
#line 608
	    naoPtr1->dataType, resultHasMissingValue, " ", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 608
    CHECK1NULL(status == TCL_OK);
#line 608
    switch (naoResultPtr->dataType) {
#line 608

#line 608
    
#line 608

#line 608

#line 608
	case NAP_U8:
#line 608
	    switch (naoPtr2->dataType) {
#line 608
	    
#line 608

#line 608

#line 608
		case NAP_U8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U8[i] = 
#line 608
				    naoPtr1->data.U8[i1] << naoPtr2->data.U8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U8[i] = 
#line 608
				    naoPtr1->data.U8[i1] << naoPtr2->data.U16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U8[i] = 
#line 608
				    naoPtr1->data.U8[i1] << naoPtr2->data.U32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608

#line 608
		case NAP_I8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U8[i] = 
#line 608
				    naoPtr1->data.U8[i1] << naoPtr2->data.I8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U8[i] = 
#line 608
				    naoPtr1->data.U8[i1] << naoPtr2->data.I16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U8[i] = 
#line 608
				    naoPtr1->data.U8[i1] << naoPtr2->data.I32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608
	    default:            /* error */
#line 608
		assert(FALSE);
#line 608
	    }
#line 608
	    break;
#line 608

#line 608
	case NAP_U16:
#line 608
	    switch (naoPtr2->dataType) {
#line 608
	    
#line 608

#line 608

#line 608
		case NAP_U8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U16[i] = 
#line 608
				    naoPtr1->data.U16[i1] << naoPtr2->data.U8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U16[i] = 
#line 608
				    naoPtr1->data.U16[i1] << naoPtr2->data.U16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U16[i] = 
#line 608
				    naoPtr1->data.U16[i1] << naoPtr2->data.U32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608

#line 608
		case NAP_I8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U16[i] = 
#line 608
				    naoPtr1->data.U16[i1] << naoPtr2->data.I8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U16[i] = 
#line 608
				    naoPtr1->data.U16[i1] << naoPtr2->data.I16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U16[i] = 
#line 608
				    naoPtr1->data.U16[i1] << naoPtr2->data.I32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608
	    default:            /* error */
#line 608
		assert(FALSE);
#line 608
	    }
#line 608
	    break;
#line 608

#line 608
	case NAP_U32:
#line 608
	    switch (naoPtr2->dataType) {
#line 608
	    
#line 608

#line 608

#line 608
		case NAP_U8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U32[i] = 
#line 608
				    naoPtr1->data.U32[i1] << naoPtr2->data.U8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U32[i] = 
#line 608
				    naoPtr1->data.U32[i1] << naoPtr2->data.U16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U32[i] = 
#line 608
				    naoPtr1->data.U32[i1] << naoPtr2->data.U32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608

#line 608
		case NAP_I8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U32[i] = 
#line 608
				    naoPtr1->data.U32[i1] << naoPtr2->data.I8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U32[i] = 
#line 608
				    naoPtr1->data.U32[i1] << naoPtr2->data.I16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.U32[i] = 
#line 608
				    naoPtr1->data.U32[i1] << naoPtr2->data.I32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608
	    default:            /* error */
#line 608
		assert(FALSE);
#line 608
	    }
#line 608
	    break;
#line 608

#line 608

#line 608

#line 608
	case NAP_I8:
#line 608
	    switch (naoPtr2->dataType) {
#line 608
	    
#line 608

#line 608

#line 608
		case NAP_U8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I8[i] = 
#line 608
				    naoPtr1->data.I8[i1] << naoPtr2->data.U8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I8[i] = 
#line 608
				    naoPtr1->data.I8[i1] << naoPtr2->data.U16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I8[i] = 
#line 608
				    naoPtr1->data.I8[i1] << naoPtr2->data.U32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608

#line 608
		case NAP_I8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I8[i] = 
#line 608
				    naoPtr1->data.I8[i1] << naoPtr2->data.I8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I8[i] = 
#line 608
				    naoPtr1->data.I8[i1] << naoPtr2->data.I16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I8[i] = 
#line 608
				    naoPtr1->data.I8[i1] << naoPtr2->data.I32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608
	    default:            /* error */
#line 608
		assert(FALSE);
#line 608
	    }
#line 608
	    break;
#line 608

#line 608
	case NAP_I16:
#line 608
	    switch (naoPtr2->dataType) {
#line 608
	    
#line 608

#line 608

#line 608
		case NAP_U8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I16[i] = 
#line 608
				    naoPtr1->data.I16[i1] << naoPtr2->data.U8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I16[i] = 
#line 608
				    naoPtr1->data.I16[i1] << naoPtr2->data.U16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I16[i] = 
#line 608
				    naoPtr1->data.I16[i1] << naoPtr2->data.U32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608

#line 608
		case NAP_I8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I16[i] = 
#line 608
				    naoPtr1->data.I16[i1] << naoPtr2->data.I8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I16[i] = 
#line 608
				    naoPtr1->data.I16[i1] << naoPtr2->data.I16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I16[i] = 
#line 608
				    naoPtr1->data.I16[i1] << naoPtr2->data.I32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608
	    default:            /* error */
#line 608
		assert(FALSE);
#line 608
	    }
#line 608
	    break;
#line 608

#line 608
	case NAP_I32:
#line 608
	    switch (naoPtr2->dataType) {
#line 608
	    
#line 608

#line 608

#line 608
		case NAP_U8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I32[i] = 
#line 608
				    naoPtr1->data.I32[i1] << naoPtr2->data.U8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I32[i] = 
#line 608
				    naoPtr1->data.I32[i1] << naoPtr2->data.U16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_U32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I32[i] = 
#line 608
				    naoPtr1->data.I32[i1] << naoPtr2->data.U32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608

#line 608
		case NAP_I8:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I32[i] = 
#line 608
				    naoPtr1->data.I32[i1] << naoPtr2->data.I8[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I16:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I32[i] = 
#line 608
				    naoPtr1->data.I32[i1] << naoPtr2->data.I16[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608
		case NAP_I32:
#line 608
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 608
			i1 = i % naoPtr1->nels;
#line 608
			i2 = i % naoPtr2->nels;
#line 608
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 608
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 608
			} else {
#line 608
			    naoResultPtr->data.I32[i] = 
#line 608
				    naoPtr1->data.I32[i1] << naoPtr2->data.I32[i2];
#line 608
			}
#line 608
		    }
#line 608
		    break;
#line 608

#line 608

#line 608
	    default:            /* error */
#line 608
		assert(FALSE);
#line 608
	    }
#line 608
	    break;
#line 608

#line 608

#line 608
    default:            /* error */
#line 608
	assert(FALSE);
#line 608
    }
#line 608
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 608
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 608
    return naoResultPtr->id;
#line 608
}
#line 608


#line 609
EXTERN char *
#line 609
Nap_ShiftRight(
#line 609
    NapClientData	*nap_cd,
#line 609
    char		*str1,			/* id of left arg (in) */
#line 609
    char		*str2)			/* id of right arg (in) */
#line 609
{
#line 609
    const int		resultHasMissingValue = FALSE;
#line 609
    size_t		i;
#line 609
    size_t		i1;			/* subscript of left arg */
#line 609
    size_t		i2;			/* subscript of right arg */
#line 609
    Nap_NAO		*naoResultPtr;
#line 609
    Nap_NAO		*naoPtr1;
#line 609
    Nap_NAO		*naoPtr2;
#line 609
    int			status;
#line 609

#line 609
    status = Nap_DyadArgs(nap_cd, str1, str2, "$1 >> $2", &naoPtr1, &naoPtr2);
#line 609
    CHECK1NULL(status == TCL_OK);
#line 609
    CHECK2NULL(Nap_TypeIsInteger(naoPtr1->dataType) && Nap_TypeIsInteger(naoPtr2->dataType), 	    "Nap_ShiftRight: Shift operator has non-integer argument");
#line 609
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, naoPtr1->dataType, naoPtr2->dataType,
#line 609
	    naoPtr1->dataType, resultHasMissingValue, " ", &naoPtr1, &naoPtr2, &naoResultPtr);
#line 609
    CHECK1NULL(status == TCL_OK);
#line 609
    switch (naoResultPtr->dataType) {
#line 609

#line 609
    
#line 609

#line 609

#line 609
	case NAP_U8:
#line 609
	    switch (naoPtr2->dataType) {
#line 609
	    
#line 609

#line 609

#line 609
		case NAP_U8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U8[i] = 
#line 609
				    naoPtr1->data.U8[i1] >> naoPtr2->data.U8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U8[i] = 
#line 609
				    naoPtr1->data.U8[i1] >> naoPtr2->data.U16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U8[i] = 
#line 609
				    naoPtr1->data.U8[i1] >> naoPtr2->data.U32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609

#line 609
		case NAP_I8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U8[i] = 
#line 609
				    naoPtr1->data.U8[i1] >> naoPtr2->data.I8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U8[i] = 
#line 609
				    naoPtr1->data.U8[i1] >> naoPtr2->data.I16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U8[i] = nap_cd->U8MissingValueNao->data.U8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U8[i] = 
#line 609
				    naoPtr1->data.U8[i1] >> naoPtr2->data.I32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609
	    default:            /* error */
#line 609
		assert(FALSE);
#line 609
	    }
#line 609
	    break;
#line 609

#line 609
	case NAP_U16:
#line 609
	    switch (naoPtr2->dataType) {
#line 609
	    
#line 609

#line 609

#line 609
		case NAP_U8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U16[i] = 
#line 609
				    naoPtr1->data.U16[i1] >> naoPtr2->data.U8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U16[i] = 
#line 609
				    naoPtr1->data.U16[i1] >> naoPtr2->data.U16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U16[i] = 
#line 609
				    naoPtr1->data.U16[i1] >> naoPtr2->data.U32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609

#line 609
		case NAP_I8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U16[i] = 
#line 609
				    naoPtr1->data.U16[i1] >> naoPtr2->data.I8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U16[i] = 
#line 609
				    naoPtr1->data.U16[i1] >> naoPtr2->data.I16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U16[i] = nap_cd->U16MissingValueNao->data.U16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U16[i] = 
#line 609
				    naoPtr1->data.U16[i1] >> naoPtr2->data.I32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609
	    default:            /* error */
#line 609
		assert(FALSE);
#line 609
	    }
#line 609
	    break;
#line 609

#line 609
	case NAP_U32:
#line 609
	    switch (naoPtr2->dataType) {
#line 609
	    
#line 609

#line 609

#line 609
		case NAP_U8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U32[i] = 
#line 609
				    naoPtr1->data.U32[i1] >> naoPtr2->data.U8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U32[i] = 
#line 609
				    naoPtr1->data.U32[i1] >> naoPtr2->data.U16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U32[i] = 
#line 609
				    naoPtr1->data.U32[i1] >> naoPtr2->data.U32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609

#line 609
		case NAP_I8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U32[i] = 
#line 609
				    naoPtr1->data.U32[i1] >> naoPtr2->data.I8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U32[i] = 
#line 609
				    naoPtr1->data.U32[i1] >> naoPtr2->data.I16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.U32[i] = nap_cd->U32MissingValueNao->data.U32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.U32[i] = 
#line 609
				    naoPtr1->data.U32[i1] >> naoPtr2->data.I32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609
	    default:            /* error */
#line 609
		assert(FALSE);
#line 609
	    }
#line 609
	    break;
#line 609

#line 609

#line 609

#line 609
	case NAP_I8:
#line 609
	    switch (naoPtr2->dataType) {
#line 609
	    
#line 609

#line 609

#line 609
		case NAP_U8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I8[i] = 
#line 609
				    naoPtr1->data.I8[i1] >> naoPtr2->data.U8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I8[i] = 
#line 609
				    naoPtr1->data.I8[i1] >> naoPtr2->data.U16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I8[i] = 
#line 609
				    naoPtr1->data.I8[i1] >> naoPtr2->data.U32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609

#line 609
		case NAP_I8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I8[i] = 
#line 609
				    naoPtr1->data.I8[i1] >> naoPtr2->data.I8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I8[i] = 
#line 609
				    naoPtr1->data.I8[i1] >> naoPtr2->data.I16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I8[i] = nap_cd->I8MissingValueNao->data.I8[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I8[i] = 
#line 609
				    naoPtr1->data.I8[i1] >> naoPtr2->data.I32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609
	    default:            /* error */
#line 609
		assert(FALSE);
#line 609
	    }
#line 609
	    break;
#line 609

#line 609
	case NAP_I16:
#line 609
	    switch (naoPtr2->dataType) {
#line 609
	    
#line 609

#line 609

#line 609
		case NAP_U8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I16[i] = 
#line 609
				    naoPtr1->data.I16[i1] >> naoPtr2->data.U8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I16[i] = 
#line 609
				    naoPtr1->data.I16[i1] >> naoPtr2->data.U16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I16[i] = 
#line 609
				    naoPtr1->data.I16[i1] >> naoPtr2->data.U32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609

#line 609
		case NAP_I8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I16[i] = 
#line 609
				    naoPtr1->data.I16[i1] >> naoPtr2->data.I8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I16[i] = 
#line 609
				    naoPtr1->data.I16[i1] >> naoPtr2->data.I16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I16[i] = nap_cd->I16MissingValueNao->data.I16[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I16[i] = 
#line 609
				    naoPtr1->data.I16[i1] >> naoPtr2->data.I32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609
	    default:            /* error */
#line 609
		assert(FALSE);
#line 609
	    }
#line 609
	    break;
#line 609

#line 609
	case NAP_I32:
#line 609
	    switch (naoPtr2->dataType) {
#line 609
	    
#line 609

#line 609

#line 609
		case NAP_U8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I32[i] = 
#line 609
				    naoPtr1->data.I32[i1] >> naoPtr2->data.U8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I32[i] = 
#line 609
				    naoPtr1->data.I32[i1] >> naoPtr2->data.U16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_U32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I32[i] = 
#line 609
				    naoPtr1->data.I32[i1] >> naoPtr2->data.U32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609

#line 609
		case NAP_I8:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I32[i] = 
#line 609
				    naoPtr1->data.I32[i1] >> naoPtr2->data.I8[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I16:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I32[i] = 
#line 609
				    naoPtr1->data.I32[i1] >> naoPtr2->data.I16[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609
		case NAP_I32:
#line 609
		    for (i = 0; i < naoResultPtr->nels; i++) {
#line 609
			i1 = i % naoPtr1->nels;
#line 609
			i2 = i % naoPtr2->nels;
#line 609
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
#line 609
			    naoResultPtr->data.I32[i] = nap_cd->I32MissingValueNao->data.I32[0];
#line 609
			} else {
#line 609
			    naoResultPtr->data.I32[i] = 
#line 609
				    naoPtr1->data.I32[i1] >> naoPtr2->data.I32[i2];
#line 609
			}
#line 609
		    }
#line 609
		    break;
#line 609

#line 609

#line 609
	    default:            /* error */
#line 609
		assert(FALSE);
#line 609
	    }
#line 609
	    break;
#line 609

#line 609

#line 609
    default:            /* error */
#line 609
	assert(FALSE);
#line 609
    }
#line 609
    Nap_DecrRefCount(nap_cd, naoPtr1);
#line 609
    Nap_DecrRefCount(nap_cd, naoPtr2);
#line 609
    return naoResultPtr->id;
#line 609
}
#line 609



/*
 * Nap_AP_check --
 *
 *	Called by Nap_AP & Nap_AP_arg
 */

static int
Nap_AP_check(
    NapClientData	*nap_cd,
    Nap_NAO		*naoPtr,
    char		*name)		/* name of arg for messages */
{
    CHECK3(naoPtr , "Nap_DyadInit: Operand '%s' is bad", name);
    CHECK3(Nap_TypeIsNumeric(naoPtr->dataType), "Nap_DyadInit: Operand '%s' is not numeric", name);
    CHECK3(naoPtr->rank == 0, "Nap_DyadInit: Operand '%s' is not scalar", name);
    CHECK3(!IsMissing(naoPtr, 0), "Nap_DyadInit: Operand '%s' == missing value", name);
    return TCL_OK;
}

/*
 * Nap_AP_arg --
 *
 *	Called by Nap_AP
 */

static Nap_NAO *
Nap_AP_arg(
    NapClientData	*nap_cd,
    Nap_NAO		*naoPtr,
    int			i,		/* index of this arg within naoPtr */
    char		*name)		/* name of arg for messages */
{
    Nap_NAO		*result;
    int			status;

    if (i < naoPtr->nels) {
	result = Nap_GetNaoFromSlot(naoPtr->data.Boxed[i]);
	status = Nap_AP_check(nap_cd, result, name);
	Nap_IncrRefCount(nap_cd, result);
	if (status != TCL_OK) {
	    Nap_DecrRefCount(nap_cd, result);
	    CHECK1NULL(FALSE);
	}
    } else {
	result = NULL;
    }
    return result;
}

/*
 * Nap_AP --
 *      Generate arithmetic progression -- operator '..'
 *
 *	Either operand can be boxed, but not both
 *	If left  argument is unboxed it represents 'from' value
 *	If right argument is unboxed it represents 'to' value
 *	If left  argument is unboxed it represents values: (n , from)
 *		where n is # elements in result
 *	If right argument is unboxed it represents values: (to , step [, tolerance])
 *		where tolerance (default 1e-9) is used to define n=floor((to-from)/step+tolerance)
 */

#line 701 "/home/dav480/tcl/nap/generic/napDyad.c,m4"

EXTERN char *
Nap_AP(
    NapClientData	*nap_cd,
    char		*str1,		/* 'from' value */
    char		*str2)		/* either 'to' value or 'to,step' (boxed) */
{
    Nap_dataType	dataType;
    int                 extra;		/* 1 if need extra element at end, else 0 */
    double              from;		/* initial value of A.P. */
    size_t		i;
    int                 n;		/* integer number of elements in A.P. */
    					/*(excludes any extra element at end) */
    double              nn;		/* floating point number of elements in A.P. */
    Nap_NAO		*naoFrom = NULL;
    Nap_NAO		*naoN = NULL;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoStep = NULL;
    Nap_NAO		*naoTol = NULL;
    Nap_NAO		*naoTo = NULL;
    Nap_NAO		*result;
    size_t		shape[1];
    int			status;
    double              step;           /* A.P. increment */
    double              to;		/* final value of A.P. */
    double              tol = 1.0e-9;	/* tolerance (see above) */
    Nap_NAO		*tmp;

    CHECK2NULL(str1, "Nap_AP: Left argument of .. is NULL");
    naoPtr1 = Nap_GetNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "Nap_AP: Bad left argument of ..");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    if (naoPtr1->dataType == NAP_BOXED) {
	CHECK2NULL(naoPtr1->rank == 1, "Nap_AP: Left boxed argument of .. is not vector");
	CHECK2NULL(naoPtr1->nels == 2, "Nap_AP: Left boxed argument of .. does not have shape {2}");
	naoN    = Nap_AP_arg(nap_cd, naoPtr1, 0, "n");
	CHECK1NULL(naoN);
	naoFrom = Nap_AP_arg(nap_cd, naoPtr1, 1, "from");
	CHECK1NULL(naoFrom);
    } else {
	naoFrom = naoPtr1;
	status = Nap_AP_check(nap_cd, naoFrom, "from");
	Nap_IncrRefCount(nap_cd, naoFrom);
	if (status != TCL_OK) {
	    Nap_DecrRefCount(nap_cd, naoFrom);
	    CHECK1NULL(FALSE);
	}
    }
    CHECK2NULL(str2, "Nap_AP: Right argument of .. is NULL");
    naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
    CHECK2NULL(naoPtr2, "Nap_AP: Bad right argument of ..");
    Nap_IncrRefCount(nap_cd, naoPtr2);
    if (naoPtr2->dataType == NAP_BOXED) {
	CHECK2NULL(naoPtr2->rank == 1, "Nap_AP: Right boxed argument of .. is not vector");
	CHECK2NULL(naoPtr2->nels == 2 || naoPtr2->nels == 3,
		"Nap_AP: Right boxed argument of .. does not have shape {2} or {3}");
	naoTo   = Nap_AP_arg(nap_cd, naoPtr2, 0, "to");
	CHECK1NULL(naoTo);
	naoStep = Nap_AP_arg(nap_cd, naoPtr2, 1, "step");
	CHECK1NULL(naoStep);
	if (naoPtr2->nels == 3) {
	    naoTol  = Nap_AP_arg(nap_cd, naoPtr2, 2, "tolerance");
	    CHECK1NULL(naoTol);
	}
    } else {
	naoTo = naoPtr2;
	status = Nap_AP_check(nap_cd, naoTo, "to");
	Nap_IncrRefCount(nap_cd, naoTo);
	if (status != TCL_OK) {
	    Nap_DecrRefCount(nap_cd, naoTo);
	    CHECK1NULL(FALSE);
	}
    }
    assert(naoFrom);
    CHECK2NULL(!naoN || !naoStep, "Nap_AP: Both 'n' and 'step' specified");
    status = Nap_F64ScalarValue(nap_cd, naoFrom, &from);
    CHECK2NULL(status == TCL_OK, "Nap_AP: Error calling Nap_F64ScalarValue");
    assert(naoTo);
    status = Nap_F64ScalarValue(nap_cd, naoTo, &to);
    CHECK2NULL(status == TCL_OK, "Nap_AP: Error calling Nap_F64ScalarValue");
    dataType = Nap_DataType2(naoFrom->dataType, naoTo->dataType);
    if (from == to) {
	step = 1.0;
	nn = 1.0;
    } else if (naoN) {
	status = Nap_F64ScalarValue(nap_cd, naoN, &nn);
	CHECK2NULL(status == TCL_OK, "Nap_AP: Error calling Nap_F64ScalarValue");
	nn = Max(0.0, nn);
	step = nn == 1.0 ? 1.0 : (to - from) / (nn - 1.0);
    } else {
	if (naoStep) {
	    status = Nap_F64ScalarValue(nap_cd, naoStep, &step);
	    CHECK2NULL(status == TCL_OK, "Nap_AP: Error calling Nap_F64ScalarValue");
	    if (naoTol) {
		status = Nap_F64ScalarValue(nap_cd, naoTol, &tol);
		CHECK2NULL(status == TCL_OK, "Nap_AP: Error calling Nap_F64ScalarValue");
	    }
	} else {
	    step = Sign(to - from);
	}
	nn = step ? 1.0 + (to - from) / step : 0.0;
    }
    nn = Max(0.0, floor(nn+tol) > floor(nn) ? ceil(nn) : nn);
    n = nn;
    if (step != floor(step)) {
	dataType = Nap_DataType2(dataType, NAP_F32);
    }
    tmp = naoFrom;
    naoFrom = Nap_CastNAO(nap_cd, tmp, dataType);
    Nap_IncrRefCount(nap_cd, naoFrom);
    Nap_DecrRefCount(nap_cd, tmp);
    tmp = naoTo;
    naoTo = Nap_CastNAO(nap_cd, tmp, dataType);
    Nap_IncrRefCount(nap_cd, naoTo);
    Nap_DecrRefCount(nap_cd, tmp);
    extra = nn > n+tol;
    shape[0] = n + extra;
    result = Nap_NewNAO(nap_cd, dataType, 1, shape);
    if (n > 0) {
	if (step == 1.0) {
	    switch (dataType) {
		
#line 823

#line 823

#line 823

#line 823
            case NAP_U8:
#line 823
                for (i = 0; i < n; i++) {
#line 823
                    result->data.U8[i] = naoFrom->data.U8[0] + i;
#line 823
                }
#line 823
                break;
#line 823

#line 823
            case NAP_U16:
#line 823
                for (i = 0; i < n; i++) {
#line 823
                    result->data.U16[i] = naoFrom->data.U16[0] + i;
#line 823
                }
#line 823
                break;
#line 823

#line 823
            case NAP_U32:
#line 823
                for (i = 0; i < n; i++) {
#line 823
                    result->data.U32[i] = naoFrom->data.U32[0] + i;
#line 823
                }
#line 823
                break;
#line 823

#line 823

#line 823

#line 823
            case NAP_I8:
#line 823
                for (i = 0; i < n; i++) {
#line 823
                    result->data.I8[i] = naoFrom->data.I8[0] + i;
#line 823
                }
#line 823
                break;
#line 823

#line 823
            case NAP_I16:
#line 823
                for (i = 0; i < n; i++) {
#line 823
                    result->data.I16[i] = naoFrom->data.I16[0] + i;
#line 823
                }
#line 823
                break;
#line 823

#line 823
            case NAP_I32:
#line 823
                for (i = 0; i < n; i++) {
#line 823
                    result->data.I32[i] = naoFrom->data.I32[0] + i;
#line 823
                }
#line 823
                break;
#line 823

#line 823

#line 823

#line 823

#line 823
            case NAP_F32:
#line 823
                for (i = 0; i < n; i++) {
#line 823
                    result->data.F32[i] = naoFrom->data.F32[0] + i;
#line 823
                }
#line 823
                break;
#line 823

#line 823
            case NAP_F64:
#line 823
                for (i = 0; i < n; i++) {
#line 823
                    result->data.F64[i] = naoFrom->data.F64[0] + i;
#line 823
                }
#line 823
                break;
#line 823

#line 823

		default:                /* error */
		    return NULL;
	    }
	} else if (step == -1.0) {
	    switch (dataType) {
		
#line 829

#line 829

#line 829

#line 829
            case NAP_U8:
#line 829
                for (i = 0; i < n; i++) {
#line 829
                    result->data.U8[i] = naoFrom->data.U8[0] - i;
#line 829
                }
#line 829
                break;
#line 829

#line 829
            case NAP_U16:
#line 829
                for (i = 0; i < n; i++) {
#line 829
                    result->data.U16[i] = naoFrom->data.U16[0] - i;
#line 829
                }
#line 829
                break;
#line 829

#line 829
            case NAP_U32:
#line 829
                for (i = 0; i < n; i++) {
#line 829
                    result->data.U32[i] = naoFrom->data.U32[0] - i;
#line 829
                }
#line 829
                break;
#line 829

#line 829

#line 829

#line 829
            case NAP_I8:
#line 829
                for (i = 0; i < n; i++) {
#line 829
                    result->data.I8[i] = naoFrom->data.I8[0] - i;
#line 829
                }
#line 829
                break;
#line 829

#line 829
            case NAP_I16:
#line 829
                for (i = 0; i < n; i++) {
#line 829
                    result->data.I16[i] = naoFrom->data.I16[0] - i;
#line 829
                }
#line 829
                break;
#line 829

#line 829
            case NAP_I32:
#line 829
                for (i = 0; i < n; i++) {
#line 829
                    result->data.I32[i] = naoFrom->data.I32[0] - i;
#line 829
                }
#line 829
                break;
#line 829

#line 829

#line 829

#line 829

#line 829
            case NAP_F32:
#line 829
                for (i = 0; i < n; i++) {
#line 829
                    result->data.F32[i] = naoFrom->data.F32[0] - i;
#line 829
                }
#line 829
                break;
#line 829

#line 829
            case NAP_F64:
#line 829
                for (i = 0; i < n; i++) {
#line 829
                    result->data.F64[i] = naoFrom->data.F64[0] - i;
#line 829
                }
#line 829
                break;
#line 829

#line 829

		default:                /* error */
		    return NULL;
	    }
	} else {
	    switch (dataType) {
		
#line 835

#line 835

#line 835

#line 835
            case NAP_U8:
#line 835
                for (i = 0; i < n; i++) {
#line 835
                    result->data.U8[i] = naoFrom->data.U8[0] + i * step;
#line 835
                }
#line 835
                break;
#line 835

#line 835
            case NAP_U16:
#line 835
                for (i = 0; i < n; i++) {
#line 835
                    result->data.U16[i] = naoFrom->data.U16[0] + i * step;
#line 835
                }
#line 835
                break;
#line 835

#line 835
            case NAP_U32:
#line 835
                for (i = 0; i < n; i++) {
#line 835
                    result->data.U32[i] = naoFrom->data.U32[0] + i * step;
#line 835
                }
#line 835
                break;
#line 835

#line 835

#line 835

#line 835
            case NAP_I8:
#line 835
                for (i = 0; i < n; i++) {
#line 835
                    result->data.I8[i] = naoFrom->data.I8[0] + i * step;
#line 835
                }
#line 835
                break;
#line 835

#line 835
            case NAP_I16:
#line 835
                for (i = 0; i < n; i++) {
#line 835
                    result->data.I16[i] = naoFrom->data.I16[0] + i * step;
#line 835
                }
#line 835
                break;
#line 835

#line 835
            case NAP_I32:
#line 835
                for (i = 0; i < n; i++) {
#line 835
                    result->data.I32[i] = naoFrom->data.I32[0] + i * step;
#line 835
                }
#line 835
                break;
#line 835

#line 835

#line 835

#line 835

#line 835
            case NAP_F32:
#line 835
                for (i = 0; i < n; i++) {
#line 835
                    result->data.F32[i] = naoFrom->data.F32[0] + i * step;
#line 835
                }
#line 835
                break;
#line 835

#line 835
            case NAP_F64:
#line 835
                for (i = 0; i < n; i++) {
#line 835
                    result->data.F64[i] = naoFrom->data.F64[0] + i * step;
#line 835
                }
#line 835
                break;
#line 835

#line 835

		default:                /* error */
		    return NULL;
	    }
	}
    }
    if (extra) {
	switch (dataType) {
	    
#line 843

#line 843

#line 843

#line 843
            case NAP_U8:
#line 843
		result->data.U8[n] = to;
#line 843
                break;
#line 843

#line 843
            case NAP_U16:
#line 843
		result->data.U16[n] = to;
#line 843
                break;
#line 843

#line 843
            case NAP_U32:
#line 843
		result->data.U32[n] = to;
#line 843
                break;
#line 843

#line 843

#line 843

#line 843
            case NAP_I8:
#line 843
		result->data.I8[n] = to;
#line 843
                break;
#line 843

#line 843
            case NAP_I16:
#line 843
		result->data.I16[n] = to;
#line 843
                break;
#line 843

#line 843
            case NAP_I32:
#line 843
		result->data.I32[n] = to;
#line 843
                break;
#line 843

#line 843

#line 843

#line 843

#line 843
            case NAP_F32:
#line 843
		result->data.F32[n] = to;
#line 843
                break;
#line 843

#line 843
            case NAP_F64:
#line 843
		result->data.F64[n] = to;
#line 843
                break;
#line 843

#line 843

	    default:                /* error */
		return NULL;
	}
    }
    Nap_DecrRefCount(nap_cd, naoN);
    Nap_DecrRefCount(nap_cd, naoFrom);
    Nap_DecrRefCount(nap_cd, naoTo);
    Nap_DecrRefCount(nap_cd, naoStep);
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    result->step = NAP_EQUAL;
    return result->id;
}
