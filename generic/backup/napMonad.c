#line 6 "/home/dav480/tcl/nap/generic/include.m4"

#line 5 "/home/dav480/tcl/nap/generic/napMonad.c,m4"
/* Do not edit this file (napMonad.c) */
/* It was produced from source file napMonad.c,m4 */

/* 
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napMonad.c,m4,v 1.209 2005/06/23 08:28:26 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"
#include "napParse.tab.h"

/*
 * Nap_Tally --
 *
 * Unary operator "#"
 */

#line 90 "/home/dav480/tcl/nap/generic/napMonad.c,m4"

EXTERN char *
Nap_Tally(
    NapClientData	*nap_cd, 
    char		*str)
{
    int			c;			/* Product of all dims except 1st */
    int			dataMax;		/* max. value in input */
    int			i;			/* subscript */
    int			ia;			/* subscript of array = 0 .. na-1 */
    int			j;			/* subscript */
    int			k;			/* subscript */
    int			m;			/* subscript */
    int			n;			/* # elements in each array */
    int			na;			/* # arrays */
    Nap_NAO		*naoArray[NAP_MAX_RANK]; /* pointers to arrays */
    Nap_NAO		*naoPtr;
    Nap_NAO		*naoResult;
    Nap_NAO		*naoTmp;
    int			p[NAP_MAX_RANK];	/* partial products of shape */
    size_t		shape[NAP_MAX_RANK];	/* shape of result */

    CHECK2NULL(str, "Nap_Tally: Operand of unary # is NULL");
    assert(str);
    naoPtr = Nap_GetNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "Nap_Tally: Error calling Nap_GetNaoFromId");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsBoxed(naoPtr)) {
	n = ia = -1;
	for (i = 0; i < naoPtr->nels; i++) {
	    naoTmp = Nap_GetNaoFromSlot(naoPtr->data.Boxed[i]);
	    if (naoTmp) {
		CHECK2NULL(ia < NAP_MAX_RANK, "Nap_Tally: Too many arrays");
		++ia;
		Nap_IncrRefCount(nap_cd, naoTmp);
		if (n < 0) {
		    n = naoTmp->nels;
		}
		CHECK3NULL(naoTmp->nels == n,
			"Nap_Tally: Array %d has different number of elements from array 0", ia);
		if (Nap_IsReal(naoTmp)) {
		    naoArray[ia] = Nap_CastNAO(nap_cd, naoTmp, NAP_I32);
		    CHECK2NULL(naoArray[ia], "Nap_Tally: Error calling Nap_CastNAO");
		    Nap_IncrRefCount(nap_cd, naoArray[ia]);
		    Nap_DecrRefCount(nap_cd, naoTmp);
		} else {
		    naoArray[ia] = naoTmp;
		}
		dataMax = -1;
		switch (naoArray[ia]->dataType) {
		
#line 140

#line 140

#line 140
	case NAP_U8:
#line 140
	    for (j = 0; j < n; j++) {
#line 140
		if (! IsMissing(naoArray[ia], j)) {
#line 140
		    if (naoArray[ia]->data.U8[j] > dataMax) {
#line 140
			dataMax = naoArray[ia]->data.U8[j];
#line 140
		    }
#line 140
		}
#line 140
	    }
#line 140
	    break;
#line 140

#line 140
	case NAP_U16:
#line 140
	    for (j = 0; j < n; j++) {
#line 140
		if (! IsMissing(naoArray[ia], j)) {
#line 140
		    if (naoArray[ia]->data.U16[j] > dataMax) {
#line 140
			dataMax = naoArray[ia]->data.U16[j];
#line 140
		    }
#line 140
		}
#line 140
	    }
#line 140
	    break;
#line 140

#line 140
	case NAP_U32:
#line 140
	    for (j = 0; j < n; j++) {
#line 140
		if (! IsMissing(naoArray[ia], j)) {
#line 140
		    if (naoArray[ia]->data.U32[j] > dataMax) {
#line 140
			dataMax = naoArray[ia]->data.U32[j];
#line 140
		    }
#line 140
		}
#line 140
	    }
#line 140
	    break;
#line 140

#line 140

#line 140

#line 140
	case NAP_I8:
#line 140
	    for (j = 0; j < n; j++) {
#line 140
		if (! IsMissing(naoArray[ia], j)) {
#line 140
		    if (naoArray[ia]->data.I8[j] > dataMax) {
#line 140
			dataMax = naoArray[ia]->data.I8[j];
#line 140
		    }
#line 140
		}
#line 140
	    }
#line 140
	    break;
#line 140

#line 140
	case NAP_I16:
#line 140
	    for (j = 0; j < n; j++) {
#line 140
		if (! IsMissing(naoArray[ia], j)) {
#line 140
		    if (naoArray[ia]->data.I16[j] > dataMax) {
#line 140
			dataMax = naoArray[ia]->data.I16[j];
#line 140
		    }
#line 140
		}
#line 140
	    }
#line 140
	    break;
#line 140

#line 140
	case NAP_I32:
#line 140
	    for (j = 0; j < n; j++) {
#line 140
		if (! IsMissing(naoArray[ia], j)) {
#line 140
		    if (naoArray[ia]->data.I32[j] > dataMax) {
#line 140
			dataMax = naoArray[ia]->data.I32[j];
#line 140
		    }
#line 140
		}
#line 140
	    }
#line 140
	    break;
#line 140

#line 140

		default:            /* error */
		    assert(FALSE);
		}
		shape[ia] = dataMax + 1;
	    }
	}
	na = ia + 1;
	CHECK2NULL(na > 0, "Nap_Tally: No arrays");
	p[ia] = 1;
	while (ia > 0) {
	    p[ia-1] = p[ia] * shape[ia];
	    ia--;
	}
	naoResult = Nap_NewNAO(nap_cd, NAP_I32, na, shape);
	CHECK2NULL(naoResult, "Nap_Tally: Error calling Nap_NewNAO");
	for (j = 0; j < naoResult->nels; j++) {
	    naoResult->data.I32[j] = 0;
	}
	for (j = 0; j < n; j++) {
	    m = 0;
	    for (ia = 0; ia < na; ia++) {
		switch (naoArray[ia]->dataType) {
		
#line 163

#line 163

#line 163
	case NAP_U8:
#line 163
	    if (IsMissing(naoArray[ia], j)) {
#line 163
		k = -1;
#line 163
	    } else {
#line 163
		k = naoArray[ia]->data.U8[j];
#line 163
	    }
#line 163
	    break;
#line 163

#line 163
	case NAP_U16:
#line 163
	    if (IsMissing(naoArray[ia], j)) {
#line 163
		k = -1;
#line 163
	    } else {
#line 163
		k = naoArray[ia]->data.U16[j];
#line 163
	    }
#line 163
	    break;
#line 163

#line 163
	case NAP_U32:
#line 163
	    if (IsMissing(naoArray[ia], j)) {
#line 163
		k = -1;
#line 163
	    } else {
#line 163
		k = naoArray[ia]->data.U32[j];
#line 163
	    }
#line 163
	    break;
#line 163

#line 163

#line 163

#line 163
	case NAP_I8:
#line 163
	    if (IsMissing(naoArray[ia], j)) {
#line 163
		k = -1;
#line 163
	    } else {
#line 163
		k = naoArray[ia]->data.I8[j];
#line 163
	    }
#line 163
	    break;
#line 163

#line 163
	case NAP_I16:
#line 163
	    if (IsMissing(naoArray[ia], j)) {
#line 163
		k = -1;
#line 163
	    } else {
#line 163
		k = naoArray[ia]->data.I16[j];
#line 163
	    }
#line 163
	    break;
#line 163

#line 163
	case NAP_I32:
#line 163
	    if (IsMissing(naoArray[ia], j)) {
#line 163
		k = -1;
#line 163
	    } else {
#line 163
		k = naoArray[ia]->data.I32[j];
#line 163
	    }
#line 163
	    break;
#line 163

#line 163

		default:            /* error */
		    assert(FALSE);
		}
		if (k < 0) {
		    m = -1;
		    break;
		} else {
		    m += p[ia] * k;
		}
	    }
	    if (m >= 0) {
		++ naoResult->data.I32[m];
	    }
	}
	for (ia = 0; ia < na; ia++) {
	    Nap_DecrRefCount(nap_cd, naoArray[ia]);
	}
    } else {
	if (Nap_IsReal(naoPtr)) {
	    naoTmp = naoPtr;
	    naoPtr = Nap_CastNAO(nap_cd, naoTmp, NAP_I32);
	    CHECK2NULL(naoPtr, "Nap_Tally: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, naoPtr);
	    Nap_DecrRefCount(nap_cd, naoTmp);
	}
	dataMax = 0;
	switch (naoPtr->dataType) {
	
#line 191

#line 191

#line 191
	case NAP_U8:
#line 191
	    for (i = 0; i < naoPtr->nels; i++) {
#line 191
		if (! IsMissing(naoPtr, i)) {
#line 191
		    if (naoPtr->data.U8[i] > dataMax) {
#line 191
			dataMax = naoPtr->data.U8[i];
#line 191
		    }
#line 191
		}
#line 191
	    }
#line 191
	    break;
#line 191

#line 191
	case NAP_U16:
#line 191
	    for (i = 0; i < naoPtr->nels; i++) {
#line 191
		if (! IsMissing(naoPtr, i)) {
#line 191
		    if (naoPtr->data.U16[i] > dataMax) {
#line 191
			dataMax = naoPtr->data.U16[i];
#line 191
		    }
#line 191
		}
#line 191
	    }
#line 191
	    break;
#line 191

#line 191
	case NAP_U32:
#line 191
	    for (i = 0; i < naoPtr->nels; i++) {
#line 191
		if (! IsMissing(naoPtr, i)) {
#line 191
		    if (naoPtr->data.U32[i] > dataMax) {
#line 191
			dataMax = naoPtr->data.U32[i];
#line 191
		    }
#line 191
		}
#line 191
	    }
#line 191
	    break;
#line 191

#line 191

#line 191

#line 191
	case NAP_I8:
#line 191
	    for (i = 0; i < naoPtr->nels; i++) {
#line 191
		if (! IsMissing(naoPtr, i)) {
#line 191
		    if (naoPtr->data.I8[i] > dataMax) {
#line 191
			dataMax = naoPtr->data.I8[i];
#line 191
		    }
#line 191
		}
#line 191
	    }
#line 191
	    break;
#line 191

#line 191
	case NAP_I16:
#line 191
	    for (i = 0; i < naoPtr->nels; i++) {
#line 191
		if (! IsMissing(naoPtr, i)) {
#line 191
		    if (naoPtr->data.I16[i] > dataMax) {
#line 191
			dataMax = naoPtr->data.I16[i];
#line 191
		    }
#line 191
		}
#line 191
	    }
#line 191
	    break;
#line 191

#line 191
	case NAP_I32:
#line 191
	    for (i = 0; i < naoPtr->nels; i++) {
#line 191
		if (! IsMissing(naoPtr, i)) {
#line 191
		    if (naoPtr->data.I32[i] > dataMax) {
#line 191
			dataMax = naoPtr->data.I32[i];
#line 191
		    }
#line 191
		}
#line 191
	    }
#line 191
	    break;
#line 191

#line 191

	default:            /* error */
	    CHECK2NULL(0, "Nap_Tally: Illegal data-type");
	}
	shape[0] = dataMax + 1;
	c = 1;
	for (i = 1; i < naoPtr->rank; i++) {
	    shape[i] = naoPtr->shape[i];
	    c *= naoPtr->shape[i];
	}
	naoResult = Nap_NewNAO(nap_cd, NAP_I32, naoPtr->rank, shape);
	CHECK2NULL(naoResult, "Nap_Tally: Error calling Nap_NewNAO");
	for (j = 0; j < naoResult->nels; j++) {
	    naoResult->data.I32[j] = 0;
	}
	if (Nap_IsSignedInteger(naoPtr)) {
	    switch (naoPtr->dataType) {
	    
#line 208

#line 208
	case NAP_I8:
#line 208
	    for (i = 0; i < naoPtr->nels; i++) {
#line 208
		if (! IsMissing(naoPtr, i)   &&  naoPtr->data.I8[i] >= 0) {
#line 208
		    j = i + c * (naoPtr->data.I8[i] - i/c);
#line 208
		    ++(naoResult->data.I32[j]);
#line 208
		}
#line 208
	    }
#line 208
	    break;
#line 208

#line 208
	case NAP_I16:
#line 208
	    for (i = 0; i < naoPtr->nels; i++) {
#line 208
		if (! IsMissing(naoPtr, i)   &&  naoPtr->data.I16[i] >= 0) {
#line 208
		    j = i + c * (naoPtr->data.I16[i] - i/c);
#line 208
		    ++(naoResult->data.I32[j]);
#line 208
		}
#line 208
	    }
#line 208
	    break;
#line 208

#line 208
	case NAP_I32:
#line 208
	    for (i = 0; i < naoPtr->nels; i++) {
#line 208
		if (! IsMissing(naoPtr, i)   &&  naoPtr->data.I32[i] >= 0) {
#line 208
		    j = i + c * (naoPtr->data.I32[i] - i/c);
#line 208
		    ++(naoResult->data.I32[j]);
#line 208
		}
#line 208
	    }
#line 208
	    break;
#line 208

	    default:            /* error */
		assert(FALSE);
	    }
	} else {
	    switch (naoPtr->dataType) {
	    
#line 214

#line 214
	case NAP_U8:
#line 214
	    for (i = 0; i < naoPtr->nels; i++) {
#line 214
		if (! IsMissing(naoPtr, i)) {
#line 214
		    j = i + c * (naoPtr->data.U8[i] - i/c);
#line 214
		    ++(naoResult->data.I32[j]);
#line 214
		}
#line 214
	    }
#line 214
	    break;
#line 214

#line 214
	case NAP_U16:
#line 214
	    for (i = 0; i < naoPtr->nels; i++) {
#line 214
		if (! IsMissing(naoPtr, i)) {
#line 214
		    j = i + c * (naoPtr->data.U16[i] - i/c);
#line 214
		    ++(naoResult->data.I32[j]);
#line 214
		}
#line 214
	    }
#line 214
	    break;
#line 214

#line 214
	case NAP_U32:
#line 214
	    for (i = 0; i < naoPtr->nels; i++) {
#line 214
		if (! IsMissing(naoPtr, i)) {
#line 214
		    j = i + c * (naoPtr->data.U32[i] - i/c);
#line 214
		    ++(naoResult->data.I32[j]);
#line 214
		}
#line 214
	    }
#line 214
	    break;
#line 214

	    default:            /* error */
		assert(FALSE);
	    }
	}
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return naoResult ? naoResult->id : NULL;
}

/*
 * Nap_Not --
 *
 * Operator "!"
 */

#line 243 "/home/dav480/tcl/nap/generic/napMonad.c,m4"

EXTERN char *
Nap_Not(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "Nap_Not: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    new = Nap_NewNAO(nap_cd, NAP_U8, naoPtr->rank, naoPtr->shape);
    CHECK2NULL(new, "Nap_Not: Error calling Nap_NewNAO");
    status = Nap_CopyDims(nap_cd, naoPtr, new);
    CHECK1NULL(status == TCL_OK);
    switch (naoPtr->dataType) {
    
#line 262

#line 262

#line 262

#line 262
	case NAP_U8:
#line 262
	    for (i = 0; i < new->nels; i++) {
#line 262
		new->data.U8[i] = ! naoPtr->data.U8[i];
#line 262
	    }
#line 262
	    break;
#line 262

#line 262
	case NAP_U16:
#line 262
	    for (i = 0; i < new->nels; i++) {
#line 262
		new->data.U8[i] = ! naoPtr->data.U16[i];
#line 262
	    }
#line 262
	    break;
#line 262

#line 262
	case NAP_U32:
#line 262
	    for (i = 0; i < new->nels; i++) {
#line 262
		new->data.U8[i] = ! naoPtr->data.U32[i];
#line 262
	    }
#line 262
	    break;
#line 262

#line 262

#line 262

#line 262
	case NAP_I8:
#line 262
	    for (i = 0; i < new->nels; i++) {
#line 262
		new->data.U8[i] = ! naoPtr->data.I8[i];
#line 262
	    }
#line 262
	    break;
#line 262

#line 262
	case NAP_I16:
#line 262
	    for (i = 0; i < new->nels; i++) {
#line 262
		new->data.U8[i] = ! naoPtr->data.I16[i];
#line 262
	    }
#line 262
	    break;
#line 262

#line 262
	case NAP_I32:
#line 262
	    for (i = 0; i < new->nels; i++) {
#line 262
		new->data.U8[i] = ! naoPtr->data.I32[i];
#line 262
	    }
#line 262
	    break;
#line 262

#line 262

#line 262

#line 262

#line 262
	case NAP_F32:
#line 262
	    for (i = 0; i < new->nels; i++) {
#line 262
		new->data.U8[i] = ! naoPtr->data.F32[i];
#line 262
	    }
#line 262
	    break;
#line 262

#line 262
	case NAP_F64:
#line 262
	    for (i = 0; i < new->nels; i++) {
#line 262
		new->data.U8[i] = ! naoPtr->data.F64[i];
#line 262
	    }
#line 262
	    break;
#line 262

#line 262

    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}

/*
 * Nap_Complement --
 *
 * Operator "~"
 */

#line 289 "/home/dav480/tcl/nap/generic/napMonad.c,m4"

EXTERN char *
Nap_Complement(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    assert(str);
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "Nap_Complement: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    CHECK2NULL(Nap_IsInteger(naoPtr), "Nap_Complement: Non-integer operand to '~'");
    new = Nap_DupNAO(nap_cd, naoPtr);
    CHECK2NULL(new, "Nap_Complement: Error calling Nap_DupNAO");
    status = Nap_SetMissing(nap_cd, new, 0);
    CHECK1NULL(status == TCL_OK);
    switch (new->dataType) {
    
#line 310

#line 310

#line 310
	case NAP_U8:
#line 310
	    for (i = 0; i < new->nels; i++) {
#line 310
		new->data.U8[i] = ~ new->data.U8[i];
#line 310
	    }
#line 310
	    break;
#line 310

#line 310
	case NAP_U16:
#line 310
	    for (i = 0; i < new->nels; i++) {
#line 310
		new->data.U16[i] = ~ new->data.U16[i];
#line 310
	    }
#line 310
	    break;
#line 310

#line 310
	case NAP_U32:
#line 310
	    for (i = 0; i < new->nels; i++) {
#line 310
		new->data.U32[i] = ~ new->data.U32[i];
#line 310
	    }
#line 310
	    break;
#line 310

#line 310

#line 310

#line 310
	case NAP_I8:
#line 310
	    for (i = 0; i < new->nels; i++) {
#line 310
		new->data.I8[i] = ~ new->data.I8[i];
#line 310
	    }
#line 310
	    break;
#line 310

#line 310
	case NAP_I16:
#line 310
	    for (i = 0; i < new->nels; i++) {
#line 310
		new->data.I16[i] = ~ new->data.I16[i];
#line 310
	    }
#line 310
	    break;
#line 310

#line 310
	case NAP_I32:
#line 310
	    for (i = 0; i < new->nels; i++) {
#line 310
		new->data.I32[i] = ~ new->data.I32[i];
#line 310
	    }
#line 310
	    break;
#line 310

#line 310

    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}

/*
 * Nap_Negate --
 *
 * Operator "-"
 */

#line 337 "/home/dav480/tcl/nap/generic/napMonad.c,m4"

EXTERN char *
Nap_Negate(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "Nap_Negate: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    new = Nap_DupNAO(nap_cd, naoPtr);
    CHECK2NULL(new, "Nap_Negate: Error calling Nap_DupNAO");
    switch (new->dataType) {
    
#line 353

#line 353

#line 353
	case NAP_I8:
#line 353
	    for (i = 0; i < new->nels; i++) {
#line 353
		new->data.I8[i] = - new->data.I8[i];
#line 353
	    }
#line 353
	    break;
#line 353

#line 353
	case NAP_I16:
#line 353
	    for (i = 0; i < new->nels; i++) {
#line 353
		new->data.I16[i] = - new->data.I16[i];
#line 353
	    }
#line 353
	    break;
#line 353

#line 353
	case NAP_I32:
#line 353
	    for (i = 0; i < new->nels; i++) {
#line 353
		new->data.I32[i] = - new->data.I32[i];
#line 353
	    }
#line 353
	    break;
#line 353

#line 353

#line 353

#line 353
	case NAP_F32:
#line 353
	    for (i = 0; i < new->nels; i++) {
#line 353
		new->data.F32[i] = - new->data.F32[i];
#line 353
	    }
#line 353
	    break;
#line 353

#line 353
	case NAP_F64:
#line 353
	    for (i = 0; i < new->nels; i++) {
#line 353
		new->data.F64[i] = - new->data.F64[i];
#line 353
	    }
#line 353
	    break;
#line 353

#line 353

    default:            /* error */
	CHECK2NULL(FALSE, "Nap_Negate: Unsigned data-type");
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}


/*
 * Nap_Identity --
 *
 * Operator "+"  i.e. Identity function (copy of argument, not argument itself)
 */



EXTERN char *
Nap_Identity(
    NapClientData	*nap_cd, 
    char		*str)
{
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;

    CHECK2NULL(str, "Nap_Identity: NULL argument");
    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "Nap_Identity: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    new = Nap_DupNAO(nap_cd, naoPtr);
    CHECK2NULL(new, "Nap_Identity: Error calling Nap_DupNAO");
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new->id;
}


/*
 * Nap_Round --
 *
 * Unary operator "^"
 */

#line 408 "/home/dav480/tcl/nap/generic/napMonad.c,m4"

EXTERN char *
Nap_Round(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "Nap_Round: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsReal(naoPtr)) {
	new = Nap_NewNAO(nap_cd, NAP_I32, naoPtr->rank, naoPtr->shape);
	CHECK2NULL(new, "Nap_Round: Error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, naoPtr, new);
	CHECK1NULL(status == TCL_OK);
	switch (naoPtr->dataType) {
	
#line 428

#line 428
	case NAP_F32:
#line 428
	    for (i = 0; i < new->nels; i++) {
#line 428
		new->data.I32[i] = Nint(naoPtr->data.F32[i]);
#line 428
	    }
#line 428
	    break;
#line 428

#line 428
	case NAP_F64:
#line 428
	    for (i = 0; i < new->nels; i++) {
#line 428
		new->data.I32[i] = Nint(naoPtr->data.F64[i]);
#line 428
	    }
#line 428
	    break;
#line 428

	default:            /* error */
	    assert(FALSE);
	}
    } else {
	new = Nap_DupNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "Nap_Round: Error calling Nap_DupNAO");
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}



/*
 * Nap_Floor --
 *
 * Unary operator "^"
 */

#line 461 "/home/dav480/tcl/nap/generic/napMonad.c,m4"

EXTERN char *
Nap_Floor(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "Nap_Floor: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsReal(naoPtr)) {
	new = Nap_NewNAO(nap_cd, NAP_I32, naoPtr->rank, naoPtr->shape);
	CHECK2NULL(new, "Nap_Floor: Error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, naoPtr, new);
	CHECK1NULL(status == TCL_OK);
	switch (naoPtr->dataType) {
	
#line 481

#line 481
	case NAP_F32:
#line 481
	    for (i = 0; i < new->nels; i++) {
#line 481
		new->data.I32[i] = floor(naoPtr->data.F32[i]);
#line 481
	    }
#line 481
	    break;
#line 481

#line 481
	case NAP_F64:
#line 481
	    for (i = 0; i < new->nels; i++) {
#line 481
		new->data.I32[i] = floor(naoPtr->data.F64[i]);
#line 481
	    }
#line 481
	    break;
#line 481

	default:            /* error */
	    assert(FALSE);
	}
    } else {
	new = Nap_DupNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "Nap_Floor: Error calling Nap_DupNAO");
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}



/*
 * Nap_Ceil --
 *
 * Unary operator "^"
 */

#line 514 "/home/dav480/tcl/nap/generic/napMonad.c,m4"

EXTERN char *
Nap_Ceil(
    NapClientData	*nap_cd, 
    char		*str)
{
    size_t		i;
    Nap_NAO		*naoPtr;
    Nap_NAO		*new = NULL;
    int			status;

    naoPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "Nap_Ceil: Non-numeric argument");
    Nap_IncrRefCount(nap_cd, naoPtr);
    if (Nap_IsReal(naoPtr)) {
	new = Nap_NewNAO(nap_cd, NAP_I32, naoPtr->rank, naoPtr->shape);
	CHECK2NULL(new, "Nap_Ceil: Error calling Nap_NewNAO");
	status = Nap_CopyDims(nap_cd, naoPtr, new);
	CHECK1NULL(status == TCL_OK);
	switch (naoPtr->dataType) {
	
#line 534

#line 534
	case NAP_F32:
#line 534
	    for (i = 0; i < new->nels; i++) {
#line 534
		new->data.I32[i] = ceil(naoPtr->data.F32[i]);
#line 534
	    }
#line 534
	    break;
#line 534

#line 534
	case NAP_F64:
#line 534
	    for (i = 0; i < new->nels; i++) {
#line 534
		new->data.I32[i] = ceil(naoPtr->data.F64[i]);
#line 534
	    }
#line 534
	    break;
#line 534

	default:            /* error */
	    assert(FALSE);
	}
    } else {
	new = Nap_DupNAO(nap_cd, naoPtr);
	CHECK2NULL(new, "Nap_Ceil: Error calling Nap_DupNAO");
    }
    Nap_DecrRefCount(nap_cd, naoPtr);
    return new ? new->id : NULL;
}


/*
 * Nap_Indirect --
 *
 * Monadic "@", "@@", "@@@"
 */



EXTERN char *
Nap_Indirect(
    NapClientData	*nap_cd, 
    int			op,
    char		*right)			/* argument */
{   
    Nap_NAO		*cv_nao;		/* coord var */
    char		*fmt_s = "Nap_Indirect: Illegal coordinate variable corresponding to unary '%s'";
    int			i;			/* dimension number of base array */
    char		*id;			/* OOC name of result */
    Nap_NAO		*indexBaseCV;		/* boxed NAO of CVs */
    int			level;			/* parse level */
    Nap_NAO		*right_nao;		/* argument */
    int			status;
    char		*symbol;		/* "@", "@@" or "@@@" */

    right_nao = Nap_GetNaoFromId(nap_cd, right);
    Nap_IncrRefCount(nap_cd, right_nao);
    switch (op) {
	case '@':	symbol = "@"; break;
	case CLOSEST:	symbol = "@@"; break;
	case MATCH:	symbol = "@@@"; break;
	default:	assert(0);
    }
    level = nap_cd->parseLevel;
    CHECK3NULL(level >= 0, "Nap_Indirect: Unary '%s' used without any defined base array", symbol);
    indexBaseCV = nap_cd->indexBaseCV[level];
    CHECK3NULL(indexBaseCV, fmt_s, symbol);
    CHECK3NULL(Nap_IsNAO(nap_cd, indexBaseCV), fmt_s, symbol);
    CHECK3NULL(Nap_IsBoxed(indexBaseCV), fmt_s, symbol);
    i = nap_cd->indexDimNum[level];
    assert(i >= 0);
    assert(i < indexBaseCV->nels);
    cv_nao = Nap_GetNaoFromSlot(indexBaseCV->data.Boxed[i]);
    CHECK3NULL(cv_nao, fmt_s, symbol);
    CHECK3NULL(cv_nao->rank == 1, fmt_s, symbol);
    switch (op) {
	case '@':	id = Nap_IndexOf2(nap_cd, cv_nao->id, right); break;
	case CLOSEST:	id = Nap_Closest( nap_cd, cv_nao->id, right); break;
	case MATCH:	id = Nap_Match(   nap_cd, cv_nao->id, right); break;
	default:	assert(0);
    }
    CHECK3NULL(id, "Nap_Indirect: Error in unary operator '%s'", symbol);
    Nap_DecrRefCount(nap_cd, right_nao);
    return id;
}

/*
 * Nap_Niladic --
 *
 * Operator with no argument.
 */



EXTERN char *
Nap_Niladic(
    NapClientData	*nap_cd, 
    int			op)		/* operator */
{
    Nap_NAO		*naoPtr;
    char		*result = NULL;	/* NAO ID to be returned */

    switch (op) {
	case ',':
	    result = Nap_Link(nap_cd, NULL, NULL);
	    CHECK2NULL(result, "Nap_Niladic: Error calling Nap_Link");
	    break;
	case '-':
	    naoPtr = Nap_NewNAO(nap_cd, NAP_F32, 0, NULL);
	    CHECK2NULL(naoPtr, "Nap_Niladic: Error calling Nap_NewNAO");
	    naoPtr->data.F32[0] = -napF32Inf;
	    result = naoPtr->id;
	    break;
	default:
	    CHECK3NULL(0, "Nap_Niladic: Illegal niladic operator '%c'", op);
    }
    return result;
}
