#line 6 "/home/dav480/tcl/nap/generic/include.m4"

#line 5 "/home/dav480/tcl/nap/generic/linsys.c,m4"
/* Do not edit this file (linsys.c). It was produced from source file linsys.c,m4 */

/* 
 *	linsys.c,m4 --
 *
 *	This routine 'linsys' was adapted from code in
 *	http://www.fysik.dtu.dk/~stoltze/tools/linsys/linsys.htm
 *
 *      Called from Nap_SolveLinear in napDyad.c,m4 to implement nap function "solve_linear(A, B)"
 */

#ifndef lint
static char *rcsid="@(#) $Id: linsys.c,m4,v 1.3 2002/05/14 00:32:03 dav480 Exp $";
#endif /* not lint */

#include <stdio.h>
#include <math.h>

#include "linsys.h"

#line 107 "/home/dav480/tcl/nap/generic/linsys.c,m4"


#line 108

#line 108

#line 108
EXTERN int
#line 108
linsys_F32(
#line 108
	NapClientData       *nap_cd,
#line 108
	int n,				/* # rows in a and b */
#line 108
	int m,				/* # columns in b */
#line 108
	Nap_f32 **a,		/* pointers to rows of main matrix (left hand side) */
#line 108
	Nap_f32 **b)		/* pointers to rows of right hand side */
#line 108
{
#line 108
	int i, j, k;
#line 108
	Nap_f32 d;
#line 108

#line 108
	/* reduce to upper triangular form */
#line 108
	for(i = 0; i < n; i++)
#line 108
	{
#line 108
		/* find maximal element */
#line 108
		j = i;
#line 108
		for(k = i+1; k < n; k++)
#line 108
			if(fabs(a[k][i]) > fabs(a[j][i]))
#line 108
				j = k;
#line 108

#line 108
		/* swap row i and j in both a and b */
#line 108
		for(k = i; k < n; k++)
#line 108
		{
#line 108
			d = a[i][k];
#line 108
			a[i][k] = a[j][k];
#line 108
			a[j][k] = d;
#line 108
		}
#line 108
		for(k = 0; k<m; k++)
#line 108
		{
#line 108
			d = b[i][k];
#line 108
			b[i][k] = b[j][k];
#line 108
			b[j][k] = d;
#line 108
		}
#line 108

#line 108
		/* check if the system is singular */
#line 108
		CHECK3(fabs(a[i][i]) > 0.001, "linsys: Singular matrix, column %d", i+1);
#line 108

#line 108

#line 108
		/* elimination */
#line 108
		for(j=i+1; j<n; j++)
#line 108
		{
#line 108
			d = a[j][i]/a[i][i];
#line 108
			a[j][i] = 0.;
#line 108
			for(k = i+1; k < n; k++)
#line 108
				a[j][k] -= d*a[i][k];
#line 108
			for(k=0; k<m; k++)
#line 108
				b[j][k] -= d*b[i][k];
#line 108
		}
#line 108
	}
#line 108

#line 108
	/* normalization */
#line 108

#line 108
	for(i = 0; i<n; i++)
#line 108
	{
#line 108
		for(j = i+1; j<n; j++)
#line 108
			a[i][j] /= a[i][i];
#line 108
		for(j=0; j<m; j++)
#line 108
			b[i][j] /= a[i][i];
#line 108
		a[i][i] = 1.;
#line 108
	}
#line 108
	
#line 108
	/* reduction from upper trigonal form to diagonal form */
#line 108

#line 108
	for(i=n-1; i>=0; i--)
#line 108
	{
#line 108
		for(j = 0; j < i; j++)
#line 108
		{	
#line 108
			for(k=0; k<m; k++)
#line 108
				b[j][k] -= b[i][k]*a[j][i];
#line 108
			a[j][i] = 0;	
#line 108
		}
#line 108
	}
#line 108
	return TCL_OK;
#line 108
}
#line 108

#line 108

#line 108
EXTERN int
#line 108
linsys_F64(
#line 108
	NapClientData       *nap_cd,
#line 108
	int n,				/* # rows in a and b */
#line 108
	int m,				/* # columns in b */
#line 108
	Nap_f64 **a,		/* pointers to rows of main matrix (left hand side) */
#line 108
	Nap_f64 **b)		/* pointers to rows of right hand side */
#line 108
{
#line 108
	int i, j, k;
#line 108
	Nap_f64 d;
#line 108

#line 108
	/* reduce to upper triangular form */
#line 108
	for(i = 0; i < n; i++)
#line 108
	{
#line 108
		/* find maximal element */
#line 108
		j = i;
#line 108
		for(k = i+1; k < n; k++)
#line 108
			if(fabs(a[k][i]) > fabs(a[j][i]))
#line 108
				j = k;
#line 108

#line 108
		/* swap row i and j in both a and b */
#line 108
		for(k = i; k < n; k++)
#line 108
		{
#line 108
			d = a[i][k];
#line 108
			a[i][k] = a[j][k];
#line 108
			a[j][k] = d;
#line 108
		}
#line 108
		for(k = 0; k<m; k++)
#line 108
		{
#line 108
			d = b[i][k];
#line 108
			b[i][k] = b[j][k];
#line 108
			b[j][k] = d;
#line 108
		}
#line 108

#line 108
		/* check if the system is singular */
#line 108
		CHECK3(fabs(a[i][i]) > 0.001, "linsys: Singular matrix, column %d", i+1);
#line 108

#line 108

#line 108
		/* elimination */
#line 108
		for(j=i+1; j<n; j++)
#line 108
		{
#line 108
			d = a[j][i]/a[i][i];
#line 108
			a[j][i] = 0.;
#line 108
			for(k = i+1; k < n; k++)
#line 108
				a[j][k] -= d*a[i][k];
#line 108
			for(k=0; k<m; k++)
#line 108
				b[j][k] -= d*b[i][k];
#line 108
		}
#line 108
	}
#line 108

#line 108
	/* normalization */
#line 108

#line 108
	for(i = 0; i<n; i++)
#line 108
	{
#line 108
		for(j = i+1; j<n; j++)
#line 108
			a[i][j] /= a[i][i];
#line 108
		for(j=0; j<m; j++)
#line 108
			b[i][j] /= a[i][i];
#line 108
		a[i][i] = 1.;
#line 108
	}
#line 108
	
#line 108
	/* reduction from upper trigonal form to diagonal form */
#line 108

#line 108
	for(i=n-1; i>=0; i--)
#line 108
	{
#line 108
		for(j = 0; j < i; j++)
#line 108
		{	
#line 108
			for(k=0; k<m; k++)
#line 108
				b[j][k] -= b[i][k]*a[j][i];
#line 108
			a[j][i] = 0;	
#line 108
		}
#line 108
	}
#line 108
	return TCL_OK;
#line 108
}
#line 108

