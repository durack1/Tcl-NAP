#line 6 "/home/dav480/tcl/nap/generic/include.m4"

#line 5 "/home/dav480/tcl/nap/generic/geometry.c,m4"
/* Do not edit this file (geometry.c) */
/* It was produced from source file geometry.c,m4 */

/* 
 *	Copyright 2004, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Atmospheric Research
 */

#ifndef lint
static char *rcsid="@(#) $Id: geometry.c,m4,v 1.2 2005/03/04 05:35:06 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"

/*
 *  Nap_inPolygon --
 *
 *  Nap function 'inPolygon(x, y, p)'
 *  Tests whether points defined by 'x' & 'y' are inside, outside or on polygon defined by 'p'.
 *
 *  x & y must have shapes which are compatible with each other.
 *  Result has the same shape as x or y (whichever has the higher rank).
 *  Result has value -1 if (x,y) is outside, 0 if exactly on edge, 1 if inside.
 *  If x or y is missing then the result is missing.
 *
 *  p is matrix with 2 or more columns.  Each row corresponds to a vertex of the polygon.
 *  Column 0 contains x values & column 1 contains y values. Any further columns are ignored.
 *
 *  Based on function 'pnpoly' by Randolph Franklin at URL
 *  http://astronomy.swin.edu.au/~pbourke/geometry/insidepoly/
 *  This page was written by Paul Bourke in November 1987 & is titled
 *  'Determining if a point lies on the interior of a polygon'.
 */

#line 138 "/home/dav480/tcl/nap/generic/geometry.c,m4"


#line 139

#line 139

#line 139
/*
#line 139
 *  Enter with z = -128 if corresponding x or y is missing, otherwise 0.
#line 139
 *
#line 139
 *  During processing z is set to -2 for "exactly on edge" & -1 for outside.
#line 139
 *  Values of 0 & 1 indicate current odd/even status with further processing needed.
#line 139
 *
#line 139
 *  At end change -2 to 0 & 0 to -1.
#line 139
 */
#line 139

#line 139
static int
#line 139
inPoly_F32(
#line 139
    NapClientData	*nap_cd,
#line 139
    size_t		nx,		/* # elements in x */
#line 139
    Nap_f32	*px,		/* pointer to x */
#line 139
    size_t		ny,		/* # elements in y */
#line 139
    Nap_f32	*py,		/* pointer to y */
#line 139
    size_t		nrp,		/* # rows in v (= vertices in polygon) */
#line 139
    size_t		ncp,		/* # columns in v */
#line 139
    Nap_f32	*pv,		/* pointer to v (vertices) (= p in inPolygon) */
#line 139
    size_t		nz,		/* # elements in z */
#line 139
    Nap_i8	mvz,		/* missing value of z (-128) */
#line 139
    Nap_i8	*z)		/* pointer to result (out) */
#line 139
{
#line 139
    int			i;		/* vertex subscript (row of v) */
#line 139
    int			j;		/* temp. subscript */
#line 139
    int			k;		/* subscript of z */
#line 139
    Nap_f32	x;		/* x-coord of point to test */
#line 139
    Nap_f32	xi;		/* x-coord of vertex i of polygon */
#line 139
    Nap_f32	xi1;		/* x-coord of vertex i+1 of polygon */
#line 139
    Nap_f32	xlength;	/* length of horizontal ray right from point to polygon */
#line 139
    Nap_f32	xmax, xmin;	/* bounding box of polygon */
#line 139
    Nap_f32	y;		/* y-coord of point to test */
#line 139
    Nap_f32	yi;		/* y-coord of vertex i of polygon */
#line 139
    Nap_f32	yi1;		/* y-coord of vertex i+1 of polygon */
#line 139
    Nap_f32	ymax, ymin;	/* bounding box of polygon */
#line 139

#line 139
    assert(mvz < -2  ||  mvz > 1);
#line 139
    xmin = xmax = pv[0];
#line 139
    ymin = ymax = pv[1];
#line 139
    for (i = 1; i < nrp; i++) {
#line 139
	j = i * ncp;
#line 139
	xi = pv[j];
#line 139
	yi = pv[j + 1];
#line 139
	if (xi < xmin) xmin = xi;
#line 139
	if (xi > xmax) xmax = xi;
#line 139
	if (yi < ymin) ymin = yi;
#line 139
	if (yi > ymax) ymax = yi;
#line 139
    }
#line 139
    for (k = 0; k < nz; k++) {
#line 139
	if (z[k] == 0) {
#line 139
	    x = px[k % nx];
#line 139
	    y = py[k % ny];
#line 139
	    if (x < xmin  ||  x > xmax  ||  y < ymin  ||  y > ymax) {
#line 139
		z[k] = -1;
#line 139
	    }
#line 139
	}
#line 139
    }
#line 139
    for (i = 0; i < nrp; i++) {
#line 139
	j = i * ncp;
#line 139
	xi = pv[j];
#line 139
	yi = pv[j + 1];
#line 139
	j = (i+1) % nrp * ncp;
#line 139
	xi1 = pv[j];
#line 139
	yi1 = pv[j + 1];
#line 139
	for (k = 0; k < nz; k++) {
#line 139
	    if (z[k] == 0  ||  z[k] == 1) {
#line 139
		x = px[k % nx];
#line 139
		y = py[k % ny];
#line 139
		if (y == yi && (x == xi || yi == yi1 &&
#line 139
			((xi <= x && x <= xi1) || (xi >= x && x >= xi1)))) {
#line 139
		    z[k] = -2;		/* -2 means on edge (change to 0 at end) */
#line 139
		} else if ((yi <= y  &&  y < yi1)  ||  (yi > y  &&  y >= yi1)) {
#line 139
		    xlength = xi + (y - yi) / (yi1 - yi) * (xi1 - xi) - x;
#line 139
		    if (xlength > 0) {
#line 139
			z[k] = 1 - z[k];	/* change 0 to 1, 1 to 0 */
#line 139
		    } else if (xlength == 0) {
#line 139
			z[k] = -2;
#line 139
		    }
#line 139
		}
#line 139
	    }
#line 139
	}
#line 139
    }
#line 139
    for (k = 0; k < nz; k++) {		/* change -2 to 0, 0 to -1 */
#line 139
	switch (z[k]) {
#line 139
	    case -2: z[k] =  0; break;
#line 139
	    case  0: z[k] = -1; break;
#line 139
	}
#line 139
    }
#line 139
    return TCL_OK;
#line 139
}
#line 139

#line 139

#line 139
/*
#line 139
 *  Enter with z = -128 if corresponding x or y is missing, otherwise 0.
#line 139
 *
#line 139
 *  During processing z is set to -2 for "exactly on edge" & -1 for outside.
#line 139
 *  Values of 0 & 1 indicate current odd/even status with further processing needed.
#line 139
 *
#line 139
 *  At end change -2 to 0 & 0 to -1.
#line 139
 */
#line 139

#line 139
static int
#line 139
inPoly_F64(
#line 139
    NapClientData	*nap_cd,
#line 139
    size_t		nx,		/* # elements in x */
#line 139
    Nap_f64	*px,		/* pointer to x */
#line 139
    size_t		ny,		/* # elements in y */
#line 139
    Nap_f64	*py,		/* pointer to y */
#line 139
    size_t		nrp,		/* # rows in v (= vertices in polygon) */
#line 139
    size_t		ncp,		/* # columns in v */
#line 139
    Nap_f64	*pv,		/* pointer to v (vertices) (= p in inPolygon) */
#line 139
    size_t		nz,		/* # elements in z */
#line 139
    Nap_i8	mvz,		/* missing value of z (-128) */
#line 139
    Nap_i8	*z)		/* pointer to result (out) */
#line 139
{
#line 139
    int			i;		/* vertex subscript (row of v) */
#line 139
    int			j;		/* temp. subscript */
#line 139
    int			k;		/* subscript of z */
#line 139
    Nap_f64	x;		/* x-coord of point to test */
#line 139
    Nap_f64	xi;		/* x-coord of vertex i of polygon */
#line 139
    Nap_f64	xi1;		/* x-coord of vertex i+1 of polygon */
#line 139
    Nap_f64	xlength;	/* length of horizontal ray right from point to polygon */
#line 139
    Nap_f64	xmax, xmin;	/* bounding box of polygon */
#line 139
    Nap_f64	y;		/* y-coord of point to test */
#line 139
    Nap_f64	yi;		/* y-coord of vertex i of polygon */
#line 139
    Nap_f64	yi1;		/* y-coord of vertex i+1 of polygon */
#line 139
    Nap_f64	ymax, ymin;	/* bounding box of polygon */
#line 139

#line 139
    assert(mvz < -2  ||  mvz > 1);
#line 139
    xmin = xmax = pv[0];
#line 139
    ymin = ymax = pv[1];
#line 139
    for (i = 1; i < nrp; i++) {
#line 139
	j = i * ncp;
#line 139
	xi = pv[j];
#line 139
	yi = pv[j + 1];
#line 139
	if (xi < xmin) xmin = xi;
#line 139
	if (xi > xmax) xmax = xi;
#line 139
	if (yi < ymin) ymin = yi;
#line 139
	if (yi > ymax) ymax = yi;
#line 139
    }
#line 139
    for (k = 0; k < nz; k++) {
#line 139
	if (z[k] == 0) {
#line 139
	    x = px[k % nx];
#line 139
	    y = py[k % ny];
#line 139
	    if (x < xmin  ||  x > xmax  ||  y < ymin  ||  y > ymax) {
#line 139
		z[k] = -1;
#line 139
	    }
#line 139
	}
#line 139
    }
#line 139
    for (i = 0; i < nrp; i++) {
#line 139
	j = i * ncp;
#line 139
	xi = pv[j];
#line 139
	yi = pv[j + 1];
#line 139
	j = (i+1) % nrp * ncp;
#line 139
	xi1 = pv[j];
#line 139
	yi1 = pv[j + 1];
#line 139
	for (k = 0; k < nz; k++) {
#line 139
	    if (z[k] == 0  ||  z[k] == 1) {
#line 139
		x = px[k % nx];
#line 139
		y = py[k % ny];
#line 139
		if (y == yi && (x == xi || yi == yi1 &&
#line 139
			((xi <= x && x <= xi1) || (xi >= x && x >= xi1)))) {
#line 139
		    z[k] = -2;		/* -2 means on edge (change to 0 at end) */
#line 139
		} else if ((yi <= y  &&  y < yi1)  ||  (yi > y  &&  y >= yi1)) {
#line 139
		    xlength = xi + (y - yi) / (yi1 - yi) * (xi1 - xi) - x;
#line 139
		    if (xlength > 0) {
#line 139
			z[k] = 1 - z[k];	/* change 0 to 1, 1 to 0 */
#line 139
		    } else if (xlength == 0) {
#line 139
			z[k] = -2;
#line 139
		    }
#line 139
		}
#line 139
	    }
#line 139
	}
#line 139
    }
#line 139
    for (k = 0; k < nz; k++) {		/* change -2 to 0, 0 to -1 */
#line 139
	switch (z[k]) {
#line 139
	    case -2: z[k] =  0; break;
#line 139
	    case  0: z[k] = -1; break;
#line 139
	}
#line 139
    }
#line 139
    return TCL_OK;
#line 139
}
#line 139


#line 160 "/home/dav480/tcl/nap/generic/geometry.c,m4"

EXTERN char *
Nap_inPolygon(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_NAO		*argx;			/* argument x */
    Nap_NAO		*argy;			/* argument y */
    Nap_NAO		*argp;			/* argument p */
    Nap_dataType        dataType;		/* for x, y, p */
    int			i;			/* subscript */
    Nap_NAO		*p;			/* vertices of polygon */
    int			status;			/* error code */
    Nap_NAO		*x;			/* x-coords of points to be tested */
    Nap_NAO		*y;			/* y-coords of points to be tested */
    Nap_NAO		*z;			/* result */

    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    Nap_IncrRefCount(nap_cd, box_nao);
    CHECK2NULL(box_nao->rank == 1, "Nap_inPolygon: box_nao rank not 1");
    CHECK2NULL(box_nao->nels == 3,  "Nap_inPolygon: Wrong number of arguments");
    argx = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    CHECK2NULL(argx, "Nap_inPolygon: Error calling Nap_GetNaoFromSlot");
    argy = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(argy, "Nap_inPolygon: Error calling Nap_GetNaoFromSlot");
    argp = Nap_GetNaoFromSlot(box_nao->data.Boxed[2]);
    CHECK2NULL(argp, "Nap_inPolygon: Error calling Nap_GetNaoFromSlot");
    dataType = NAP_F32;
    dataType = Nap_DataType2(dataType, argx->dataType);
    dataType = Nap_DataType2(dataType, argy->dataType);
    dataType = Nap_DataType2(dataType, argp->dataType);
    x = Nap_CastNAO(nap_cd, argx, dataType);
    CHECK2NULL(x, "Nap_inPolygon: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, x);
    y = Nap_CastNAO(nap_cd, argy, dataType);
    CHECK2NULL(y, "Nap_inPolygon: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, y);
    p = Nap_CastNAO(nap_cd, argp, dataType);
    CHECK2NULL(p, "Nap_inPolygon: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, p);
    CHECK2NULL(p->rank == 2, "Nap_inPolygon: p is not matrix");
    CHECK2NULL(p->shape[1] > 1, "Nap_inPolygon: p has < 2 columns");
    if (x->rank > y->rank) {
	z = Nap_NewNAO(nap_cd, NAP_I8, x->rank, x->shape);
    } else {
	z = Nap_NewNAO(nap_cd, NAP_I8, y->rank, y->shape);
    }
    for (i = 0; i < x->rank; i++) {
	CHECK2NULL(x->shape[i] == z->shape[i + z->rank - x->rank],
		"Nap_inPolygon: Shapes of x & y are incompatible");
    }
    for (i = 0; i < y->rank; i++) {
	CHECK2NULL(y->shape[i] == z->shape[i + z->rank - y->rank],
		"Nap_inPolygon: Shapes of x & y are incompatible");
    }
    status = Nap_CopyTrailingDims(nap_cd, x, z);
    CHECK2NULL(status == TCL_OK, "Nap_inPolygon: Error calling Nap_CopyTrailingDims");
    status = Nap_CopyTrailingDims(nap_cd, y, z);
    CHECK2NULL(status == TCL_OK, "Nap_inPolygon: Error calling Nap_CopyTrailingDims");
    switch (dataType) {
	
#line 221

#line 221
	    case NAP_F32:
#line 221
		for (i = 0; i < z->nels; i++) {
#line 221
		    z->data.I8[i] = (IsMissing(x, i % x->nels)  ||  IsMissing(y, i % y->nels))
#line 221
			    ? nap_cd->I8MissingValueNao->data.I8[0] : 0;
#line 221
		}
#line 221
		status = inPoly_F32(nap_cd, x->nels, x->data.F32, y->nels, y->data.F32,
#line 221
			p->shape[0], p->shape[1], p->data.F32, z->nels, nap_cd->I8MissingValueNao->data.I8[0],
#line 221
			z->data.I8);
#line 221
		CHECK2NULL(status == TCL_OK, "Nap_inPolygon: Error calling inPoly_F32");
#line 221
		break;
#line 221

#line 221
	    case NAP_F64:
#line 221
		for (i = 0; i < z->nels; i++) {
#line 221
		    z->data.I8[i] = (IsMissing(x, i % x->nels)  ||  IsMissing(y, i % y->nels))
#line 221
			    ? nap_cd->I8MissingValueNao->data.I8[0] : 0;
#line 221
		}
#line 221
		status = inPoly_F64(nap_cd, x->nels, x->data.F64, y->nels, y->data.F64,
#line 221
			p->shape[0], p->shape[1], p->data.F64, z->nels, nap_cd->I8MissingValueNao->data.I8[0],
#line 221
			z->data.I8);
#line 221
		CHECK2NULL(status == TCL_OK, "Nap_inPolygon: Error calling inPoly_F64");
#line 221
		break;
#line 221

	default: assert(0);
    }
    Nap_DecrRefCount(nap_cd, x);
    Nap_DecrRefCount(nap_cd, y);
    Nap_DecrRefCount(nap_cd, p);
    Nap_DecrRefCount(nap_cd, box_nao);
    return z->id;
}
