m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (geometry.c) */
/* It was produced from source file geometry.c,m4 */

/* 
 *	Copyright 2004, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Atmospheric Research
 */

#ifndef lint
static char *rcsid="@(#) $Id: geometry.c,m4,v 1.2 2005/03/04 05:35:06 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"

/*
 *  Nap_inPolygon --
 *
 *  Nap function 'inPolygon(x, y, p)'
 *  Tests whether points defined by 'x' & 'y' are inside, outside or on polygon defined by 'p'.
 *
 *  x & y must have shapes which are compatible with each other.
 *  Result has the same shape as x or y (whichever has the higher rank).
 *  Result has value -1 if (x,y) is outside, 0 if exactly on edge, 1 if inside.
 *  If x or y is missing then the result is missing.
 *
 *  p is matrix with 2 or more columns.  Each row corresponds to a vertex of the polygon.
 *  Column 0 contains x values & column 1 contains y values. Any further columns are ignored.
 *
 *  Based on function 'pnpoly' by Randolph Franklin at URL
 *  http://astronomy.swin.edu.au/~pbourke/geometry/insidepoly/
 *  This page was written by Paul Bourke in November 1987 & is titled
 *  'Determining if a point lies on the interior of a polygon'.
 */

m4begin

# m4inPoly(dataType)

m4define(`m4inPoly', `

/*
 *  Enter with z = -128 if corresponding x or y is missing, otherwise 0.
 *
 *  During processing z is set to -2 for "exactly on edge" & -1 for outside.
 *  Values of 0 & 1 indicate current odd/even status with further processing needed.
 *
 *  At end change -2 to 0 & 0 to -1.
 */

static int
inPoly_$1(
    NapClientData	*nap_cd,
    size_t		nx,		/* # elements in x */
    m4DataTypeName($1)	*px,		/* pointer to x */
    size_t		ny,		/* # elements in y */
    m4DataTypeName($1)	*py,		/* pointer to y */
    size_t		nrp,		/* # rows in v (= vertices in polygon) */
    size_t		ncp,		/* # columns in v */
    m4DataTypeName($1)	*pv,		/* pointer to v (vertices) (= p in inPolygon) */
    size_t		nz,		/* # elements in z */
    m4DataTypeName(I8)	mvz,		/* missing value of z (-128) */
    m4DataTypeName(I8)	*z)		/* pointer to result (out) */
{
    int			i;		/* vertex subscript (row of v) */
    int			j;		/* temp. subscript */
    int			k;		/* subscript of z */
    m4DataTypeName($1)	x;		/* x-coord of point to test */
    m4DataTypeName($1)	xi;		/* x-coord of vertex i of polygon */
    m4DataTypeName($1)	xi1;		/* x-coord of vertex i+1 of polygon */
    m4DataTypeName($1)	xlength;	/* length of horizontal ray right from point to polygon */
    m4DataTypeName($1)	xmax, xmin;	/* bounding box of polygon */
    m4DataTypeName($1)	y;		/* y-coord of point to test */
    m4DataTypeName($1)	yi;		/* y-coord of vertex i of polygon */
    m4DataTypeName($1)	yi1;		/* y-coord of vertex i+1 of polygon */
    m4DataTypeName($1)	ymax, ymin;	/* bounding box of polygon */

    assert(mvz < -2  ||  mvz > 1);
    xmin = xmax = pv[0];
    ymin = ymax = pv[1];
    for (i = 1; i < nrp; i++) {
	j = i * ncp;
	xi = pv[j];
	yi = pv[j + 1];
	if (xi < xmin) xmin = xi;
	if (xi > xmax) xmax = xi;
	if (yi < ymin) ymin = yi;
	if (yi > ymax) ymax = yi;
    }
    for (k = 0; k < nz; k++) {
	if (z[k] == 0) {
	    x = px[k % nx];
	    y = py[k % ny];
	    if (x < xmin  ||  x > xmax  ||  y < ymin  ||  y > ymax) {
		z[k] = -1;
	    }
	}
    }
    for (i = 0; i < nrp; i++) {
	j = i * ncp;
	xi = pv[j];
	yi = pv[j + 1];
	j = (i+1) % nrp * ncp;
	xi1 = pv[j];
	yi1 = pv[j + 1];
	for (k = 0; k < nz; k++) {
	    if (z[k] == 0  ||  z[k] == 1) {
		x = px[k % nx];
		y = py[k % ny];
		if (y == yi && (x == xi || yi == yi1 &&
			((xi <= x && x <= xi1) || (xi >= x && x >= xi1)))) {
		    z[k] = -2;		/* -2 means on edge (change to 0 at end) */
		} else if ((yi <= y  &&  y < yi1)  ||  (yi > y  &&  y >= yi1)) {
		    xlength = xi + (y - yi) / (yi1 - yi) * (xi1 - xi) - x;
		    if (xlength > 0) {
			z[k] = 1 - z[k];	/* change 0 to 1, 1 to 0 */
		    } else if (xlength == 0) {
			z[k] = -2;
		    }
		}
	    }
	}
    }
    for (k = 0; k < nz; k++) {		/* change -2 to 0, 0 to -1 */
	switch (z[k]) {
	    case -2: z[k] =  0; break;
	    case  0: z[k] = -1; break;
	}
    }
    return TCL_OK;
}')

m4end

m4ForAllRealDataType(`m4inPoly(', `)')

m4begin

# m4_inPolygon(dataType)

m4define(`m4_inPolygon', `
	    case m4DataTypeEnum($1):
		for (i = 0; i < z->nels; i++) {
		    z->data.I8[i] = (IsMissing(x, i % x->nels)  ||  IsMissing(y, i % y->nels))
			    ? m4MissingValue(I8) : 0;
		}
		status = inPoly_$1(nap_cd, x->nels, x->data.$1, y->nels, y->data.$1,
			p->shape[0], p->shape[1], p->data.$1, z->nels, m4MissingValue(I8),
			z->data.I8);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling inPoly_$1");
		break;')

m4define(`m4NAME', `Nap_inPolygon')

m4end

EXTERN char *
Nap_inPolygon(
    NapClientData	*nap_cd, 
    Nap_NAO		*box_nao)		/* points to user's arguments */
{
    Nap_NAO		*argx;			/* argument x */
    Nap_NAO		*argy;			/* argument y */
    Nap_NAO		*argp;			/* argument p */
    Nap_dataType        dataType;		/* for x, y, p */
    int			i;			/* subscript */
    Nap_NAO		*p;			/* vertices of polygon */
    int			status;			/* error code */
    Nap_NAO		*x;			/* x-coords of points to be tested */
    Nap_NAO		*y;			/* y-coords of points to be tested */
    Nap_NAO		*z;			/* result */

    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    Nap_IncrRefCount(nap_cd, box_nao);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: box_nao rank not 1");
    CHECK2NULL(box_nao->nels == 3,  "m4NAME: Wrong number of arguments");
    argx = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    CHECK2NULL(argx, "m4NAME: Error calling Nap_GetNaoFromSlot");
    argy = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(argy, "m4NAME: Error calling Nap_GetNaoFromSlot");
    argp = Nap_GetNaoFromSlot(box_nao->data.Boxed[2]);
    CHECK2NULL(argp, "m4NAME: Error calling Nap_GetNaoFromSlot");
    dataType = m4DataTypeEnum(m4MinRealDataType);
    dataType = Nap_DataType2(dataType, argx->dataType);
    dataType = Nap_DataType2(dataType, argy->dataType);
    dataType = Nap_DataType2(dataType, argp->dataType);
    x = Nap_CastNAO(nap_cd, argx, dataType);
    CHECK2NULL(x, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, x);
    y = Nap_CastNAO(nap_cd, argy, dataType);
    CHECK2NULL(y, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, y);
    p = Nap_CastNAO(nap_cd, argp, dataType);
    CHECK2NULL(p, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, p);
    CHECK2NULL(p->rank == 2, "m4NAME: p is not matrix");
    CHECK2NULL(p->shape[1] > 1, "m4NAME: p has < 2 columns");
    if (x->rank > y->rank) {
	z = Nap_NewNAO(nap_cd, NAP_I8, x->rank, x->shape);
    } else {
	z = Nap_NewNAO(nap_cd, NAP_I8, y->rank, y->shape);
    }
    for (i = 0; i < x->rank; i++) {
	CHECK2NULL(x->shape[i] == z->shape[i + z->rank - x->rank],
		"m4NAME: Shapes of x & y are incompatible");
    }
    for (i = 0; i < y->rank; i++) {
	CHECK2NULL(y->shape[i] == z->shape[i + z->rank - y->rank],
		"m4NAME: Shapes of x & y are incompatible");
    }
    status = Nap_CopyTrailingDims(nap_cd, x, z);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyTrailingDims");
    status = Nap_CopyTrailingDims(nap_cd, y, z);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_CopyTrailingDims");
    switch (dataType) {
	m4ForAllRealDataType(`m4_inPolygon(', `)')
	default: assert(0);
    }
    Nap_DecrRefCount(nap_cd, x);
    Nap_DecrRefCount(nap_cd, y);
    Nap_DecrRefCount(nap_cd, p);
    Nap_DecrRefCount(nap_cd, box_nao);
    return z->id;
}
