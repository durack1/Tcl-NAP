m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (napDyad.c) */
/* It was produced from source file napDyad.c,m4 */

/* 
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napDyad.c,m4,v 1.154 2006/11/30 03:07:40 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"

/*
 *  Nap_DataType2 --
 *	Gives data type of result from data type of two arguments.
 *	Both types should be numeric or character - else return NAP_NULL_TYPE.
 */

m4define(`m4NAME', `Nap_DataType2')

EXTERN Nap_dataType
Nap_DataType2(
    Nap_dataType        t1,		/* dataType of left arg */
    Nap_dataType        t2)		/* dataType of right arg */
{
    double		m;		/* max exact int float */
    double		max2;		/* max value spanning two types */
    double		min2;		/* min value spanning two types */
    Nap_dataType        tmax;
    Nap_dataType        tmin;
    Nap_dataType        result;

    if (Nap_TypeIsUnboxed(t1) && Nap_TypeIsUnboxed(t2)) {
	tmax = Max(t1, t2);
	tmin = Min(t1, t2);
	result = tmax;
	if (Nap_TypeIsInteger(tmax)) {
	    max2 = Max(Nap_MaxOf(t1), Nap_MaxOf(t2));
	    min2 = Min(Nap_MinOf(t1), Nap_MinOf(t2));
	    while (result < NAP_F64  &&  (min2 < Nap_MinOf(result)  ||  max2 > Nap_MaxOf(result))) {
		++result;
	    }
	} else if (Nap_TypeIsInteger(tmin)  &&  tmax == NAP_F32) {
	    m = ldexp(1.0, FLT_MANT_DIG) - 1.0;
	    if (Nap_MaxOf(tmin) > m) {
		result = NAP_F64;
	    }
	}
    } else {
	result = NAP_NULL_TYPE;
    }
    return result;
}

/*
 *  Nap_DyadArgs --
 *      Get left & right argument naos.
 *      Do padding if needed.
 *      Both have ref. count incremented.
 */

m4define(`m4NAME', `Nap_DyadArgs')

static int
Nap_DyadArgs(
    NapClientData       *nap_cd,
    char		*left,			/* id of left arg (in) */
    char		*right,			/* id of right arg (in) */
    Nap_NAO		**naoLeftPtr,		/* new left arg (out) */
    Nap_NAO		**naoRightPtr)		/* new right arg (out) */
{
    Nap_NAO		*naoLeft;		/* new left arg */
    Nap_NAO		*naoPtr;
    Nap_NAO		*naoRight;		/* new right arg */
    int			status;

    naoPtr = Nap_GetNaoFromId(nap_cd, left);
    CHECK2(naoPtr, "m4NAME: Undefined left-hand operand");
    naoLeft = Nap_GetNumericNaoFromId(nap_cd, left);
    CHECK2(naoLeft, "m4NAME: Non-numeric left-hand operand");
    Nap_IncrRefCount(nap_cd, naoLeft);
    CHECK2(Nap_IsUnboxed(naoLeft), "m4NAME: Boxed left-hand operand");
    naoPtr = Nap_GetNaoFromId(nap_cd, right);
    CHECK2(naoPtr, "m4NAME: Undefined right-hand operand");
    naoRight = Nap_GetNumericNaoFromId(nap_cd, right);
    CHECK2(naoRight, "m4NAME: Non-numeric right-hand operand");
    Nap_IncrRefCount(nap_cd, naoRight);
    CHECK2(Nap_IsUnboxed(naoRight), "m4NAME: Boxed right-hand operand");
    *naoLeftPtr  = naoLeft;
    *naoRightPtr = naoRight;
    return TCL_OK;
}


/*
 *  Nap_DyadInit --
 *      Define NAOs for arguments & result, etc.
 */

m4define(`m4NAME', `Nap_DyadInit')

static int
Nap_DyadInit(
    NapClientData       *nap_cd,
    Nap_NAO		*nao1,			/* left arg (in) */
    Nap_NAO		*nao2,			/* right arg (in) */
    Nap_dataType        dataType1,		/* dataType for left arg (in) */
    Nap_dataType        dataType2,		/* dataType for right arg (in) */
    Nap_dataType        resultDataType,		/* adjusted if result has unit (in) */
    int			resultHasMissingValue,	/* TRUE/FALSE (in) */
    Nap_NAO		**naoPtr1Ptr,		/* left arg (out) */
    Nap_NAO		**naoPtr2Ptr,		/* right arg (out) */
    Nap_NAO		**naoResultPtrPtr)	/* result (out) */
{
    Nap_NAO             *coordNaoPtr;           /* coordinate variable */
    char                *dimName;               /* dimension name */
    int			i;
    int			i1;
    int			i2;
    Nap_NAO		*naoMissingValuePtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoResultPtr;
    int                 rank;
    size_t              *shape;
    int			status;
    double		tmp_double;

    naoPtr1 = Nap_CastNAO(nap_cd, nao1, dataType1);
    Nap_IncrRefCount(nap_cd, naoPtr1);
    naoPtr2 = Nap_CastNAO(nap_cd, nao2, dataType2);
    Nap_IncrRefCount(nap_cd, naoPtr2);
    if (naoPtr1->rank > naoPtr2->rank) {
	rank = naoPtr1->rank;
	shape = naoPtr1->shape;
    } else {
	rank = naoPtr2->rank;
	shape = naoPtr2->shape;
    }
    for (i = 0; i < rank; i++) {
	i1 = naoPtr1->rank + i - rank;
	i2 = naoPtr2->rank + i - rank;
	CHECK4(i1 < 0  ||  i2 < 0  ||  naoPtr1->shape[i1] == naoPtr2->shape[i2],
		"m4NAME: Dimension %d of left operand has different size from "
		"dimension %d of right operand",
		i1, i2);
    }
    naoResultPtr = Nap_NewNAO(nap_cd, resultDataType, rank, shape);
    CHECK2(naoResultPtr, "m4NAME: Error calling Nap_NewNAO");
    if (resultHasMissingValue) {
	if (naoResultPtr->missingValueSlot == 0) {
	    naoMissingValuePtr = Nap_StandardMissingValueNAO(nap_cd, resultDataType);
	    status = Nap_SetMissing(nap_cd, naoResultPtr, naoMissingValuePtr->slot);
	    CHECK(status == TCL_OK);
	}
    } else {
	status = Nap_SetMissing(nap_cd, naoResultPtr, 0);
	CHECK(status == TCL_OK);
    }
    for (i = 0; i < rank; i++) {
	coordNaoPtr = NULL;
	dimName = NULL;
	i1 = nao1->rank + i - rank;
	i2 = nao2->rank + i - rank;
	if (i1 >= 0) {
	    coordNaoPtr = Nap_GetCoordVar(nap_cd, nao1, i1);
	    dimName = nao1->dimName[i1];
	}
	if (i2 >= 0) {
	    if (!coordNaoPtr) {
		coordNaoPtr = Nap_GetCoordVar(nap_cd, nao2, i2);
	    }
	    if (!dimName) {
		dimName = nao2->dimName[i2];
	    }
	}
	status = Nap_AttachCoordVar(nap_cd, naoResultPtr, coordNaoPtr, dimName, i);
	CHECK(status == TCL_OK);
    }
    *naoPtr1Ptr = naoPtr1;
    *naoPtr2Ptr = naoPtr2;
    *naoResultPtrPtr = naoResultPtr;
    Nap_DecrRefCount(nap_cd, nao1);
    Nap_DecrRefCount(nap_cd, nao2);
    return TCL_OK;
}

m4begin

#	m4dyad3(resultDataType, arg1DataType, arg2DataType, resultMissingValue)
m4define(`m4dyad3', `
		case m4DataTypeEnum($3):
		    for (i = 0; i < naoResultPtr->nels; i++) {
			i1 = i % naoPtr1->nels;
			i2 = i % naoPtr2->nels;
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
			    naoResultPtr->data.$1[i] = $4;
			} else {
			    naoResultPtr->data.$1[i] = 
				    m4op(naoPtr1->data.$2[i1], naoPtr2->data.$3[i2], $4);
			}
		    }
		    break;')

#  m4arith1(dataType)
m4define(`m4arith1', `m4dyad3($1, $1, $1, m4MissingValue($1))')

#  m4arith(name, unitMode, intDefn, floatDefn, doubleDefn)
#  floatDefn  defaults to intDefn
#  doubleDefn defaults to intDefn
#  e.g. m4arith(`Rem', '%', `Nap_mod($1,$2)', `Nap_fmod_f32($1, $2)', `Nap_fmod($1, $2)')
m4define(`m4arith', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = TRUE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_dataType        resultDataType;
    int			status;

    status = Nap_DyadArgs(nap_cd, str1, str2, &naoPtr1, &naoPtr2);
    CHECK2NULL(status == TCL_OK, "Nap_$1: Error calling Nap_DyadArgs");
    resultDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
	    resultHasMissingValue, &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK2NULL(status == TCL_OK, "Nap_$1: Error calling Nap_DyadInit");
    switch (naoResultPtr->dataType) {
m4define(`m4op', `$3')
    m4ForAllIntegerDataType(`m4arith1(', `)')
m4define(`m4op', m4ifelse(`$4', `', `$3', `$4'))
    m4arith1(F32)
m4define(`m4op', m4ifelse(`$5', `', `$3', `$5'))
    m4arith1(F64)
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return naoResultPtr->id;
}
')

m4end

m4arith(`Add', `+', `$1 + $2')
m4arith(`Sub', `+', `$1 - $2')
m4arith(`Mul', `*', `$1 * $2')
m4arith(`LesserOf', `+', `Min($1, $2)')
m4arith(`GreaterOf', `+', `Max($1, $2)')
m4arith(`Div', `/', `$2?$1/$2:$3', `$1/$2', `$1/$2')
m4arith(`Rem', `%', `Nap_mod($1,$2)', `Nap_fmod_f32($1, $2)', `Nap_fmod($1, $2)')

m4begin

#  m4real(name, unitMode, defn)
#  e.g. m4real(`Power', 'p', `Pow($1, $2)')
m4define(`m4real', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = TRUE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_dataType        resultDataType;
    int			status;

    status = Nap_DyadArgs(nap_cd, str1, str2, &naoPtr1, &naoPtr2);
    CHECK1NULL(status == TCL_OK);
    resultDataType = Max(naoPtr1->dataType, naoPtr2->dataType);
    resultDataType = Max(resultDataType, m4DataTypeEnum(m4MinRealDataType));
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
	    resultHasMissingValue, &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (naoResultPtr->dataType) {
m4define(`m4op', `$3')
    m4ForAllRealDataType(`m4arith1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return naoResultPtr->id;
}
')

m4end

m4real(`Power', `p', `Pow($1, $2)')
m4real(`Atan2', ` ', `atan2($1, $2)')
m4real(`Hypot', `+', `hypot($1, $2)')
m4real(`Log',   ` ', `log($1) / log($2)')

m4begin

#  m4boolean2(leftDataType, rightDataType)
m4define(`m4boolean2',
	`m4dyad3(m4MinIntegerDataType, $1, $2, m4MissingValue(m4MinIntegerDataType))')

#  m4boolean1(leftDataType)
m4define(`m4boolean1', `
    case m4DataTypeEnum($1):
	switch (naoPtr2->dataType) {
	m4ForAllNumericDataType(`m4boolean2($1, ', `)')
	default:            /* error */
	    assert(FALSE);
	}
	break;')

#  m4boolean(name, defn)
m4define(`m4boolean', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = TRUE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    int			status;

    status = Nap_DyadArgs(nap_cd, str1, str2, &naoPtr1, &naoPtr2);
    CHECK1NULL(status == TCL_OK);
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, naoPtr1->dataType, naoPtr2->dataType,
	    m4DataTypeEnum(m4MinIntegerDataType), resultHasMissingValue,
	    &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (naoPtr1->dataType) {
m4define(`m4op', `$2')
    m4ForAllNumericDataType(`m4boolean1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return naoResultPtr->id;
}
')

m4end

m4boolean(`And', `$1 && $2')
m4boolean(`Or',  `$1 || $2')

m4begin

m4define(`m4relational1', `m4dyad3(m4MinIntegerDataType, $1, $1, m4resultMV)')

#  m4relational(name, defn, resultMissingValue)
m4define(`m4relational', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    Nap_dataType	argDataType;
    const int		resultHasMissingValue = FALSE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    int			status;

    status = Nap_DyadArgs(nap_cd, str1, str2, &naoPtr1, &naoPtr2);
    CHECK1NULL(status == TCL_OK);
    argDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, argDataType, argDataType,
	    m4DataTypeEnum(m4MinIntegerDataType), resultHasMissingValue,
	    &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (argDataType) {
m4define(`m4op', `$2')
m4define(`m4resultMV', `$3')
    m4ForAllUnboxedDataType(`m4relational1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return naoResultPtr->id;
}
')

m4end

m4relational(`Eq', `$1 == $2', 0)
m4relational(`Ne', `$1 != $2', 1)
m4relational(`Lt', `$1 <  $2', 0)
m4relational(`Le', `$1 <= $2', 0)
m4relational(`Gt', `$1 >  $2', 0)
m4relational(`Ge', `$1 >= $2', 0)

m4begin

#  m4bit(name, defn)
m4define(`m4bit', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = FALSE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_dataType        resultDataType;
    int			status;

    status = Nap_DyadArgs(nap_cd, str1, str2, &naoPtr1, &naoPtr2);
    CHECK1NULL(status == TCL_OK);
    resultDataType = Min(NAP_U32, Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType));
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
	    resultHasMissingValue, &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (naoResultPtr->dataType) {
m4define(`m4op', `$2')
    m4ForAllIntegerDataType(`m4arith1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return naoResultPtr->id;
}
')

m4end

m4bit(`BitAnd', `$1 & $2')
m4bit(`BitOr',  `$1 | $2')
m4bit(`BitXor', `$1 ^ $2')

m4begin

#  m4shift2(leftDataType, rightDataType)
m4define(`m4shift2', `m4dyad3($1, $1, $2, m4MissingValue($1))')

#  m4shift1(leftDataType)
m4define(`m4shift1', `
	case m4DataTypeEnum($1):
	    switch (naoPtr2->dataType) {
	    m4ForAllIntegerDataType(`m4shift2($1, ', `)')
	    default:            /* error */
		assert(FALSE);
	    }
	    break;')

#  m4shift(name, defn)
m4define(`m4shift', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = FALSE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    int			status;

    status = Nap_DyadArgs(nap_cd, str1, str2, &naoPtr1, &naoPtr2);
    CHECK1NULL(status == TCL_OK);
    CHECK2NULL(Nap_TypeIsInteger(naoPtr1->dataType) && Nap_TypeIsInteger(naoPtr2->dataType), m4dnl
	    "Nap_$1: Shift operator has non-integer argument");
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, naoPtr1->dataType, naoPtr2->dataType,
	    naoPtr1->dataType, resultHasMissingValue, &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (naoResultPtr->dataType) {
m4define(`m4op', `$2')
    m4ForAllIntegerDataType(`m4shift1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return naoResultPtr->id;
}
')

m4end

m4shift(`ShiftLeft',  `$1 << $2')
m4shift(`ShiftRight', `$1 >> $2')


/*
 * Nap_AP_check --
 *
 *	Called by Nap_AP & Nap_AP_arg
 */

static int
Nap_AP_check(
    NapClientData	*nap_cd,
    Nap_NAO		*naoPtr,
    char		*name)		/* name of arg for messages */
{
    CHECK3(naoPtr , "m4NAME: Operand '%s' is bad", name);
    CHECK3(Nap_TypeIsNumeric(naoPtr->dataType), "m4NAME: Operand '%s' is not numeric", name);
    CHECK3(naoPtr->rank == 0, "m4NAME: Operand '%s' is not scalar", name);
    CHECK3(!IsMissing(naoPtr, 0), "m4NAME: Operand '%s' == missing value", name);
    return TCL_OK;
}

/*
 * Nap_AP_arg --
 *
 *	Called by Nap_AP
 */

static Nap_NAO *
Nap_AP_arg(
    NapClientData	*nap_cd,
    Nap_NAO		*naoPtr,
    int			i,		/* index of this arg within naoPtr */
    char		*name)		/* name of arg for messages */
{
    Nap_NAO		*result;
    int			status;

    if (i < naoPtr->nels) {
	result = Nap_GetNaoFromSlot(naoPtr->data.Boxed[i]);
	status = Nap_AP_check(nap_cd, result, name);
	Nap_IncrRefCount(nap_cd, result);
	if (status != TCL_OK) {
	    Nap_DecrRefCount(nap_cd, result);
	    CHECK1NULL(FALSE);
	}
    } else {
	result = NULL;
    }
    return result;
}

/*
 * Nap_AP --
 *      Generate arithmetic progression -- operator '..'
 *
 *	Either operand can be boxed, but not both
 *	If left  argument is unboxed it represents 'from' value
 *	If right argument is unboxed it represents 'to' value
 *	If left  argument is unboxed it represents values: (n , from)
 *		where n is # elements in result
 *	If right argument is unboxed it represents values: (to , step [, tolerance])
 *		where tolerance (default 1e-9) is used to define n=floor((to-from)/step+tolerance)
 */

m4begin

# m4generateAP(type)  -- with specified step
m4define(`m4generateAP', `
            case m4DataTypeEnum($1):
                for (i = 0; i < n; i++) {
                    result->data.$1[i] = naoFrom->data.$1[0] + i * step;
                }
                break;')

# m4generateAP1(type,sign)  -- with step of -1 or +1
m4define(`m4generateAP1', `
            case m4DataTypeEnum($1):
                for (i = 0; i < n; i++) {
                    result->data.$1[i] = naoFrom->data.$1[0] $2 i;
                }
                break;')

# m4appendAP(type)
m4define(`m4appendAP', `
            case m4DataTypeEnum($1):
		result->data.$1[n] = to;
                break;')

m4define(`m4NAME', `Nap_AP')

m4end

EXTERN char *
Nap_AP(
    NapClientData	*nap_cd,
    char		*str1,		/* 'from' value */
    char		*str2)		/* either 'to' value or 'to,step' (boxed) */
{
    Nap_dataType	dataType;
    int                 extra;		/* 1 if need extra element at end, else 0 */
    double              from;		/* initial value of A.P. */
    size_t		i;
    int                 n;		/* integer number of elements in A.P. */
    					/*(excludes any extra element at end) */
    double              nn;		/* floating point number of elements in A.P. */
    Nap_NAO		*naoFrom = NULL;
    Nap_NAO		*naoN = NULL;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoStep = NULL;
    Nap_NAO		*naoTol = NULL;
    Nap_NAO		*naoTo = NULL;
    Nap_NAO		*result;
    size_t		shape[1];
    int			status;
    double              step;           /* A.P. increment */
    double              to;		/* final value of A.P. */
    double              tol = 1.0e-9;	/* tolerance (see above) */
    Nap_NAO		*tmp;

    CHECK2NULL(str1, "m4NAME: Left argument of .. is NULL");
    naoPtr1 = Nap_GetNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Bad left argument of ..");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    if (naoPtr1->dataType == NAP_BOXED) {
	CHECK2NULL(naoPtr1->rank == 1, "m4NAME: Left boxed argument of .. is not vector");
	CHECK2NULL(naoPtr1->nels == 2, "m4NAME: Left boxed argument of .. does not have shape {2}");
	naoN    = Nap_AP_arg(nap_cd, naoPtr1, 0, "n");
	CHECK1NULL(naoN);
	naoFrom = Nap_AP_arg(nap_cd, naoPtr1, 1, "from");
	CHECK1NULL(naoFrom);
    } else {
	naoFrom = naoPtr1;
	status = Nap_AP_check(nap_cd, naoFrom, "from");
	Nap_IncrRefCount(nap_cd, naoFrom);
	if (status != TCL_OK) {
	    Nap_DecrRefCount(nap_cd, naoFrom);
	    CHECK1NULL(FALSE);
	}
    }
    CHECK2NULL(str2, "m4NAME: Right argument of .. is NULL");
    naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
    CHECK2NULL(naoPtr2, "m4NAME: Bad right argument of ..");
    Nap_IncrRefCount(nap_cd, naoPtr2);
    if (naoPtr2->dataType == NAP_BOXED) {
	CHECK2NULL(naoPtr2->rank == 1, "m4NAME: Right boxed argument of .. is not vector");
	CHECK2NULL(naoPtr2->nels == 2 || naoPtr2->nels == 3,
		"m4NAME: Right boxed argument of .. does not have shape {2} or {3}");
	naoTo   = Nap_AP_arg(nap_cd, naoPtr2, 0, "to");
	CHECK1NULL(naoTo);
	naoStep = Nap_AP_arg(nap_cd, naoPtr2, 1, "step");
	CHECK1NULL(naoStep);
	if (naoPtr2->nels == 3) {
	    naoTol  = Nap_AP_arg(nap_cd, naoPtr2, 2, "tolerance");
	    CHECK1NULL(naoTol);
	}
    } else {
	naoTo = naoPtr2;
	status = Nap_AP_check(nap_cd, naoTo, "to");
	Nap_IncrRefCount(nap_cd, naoTo);
	if (status != TCL_OK) {
	    Nap_DecrRefCount(nap_cd, naoTo);
	    CHECK1NULL(FALSE);
	}
    }
    assert(naoFrom);
    CHECK2NULL(!naoN || !naoStep, "m4NAME: Both 'n' and 'step' specified");
    status = Nap_F64ScalarValue(nap_cd, naoFrom, &from);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
    assert(naoTo);
    status = Nap_F64ScalarValue(nap_cd, naoTo, &to);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
    dataType = Nap_DataType2(naoFrom->dataType, naoTo->dataType);
    if (from == to) {
	step = 1.0;
	nn = 1.0;
    } else if (naoN) {
	status = Nap_F64ScalarValue(nap_cd, naoN, &nn);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
	nn = Max(0.0, nn);
	step = nn == 1.0 ? 1.0 : (to - from) / (nn - 1.0);
    } else {
	if (naoStep) {
	    status = Nap_F64ScalarValue(nap_cd, naoStep, &step);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
	    if (naoTol) {
		status = Nap_F64ScalarValue(nap_cd, naoTol, &tol);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
	    }
	} else {
	    step = Sign(to - from);
	}
	nn = step ? 1.0 + (to - from) / step : 0.0;
    }
    nn = Max(0.0, floor(nn+tol) > floor(nn) ? ceil(nn) : nn);
    n = nn;
    if (step != floor(step)) {
	dataType = Nap_DataType2(dataType, NAP_F32);
    }
    tmp = naoFrom;
    naoFrom = Nap_CastNAO(nap_cd, tmp, dataType);
    Nap_IncrRefCount(nap_cd, naoFrom);
    Nap_DecrRefCount(nap_cd, tmp);
    tmp = naoTo;
    naoTo = Nap_CastNAO(nap_cd, tmp, dataType);
    Nap_IncrRefCount(nap_cd, naoTo);
    Nap_DecrRefCount(nap_cd, tmp);
    extra = nn > n+tol;
    shape[0] = n + extra;
    result = Nap_NewNAO(nap_cd, dataType, 1, shape);
    if (n > 0) {
	if (step == 1.0) {
	    switch (dataType) {
		m4ForAllNumericDataType(`m4generateAP1(', `,+)')
		default:                /* error */
		    return NULL;
	    }
	} else if (step == -1.0) {
	    switch (dataType) {
		m4ForAllNumericDataType(`m4generateAP1(', `,-)')
		default:                /* error */
		    return NULL;
	    }
	} else {
	    switch (dataType) {
		m4ForAllNumericDataType(`m4generateAP(', `)')
		default:                /* error */
		    return NULL;
	    }
	}
    }
    if (extra) {
	switch (dataType) {
	    m4ForAllNumericDataType(`m4appendAP(', `)')
	    default:                /* error */
		return NULL;
	}
    }
    Nap_DecrRefCount(nap_cd, naoN);
    Nap_DecrRefCount(nap_cd, naoFrom);
    Nap_DecrRefCount(nap_cd, naoTo);
    Nap_DecrRefCount(nap_cd, naoStep);
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    result->step = NAP_STEP_EQUAL;
    return result->id;
}
