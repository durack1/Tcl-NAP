m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (napDyad.c) */
/* It was produced from source file napDyad.c,m4 */

/* 
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napDyad.c,m4,v 1.136 2003/06/13 06:45:26 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"
#include "linsys.h"

/*
 *  Nap_DataType2 --
 *	Gives data type of result from data type of two arguments.
 *	Both types should be numeric or character - else return NAP_NULL_TYPE.
 */

m4define(`m4NAME', `Nap_DataType2')

Nap_dataType
Nap_DataType2(
    Nap_dataType        t1,		/* dataType of left arg */
    Nap_dataType        t2)		/* dataType of right arg */
{
    double		m;		/* max exact int float */
    double		max2;		/* max value spanning two types */
    double		min2;		/* min value spanning two types */
    Nap_dataType        tmax;
    Nap_dataType        tmin;
    Nap_dataType        result;

    if (Nap_TypeIsUnboxed(t1) && Nap_TypeIsUnboxed(t2)) {
	tmax = Max(t1, t2);
	tmin = Min(t1, t2);
	result = tmax;
	if (Nap_TypeIsInteger(tmax)) {
	    max2 = Max(Nap_MaxOf(t1), Nap_MaxOf(t2));
	    min2 = Min(Nap_MinOf(t1), Nap_MinOf(t2));
	    while (result < NAP_F64  &&  (min2 < Nap_MinOf(result)  ||  max2 > Nap_MaxOf(result))) {
		++result;
	    }
	} else if (Nap_TypeIsInteger(tmin)  &&  tmax == NAP_F32) {
	    m = ldexp(1.0, FLT_MANT_DIG) - 1.0;
	    if (Nap_MaxOf(tmin) > m) {
		result = NAP_F64;
	    }
	}
    } else {
	result = NAP_NULL_TYPE;
    }
    return result;
}

/*
 *  Nap_DyadArg --
 *      Get left/right argument nao (padded if original ragged, but otherwise original type)
 */

m4define(`m4NAME', `Nap_DyadArg')

static Nap_NAO
*Nap_DyadArg(
    NapClientData       *nap_cd,
    char		*str)			/* id of arg (in) */
{
    Nap_NAO		*naoPtr;
    Nap_NAO		*naoResultPtr;

    naoPtr = Nap_GetNaoFromId(nap_cd, str);
    CHECK2NULL(naoPtr, "m4NAME: Undefined left-hand operand");
    naoResultPtr = Nap_GetNumericNaoFromId(nap_cd, str);
    CHECK2NULL(naoResultPtr, "m4NAME: Non-numeric left-hand operand");
    Nap_IncrRefCount(nap_cd, naoPtr);
    Nap_IncrRefCount(nap_cd, naoResultPtr);
    Nap_DecrRefCount(nap_cd, naoPtr);
    CHECK2NULL(Nap_IsUnboxed(naoResultPtr), "m4NAME: Boxed left-hand operand");
    return naoResultPtr;
}


/*
 *  Nap_DyadInit --
 *      Define NAOs for arguments & result, etc.
 */

m4define(`m4NAME', `Nap_DyadInit')

static int
Nap_DyadInit(
    NapClientData       *nap_cd,
    Nap_NAO		*nao1,			/* left arg (in) */
    Nap_NAO		*nao2,			/* right arg (in) */
    Nap_dataType        dataType1,		/* dataType for left arg (in) */
    Nap_dataType        dataType2,		/* dataType for right arg (in) */
    Nap_dataType        resultDataType,		/* (in) */
    int			resultHasMissingValue,	/* TRUE/FALSE (in) */
    Nap_NAO		**naoPtr1Ptr,		/* left arg (out) */
    Nap_NAO		**naoPtr2Ptr,		/* right arg (out) */
    Nap_NAO		**naoResultPtrPtr)	/* result (out) */
{
    Nap_NAO             *coordNaoPtr;           /* coordinate variable */
    char                *dimName;               /* dimension name */
    size_t		i;
    int			i1;
    int			i2;
    Nap_NAO		*naoMissingValuePtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoResultPtr;
    int                 rank;
    size_t              *shape;
    int			status;

    naoPtr1 = Nap_CastNAO(nap_cd, nao1, dataType1);
    Nap_IncrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, nao1);

    naoPtr2 = Nap_CastNAO(nap_cd, nao2, dataType2);
    Nap_IncrRefCount(nap_cd, naoPtr2);
    Nap_DecrRefCount(nap_cd, nao2);

    if (naoPtr1->rank > naoPtr2->rank) {
	rank = naoPtr1->rank;
	shape = naoPtr1->shape;
    } else {
	rank = naoPtr2->rank;
	shape = naoPtr2->shape;
    }
    for (i = 0; i < Min(naoPtr1->rank, naoPtr2->rank); i++) {
	i1 = naoPtr1->rank - i - 1;
	i2 = naoPtr2->rank - i - 1;
	CHECK4(naoPtr1->shape[i1] == naoPtr2->shape[i2],
		"m4NAME: Dimension %d of left operand has different size from "
		"dimension %d of right operand",
		i1, i2);
    }
    naoResultPtr = Nap_NewNAO(nap_cd, resultDataType, rank, shape);
    CHECK2(naoResultPtr, "m4NAME: Error calling Nap_NewNAO");
    if (resultHasMissingValue) {
	if (naoResultPtr->missingValueSlot == 0) {
	    naoMissingValuePtr = Nap_StandardMissingValueNAO(nap_cd, resultDataType);
	    status = Nap_SetMissing(nap_cd, naoResultPtr, naoMissingValuePtr->slot);
	    CHECK(status == TCL_OK);
	}
    } else {
	status = Nap_SetMissing(nap_cd, naoResultPtr, 0);
	CHECK(status == TCL_OK);
    }
    for (i = 0; i < rank; i++) {
	coordNaoPtr = Nap_GetCoordVar(nap_cd, naoPtr1, i);
	if (!coordNaoPtr) {
	    coordNaoPtr = Nap_GetCoordVar(nap_cd, naoPtr2, i);
	}
	dimName = NULL;
	if (i < naoPtr1->rank) {
	    dimName = naoPtr1->dimName[i];
	}
	if (i < naoPtr2->rank  &&  !dimName) {
	    dimName = naoPtr2->dimName[i];
	}
	status = Nap_AttachCoordVar(nap_cd, naoResultPtr, coordNaoPtr, dimName, i);
	CHECK(status == TCL_OK);
    }
    *naoPtr1Ptr = naoPtr1;
    *naoPtr2Ptr = naoPtr2;
    *naoResultPtrPtr = naoResultPtr;
    return TCL_OK;
}

m4begin

#	m4dyad3(resultDataType, arg1DataType, arg2DataType, resultMissingValue)
m4define(`m4dyad3', `
		case m4DataTypeEnum($3):
		    for (i = 0; i < naoResultPtr->nels; i++) {
			i1 = i % naoPtr1->nels;
			i2 = i % naoPtr2->nels;
			if (IsMissing(naoPtr1, i1)  || IsMissing(naoPtr2, i2)) {
			    naoResultPtr->data.$1[i] = $4;
			} else {
			    naoResultPtr->data.$1[i] = 
				    m4op(naoPtr1->data.$2[i1], naoPtr2->data.$3[i2], $4);
			}
		    }
		    break;')

#  m4arith1(dataType)
m4define(`m4arith1', `m4dyad3($1, $1, $1, m4MissingValue($1))')

#  m4arith(name, intDefn, floatDefn, doubleDefn)
#  floatDefn  defaults to intDefn
#  doubleDefn defaults to intDefn
#  e.g. m4arith(`Rem', `Nap_mod($1,$2)', `Nap_fmod_f32($1, $2)', `Nap_fmod($1, $2)')
m4define(`m4arith', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = TRUE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_dataType        resultDataType;
    int			status;

    naoPtr1 = Nap_DyadArg(nap_cd, str1);
    CHECK1NULL(naoPtr1);
    naoPtr2 = Nap_DyadArg(nap_cd, str2);
    CHECK1NULL(naoPtr2);
    resultDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
	    resultHasMissingValue, &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (resultDataType) {
m4define(`m4op', `$2')
    m4ForAllIntegerDataType(`m4arith1(', `)')
m4define(`m4op', m4ifelse(`$3', `', `$2', `$3'))
    m4arith1(F32)
m4define(`m4op', m4ifelse(`$4', `', `$2', `$4'))
    m4arith1(F64)
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Tcl_SetResult(nap_cd->interp, naoResultPtr->id, TCL_VOLATILE);
    return naoResultPtr->id;
}
')

m4end

m4arith(`Add', `$1 + $2')
m4arith(`Sub', `$1 - $2')
m4arith(`Mul', `$1 * $2')
m4arith(`LesserOf', `Min($1, $2)')
m4arith(`GreaterOf', `Max($1, $2)')
m4arith(`Div', `$2?$1/$2:$3', `$1/$2', `$1/$2')
m4arith(`Rem', `Nap_mod($1,$2)', `Nap_fmod_f32($1, $2)', `Nap_fmod($1, $2)')

m4begin

#  m4real(name, defn)
#  e.g. m4real(`Power', `Pow($1, $2)')
m4define(`m4real', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = TRUE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_dataType        resultDataType;
    int			status;

    naoPtr1 = Nap_DyadArg(nap_cd, str1);
    CHECK1NULL(naoPtr1);
    naoPtr2 = Nap_DyadArg(nap_cd, str2);
    CHECK1NULL(naoPtr2);
    resultDataType = Max(naoPtr1->dataType, naoPtr2->dataType);
    resultDataType = Max(resultDataType, m4DataTypeEnum(m4MinRealDataType));
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
	    resultHasMissingValue, &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (resultDataType) {
m4define(`m4op', `$2')
    m4ForAllRealDataType(`m4arith1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Tcl_SetResult(nap_cd->interp, naoResultPtr->id, TCL_VOLATILE);
    return naoResultPtr->id;
}
')

m4end

m4real(`Power', `Pow($1, $2)')
m4real(`Atan2', `atan2($1, $2)')
m4real(`Hypot', `hypot($1, $2)')
m4real(`Log', `log($1) / log($2)')

m4begin

#  m4boolean2(leftDataType, rightDataType)
m4define(`m4boolean2',
	`m4dyad3(m4MinIntegerDataType, $1, $2, m4MissingValue(m4MinIntegerDataType))')

#  m4boolean1(leftDataType)
m4define(`m4boolean1', `
    case m4DataTypeEnum($1):
	switch (naoPtr2->dataType) {
	m4ForAllNumericDataType(`m4boolean2($1, ', `)')
	default:            /* error */
	    assert(FALSE);
	}
	break;')

#  m4boolean(name, defn)
m4define(`m4boolean', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = TRUE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    int			status;

    naoPtr1 = Nap_DyadArg(nap_cd, str1);
    CHECK1NULL(naoPtr1);
    naoPtr2 = Nap_DyadArg(nap_cd, str2);
    CHECK1NULL(naoPtr2);
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, naoPtr1->dataType, naoPtr2->dataType,
	    m4DataTypeEnum(m4MinIntegerDataType), resultHasMissingValue,
	    &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (naoPtr1->dataType) {
m4define(`m4op', `$2')
    m4ForAllNumericDataType(`m4boolean1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Tcl_SetResult(nap_cd->interp, naoResultPtr->id, TCL_VOLATILE);
    return naoResultPtr->id;
}
')

m4end

m4boolean(`And', `$1 && $2')
m4boolean(`Or',  `$1 || $2')

m4begin

m4define(`m4relational1', `m4dyad3(m4MinIntegerDataType, $1, $1, m4resultMV)')

#  m4relational(name, defn, resultMissingValue)
m4define(`m4relational', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    Nap_dataType	argDataType;
    const int		resultHasMissingValue = FALSE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    int			status;

    naoPtr1 = Nap_DyadArg(nap_cd, str1);
    CHECK1NULL(naoPtr1);
    naoPtr2 = Nap_DyadArg(nap_cd, str2);
    CHECK1NULL(naoPtr2);
    argDataType = Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType);
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, argDataType, argDataType,
	    m4DataTypeEnum(m4MinIntegerDataType), resultHasMissingValue,
	    &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (argDataType) {
m4define(`m4op', `$2')
m4define(`m4resultMV', `$3')
    m4ForAllUnboxedDataType(`m4relational1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Tcl_SetResult(nap_cd->interp, naoResultPtr->id, TCL_VOLATILE);
    return naoResultPtr->id;
}
')

m4end

m4relational(`Eq', `$1 == $2', 0)
m4relational(`Ne', `$1 != $2', 1)
m4relational(`Lt', `$1 <  $2', 0)
m4relational(`Le', `$1 <= $2', 0)
m4relational(`Gt', `$1 >  $2', 0)
m4relational(`Ge', `$1 >= $2', 0)

m4begin

#  m4bit(name, defn)
m4define(`m4bit', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = FALSE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_dataType        resultDataType;
    int			status;

    naoPtr1 = Nap_DyadArg(nap_cd, str1);
    CHECK1NULL(naoPtr1);
    naoPtr2 = Nap_DyadArg(nap_cd, str2);
    CHECK1NULL(naoPtr2);
    resultDataType = Min(NAP_U32, Nap_DataType2(naoPtr1->dataType, naoPtr2->dataType));
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, resultDataType, resultDataType, resultDataType,
	    resultHasMissingValue, &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (resultDataType) {
m4define(`m4op', `$2')
    m4ForAllIntegerDataType(`m4arith1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Tcl_SetResult(nap_cd->interp, naoResultPtr->id, TCL_VOLATILE);
    return naoResultPtr->id;
}
')

m4end

m4bit(`BitAnd', `$1 & $2')
m4bit(`BitOr',  `$1 | $2')
m4bit(`BitXor', `$1 ^ $2')

m4begin

#  m4shift2(leftDataType, rightDataType)
m4define(`m4shift2', `m4dyad3($1, $1, $2, m4MissingValue($1))')

#  m4shift1(leftDataType)
m4define(`m4shift1', `
	case m4DataTypeEnum($1):
	    switch (naoPtr2->dataType) {
	    m4ForAllIntegerDataType(`m4shift2($1, ', `)')
	    default:            /* error */
		assert(FALSE);
	    }
	    break;')

#  m4shift(name, defn)
m4define(`m4shift', `
EXTERN char *
Nap_$1(
    NapClientData	*nap_cd,
    char		*str1,			/* id of left arg (in) */
    char		*str2)			/* id of right arg (in) */
{
    const int		resultHasMissingValue = FALSE;
    size_t		i;
    size_t		i1;			/* subscript of left arg */
    size_t		i2;			/* subscript of right arg */
    Nap_NAO		*naoResultPtr;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    int			status;

    naoPtr1 = Nap_DyadArg(nap_cd, str1);
    CHECK1NULL(naoPtr1);
    naoPtr2 = Nap_DyadArg(nap_cd, str2);
    CHECK1NULL(naoPtr2);
    CHECK2NULL(Nap_TypeIsInteger(naoPtr1->dataType) && Nap_TypeIsInteger(naoPtr2->dataType), m4dnl
	    "Nap_$1: Shift operator has non-integer argument");
    status = Nap_DyadInit(nap_cd, naoPtr1, naoPtr2, naoPtr1->dataType, naoPtr2->dataType,
	    naoPtr1->dataType, resultHasMissingValue, &naoPtr1, &naoPtr2, &naoResultPtr);
    CHECK1NULL(status == TCL_OK);
    switch (naoResultPtr->dataType) {
m4define(`m4op', `$2')
    m4ForAllIntegerDataType(`m4shift1(', `)')
    default:            /* error */
	assert(FALSE);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Tcl_SetResult(nap_cd->interp, naoResultPtr->id, TCL_VOLATILE);
    return naoResultPtr->id;
}
')

m4end

m4shift(`ShiftLeft',  `$1 << $2')
m4shift(`ShiftRight', `$1 >> $2')


/*
 * Nap_AP_check --
 *
 *	Called by Nap_AP & Nap_AP_arg
 */

static int
Nap_AP_check(
    NapClientData	*nap_cd,
    Nap_NAO		*naoPtr,
    char		*name)		/* name of arg for messages */
{
    CHECK3(naoPtr , "m4NAME: Operand '%s' is bad", name);
    CHECK3(Nap_TypeIsNumeric(naoPtr->dataType), "m4NAME: Operand '%s' is not numeric", name);
    CHECK3(naoPtr->rank == 0, "m4NAME: Operand '%s' is not scalar", name);
    CHECK3(!IsMissing(naoPtr, 0), "m4NAME: Operand '%s' == missing value", name);
    return TCL_OK;
}

/*
 * Nap_AP_arg --
 *
 *	Called by Nap_AP
 */

static Nap_NAO *
Nap_AP_arg(
    NapClientData	*nap_cd,
    Nap_NAO		*naoPtr,
    int			i,		/* index of this arg within naoPtr */
    char		*name)		/* name of arg for messages */
{
    Nap_NAO		*result;
    int			status;

    if (i < naoPtr->nels) {
	result = Nap_GetNaoFromSlot(naoPtr->data.Boxed[i]);
	status = Nap_AP_check(nap_cd, result, name);
	Nap_IncrRefCount(nap_cd, result);
	if (status != TCL_OK) {
	    Nap_DecrRefCount(nap_cd, result);
	    CHECK1NULL(FALSE);
	}
    } else {
	result = NULL;
    }
    return result;
}

/*
 * Nap_AP --
 *      Generate arithmetic progression -- operator '..'
 *
 *	Either operand can be boxed, but not both
 *	If left  argument is unboxed it represents 'from' value
 *	If right argument is unboxed it represents 'to' value
 *	If left  argument is unboxed it represents values: (n , from)
 *		where n is # elements in result
 *	If right argument is unboxed it represents values: (to , step [, tolerance])
 *		where tolerance (default 1e-9) is used to define n=floor((to-from)/step+tolerance)
 */

m4begin

# m4generateAP(type)  -- with specified step
m4define(`m4generateAP', `
            case m4DataTypeEnum($1):
                for (i = 0; i < n; i++) {
                    result->data.$1[i] = naoFrom->data.$1[0] + i * step;
                }
                break;')

# m4generateAP1(type,sign)  -- with step of -1 or +1
m4define(`m4generateAP1', `
            case m4DataTypeEnum($1):
                for (i = 0; i < n; i++) {
                    result->data.$1[i] = naoFrom->data.$1[0] $2 i;
                }
                break;')

# m4appendAP(type)
m4define(`m4appendAP', `
            case m4DataTypeEnum($1):
		result->data.$1[n] = to;
                break;')

m4define(`m4NAME', `Nap_AP')

m4end

EXTERN char *
Nap_AP(
    NapClientData	*nap_cd,
    char		*str1,		/* 'from' value */
    char		*str2)		/* either 'to' value or 'to,step' (boxed) */
{
    Nap_dataType	dataType;
    int                 extra;		/* 1 if need extra element at end, else 0 */
    double              from;		/* initial value of A.P. */
    size_t		i;
    int                 n;		/* integer number of elements in A.P. */
    					/*(excludes any extra element at end) */
    double              nn;		/* floating point number of elements in A.P. */
    Nap_NAO		*naoFrom = NULL;
    Nap_NAO		*naoN = NULL;
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoStep = NULL;
    Nap_NAO		*naoTol = NULL;
    Nap_NAO		*naoTo = NULL;
    Nap_NAO		*result;
    size_t		shape[1];
    int			status;
    double              step;           /* A.P. increment */
    double              to;		/* final value of A.P. */
    double              tol = 1.0e-9;	/* tolerance (see above) */
    Nap_NAO		*tmp;

    CHECK2NULL(str1, "m4NAME: Left argument of .. is NULL");
    naoPtr1 = Nap_GetNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Bad left argument of ..");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    if (naoPtr1->dataType == NAP_BOXED) {
	CHECK2NULL(naoPtr1->rank == 1, "m4NAME: Left boxed argument of .. is not vector");
	CHECK2NULL(naoPtr1->nels == 2, "m4NAME: Left boxed argument of .. does not have shape {2}");
	naoN    = Nap_AP_arg(nap_cd, naoPtr1, 0, "n");
	CHECK1NULL(naoN);
	naoFrom = Nap_AP_arg(nap_cd, naoPtr1, 1, "from");
	CHECK1NULL(naoFrom);
    } else {
	naoFrom = naoPtr1;
	status = Nap_AP_check(nap_cd, naoFrom, "from");
	Nap_IncrRefCount(nap_cd, naoFrom);
	if (status != TCL_OK) {
	    Nap_DecrRefCount(nap_cd, naoFrom);
	    CHECK1NULL(FALSE);
	}
    }
    CHECK2NULL(str2, "m4NAME: Right argument of .. is NULL");
    naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
    CHECK2NULL(naoPtr2, "m4NAME: Bad right argument of ..");
    Nap_IncrRefCount(nap_cd, naoPtr2);
    if (naoPtr2->dataType == NAP_BOXED) {
	CHECK2NULL(naoPtr2->rank == 1, "m4NAME: Right boxed argument of .. is not vector");
	CHECK2NULL(naoPtr2->nels == 2 || naoPtr2->nels == 3,
		"m4NAME: Right boxed argument of .. does not have shape {2} or {3}");
	naoTo   = Nap_AP_arg(nap_cd, naoPtr2, 0, "to");
	CHECK1NULL(naoTo);
	naoStep = Nap_AP_arg(nap_cd, naoPtr2, 1, "step");
	CHECK1NULL(naoStep);
	if (naoPtr2->nels == 3) {
	    naoTol  = Nap_AP_arg(nap_cd, naoPtr2, 2, "tolerance");
	    CHECK1NULL(naoTol);
	}
    } else {
	naoTo = naoPtr2;
	status = Nap_AP_check(nap_cd, naoTo, "to");
	Nap_IncrRefCount(nap_cd, naoTo);
	if (status != TCL_OK) {
	    Nap_DecrRefCount(nap_cd, naoTo);
	    CHECK1NULL(FALSE);
	}
    }
    assert(naoFrom);
    CHECK2NULL(!naoN || !naoStep, "m4NAME: Both 'n' and 'step' specified");
    status = Nap_F64ScalarValue(nap_cd, naoFrom, &from);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
    assert(naoTo);
    status = Nap_F64ScalarValue(nap_cd, naoTo, &to);
    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
    dataType = Nap_DataType2(naoFrom->dataType, naoTo->dataType);
    if (from == to) {
	step = 1.0;
	nn = 1.0;
    } else if (naoN) {
	status = Nap_F64ScalarValue(nap_cd, naoN, &nn);
	CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
	nn = Max(0.0, nn);
	step = nn == 1.0 ? 1.0 : (to - from) / (nn - 1.0);
    } else {
	if (naoStep) {
	    status = Nap_F64ScalarValue(nap_cd, naoStep, &step);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
	    if (naoTol) {
		status = Nap_F64ScalarValue(nap_cd, naoTol, &tol);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
	    }
	} else {
	    step = Sign(to - from);
	}
	nn = step ? 1.0 + (to - from) / step : 0.0;
    }
    nn = Max(0.0, floor(nn+tol) > floor(nn) ? ceil(nn) : nn);
    n = nn;
    if (step != floor(step)) {
	dataType = Nap_DataType2(dataType, NAP_F32);
    }
    tmp = naoFrom;
    naoFrom = Nap_CastNAO(nap_cd, tmp, dataType);
    Nap_IncrRefCount(nap_cd, naoFrom);
    Nap_DecrRefCount(nap_cd, tmp);
    tmp = naoTo;
    naoTo = Nap_CastNAO(nap_cd, tmp, dataType);
    Nap_IncrRefCount(nap_cd, naoTo);
    Nap_DecrRefCount(nap_cd, tmp);
    extra = nn > n+tol;
    shape[0] = n + extra;
    result = Nap_NewNAO(nap_cd, dataType, 1, shape);
    if (n > 0) {
	if (step == 1.0) {
	    switch (dataType) {
		m4ForAllNumericDataType(`m4generateAP1(', `,+)')
		default:                /* error */
		    return NULL;
	    }
	} else if (step == -1.0) {
	    switch (dataType) {
		m4ForAllNumericDataType(`m4generateAP1(', `,-)')
		default:                /* error */
		    return NULL;
	    }
	} else {
	    switch (dataType) {
		m4ForAllNumericDataType(`m4generateAP(', `)')
		default:                /* error */
		    return NULL;
	    }
	}
    }
    if (extra) {
	switch (dataType) {
	    m4ForAllNumericDataType(`m4appendAP(', `)')
	    default:                /* error */
		return NULL;
	}
    }
    Nap_DecrRefCount(nap_cd, naoN);
    Nap_DecrRefCount(nap_cd, naoFrom);
    Nap_DecrRefCount(nap_cd, naoTo);
    Nap_DecrRefCount(nap_cd, naoStep);
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    result->step = NAP_EQUAL;
    return result->id;
}


/*
 *  Nap_CV --
 *	nap function "coordinate_variable(x ?, dimnum?)"
 *	Result is coordinate-variable of dimension dimnum of x.
 *	dimnum taken mod rank.
 *	dimnum defaults to 0.
 *	dimnum can be name of dimension as C8 NAO e.g. coordinate_variable(m, 'latitude')
 */

m4define(`m4NAME', `Nap_CV')

static char *
Nap_CV(
    NapClientData       *nap_cd,
    char		*str1,
    char		*str2)
{
    int			i;
    size_t		shape[NAP_MAX_RANK];
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoPtr3;
    Nap_NAO		*new;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Illegal x in 'coordinate_variable(x ?,dimnum?)'");
    CHECK2NULL(naoPtr1->rank > 0, "m4NAME: scalar x in 'coordinate_variable(x ?,dimnum?)'");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    if (str2) {
	naoPtr2 = Nap_GetNaoFromId(nap_cd, str2);
	Nap_IncrRefCount(nap_cd, naoPtr2);
	if (naoPtr2->dataType == NAP_C8) {
	    i = Nap_StrToDimNum(nap_cd, naoPtr1, naoPtr2->data.c);
	} else {
	    CHECK2NULL(naoPtr2->rank == 0, "m4NAME: Non-scalar i in coordinate_variable(v,i)");
	    naoPtr3 = Nap_CastNAO(nap_cd, naoPtr2, NAP_I32);
	    Nap_IncrRefCount(nap_cd, naoPtr3);
	    i = Nap_mod(naoPtr3->data.I32[0], naoPtr1->rank);
	    Nap_DecrRefCount(nap_cd, naoPtr3);
	}
	Nap_DecrRefCount(nap_cd, naoPtr2);
    } else {
	i = 0;
    }
    new = Nap_GetCoordVar(nap_cd, naoPtr1, i);
    if (!new) {
	shape[0] = naoPtr1->shape[i];
	new = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	CHECK2NULL(new, "error calling Nap_NewNAO");
	for (i = 0; i < shape[0]; i++) {
	    new->data.I32[i] = i;
	}
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    return new ? new->id : NULL;
}


/*
 *  Nap_SolveLinear --
 *	nap function "solve_linear(A, B)"
 *	This solves system of linear equations defined by matrix A &
 *	right-hand-sides B (vector or matrix)
 */

m4begin

# m4_solve_linear(dataType)

m4define(`m4_solve_linear', `
	    case m4DataTypeEnum($1):
		{
		    m4DataTypeName($1) **a;	/* pointers to rows of left hand side */
		    m4DataTypeName($1) **b;	/* pointers to rows of right hand side */
		    a = (m4DataTypeName($1) **) MALLOC(n * sizeof(m4DataTypeName($1) *));
		    CHECK2NULL(a, "m4NAME: Unable to allocate memory");
		    b = (m4DataTypeName($1) **) MALLOC(n * sizeof(m4DataTypeName($1) *));
		    CHECK2NULL(b, "m4NAME: Unable to allocate memory");
		    for (i = 0; i < n; ++i) {
			a[i] = naoA->data.$1 + i * n;
			b[i] = naoB->data.$1 + i * m;
			if (!naoPtr2) {	/* set B to default (identity matrix) */
			    for (j = 0; j < n; ++j) {
				b[i][j] = i == j;
			    }
			}
		    }
		    status = linsys_$1(nap_cd, n, m, a, b);
		    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling linsys_$1");
		    FREE(a);
		    FREE(b);
		}
		break;')

m4define(`m4NAME', `Nap_SolveLinear')

m4end

static char *
Nap_SolveLinear(
    NapClientData       *nap_cd,
    char		*str1,
    char		*str2)
{
    Nap_dataType        dataType;
    int			i;		/* subscript */
    int			j;		/* subscript */
    int			m;		/* # columns in RHS b */
    int			n;		/* # rows (equations) */
    Nap_NAO		*naoA;		/* main matrix (LHS) */
    Nap_NAO		*naoB;		/* RHS & result */
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*oldA;		/* old naoA*/
    Nap_NAO		*oldB;		/* old naoB*/
    int			status;
    char		*str;
    Nap_NAO		*transposeA;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Illegal arg1 in solve_linear");
    CHECK2NULL(naoPtr1->rank == 2, "m4NAME: arg1 has rank other than 2");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    dataType = Nap_DataType2(naoPtr1->dataType, NAP_F32);
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    if (naoPtr2) {
	CHECK2NULL(naoPtr2->rank == 1  ||  naoPtr2->rank == 2,
		"m4NAME: arg2 has rank other than 1 or 2");
	Nap_IncrRefCount(nap_cd, naoPtr2);
	dataType = Nap_DataType2(dataType, naoPtr2->dataType);
    }
    naoA = Nap_CastNAO(nap_cd, naoPtr1, dataType);
    CHECK2NULL(naoA, "m4NAME: Error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, naoA);
    if (naoPtr2) {
	naoB = Nap_CastNAO(nap_cd, naoPtr2, dataType);
	CHECK2NULL(naoB, "m4NAME: Error calling Nap_CastNAO");
    } else {
	naoB = Nap_NewNAO(nap_cd, dataType, 2, naoA->shape);
	CHECK2NULL(naoB, "m4NAME: Error calling Nap_NewNAO");
    }
    Nap_IncrRefCount(nap_cd, naoB);
    CHECK2NULL(naoB->shape[0] == naoA->shape[0],
	    "m4NAME: # rows in arg1 differs from # rows in arg2");
    if (naoPtr1->shape[0] > naoPtr1->shape[1]) {	/* overdetermined, so least-squares soln */
	oldA = naoA;
	oldB = naoB;
	str = Nap_Func(nap_cd, "transpose", oldA->id);
	CHECK1NULL(str);
	transposeA = Nap_GetNaoFromId(nap_cd, str);
	Nap_IncrRefCount(nap_cd, transposeA);
	str = Nap_InnerProd(nap_cd, transposeA->id, oldA->id);
	CHECK1NULL(str);
	naoA = Nap_GetNaoFromId(nap_cd, str);
	Nap_IncrRefCount(nap_cd, naoA);
	str = Nap_InnerProd(nap_cd, transposeA->id, oldB->id);
	CHECK1NULL(str);
	naoB = Nap_GetNaoFromId(nap_cd, str);
	Nap_IncrRefCount(nap_cd, naoB);
	Nap_DecrRefCount(nap_cd, transposeA);
	Nap_DecrRefCount(nap_cd, oldA);
	Nap_DecrRefCount(nap_cd, oldB);
    }
    n = (int) naoA->shape[0];
    m = (int) (naoB->rank == 2 ? naoB->shape[1] : 1);
    CHECK2NULL(naoPtr1->shape[0] >= naoPtr1->shape[1], "m4NAME: more unknowns than equations");
    switch (dataType) {
	m4ForAllRealDataType(`m4_solve_linear(', `)')
	default: assert(0);
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Nap_DecrRefCount(nap_cd, naoA);
    --naoB->count;
    return naoB->id;
}


/*
 *  Nap_Reshape --
 *	nap function "reshape(x,shape)"
 *	This creates array with specified shape, taking data type & values from x
 *	(recycling if necessary).  If shape not specified then produce vector
 *	with same number of elements as x.
 */

m4define(`m4NAME', `Nap_Reshape')

static char *
Nap_Reshape(
    NapClientData       *nap_cd,
    char		*str1,
    char		*str2)
{
    int			i;
    size_t		shape[NAP_MAX_RANK];
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*naoPtr3;
    Nap_NAO		*new;

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Illegal x in 'reshape(x ?,shape?)'");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    if (naoPtr2) {
	CHECK2NULL(naoPtr2->rank <= 1, 
	    "m4NAME: shape argument not scalar or vector in reshape(array,shape)");
	CHECK4NULL(naoPtr2->nels <= NAP_MAX_RANK, 
	    "m4NAME: shape argument in reshape(array,shape) specifies rank = %d "
	    "which exceeds max. of %d", naoPtr2->nels, NAP_MAX_RANK);
	Nap_IncrRefCount(nap_cd, naoPtr2);
	shape[0] = naoPtr2->nels;
	naoPtr3 = Nap_ReshapeNAO(nap_cd, naoPtr2, NAP_I32, 1, shape);
	Nap_IncrRefCount(nap_cd, naoPtr3);
	for (i = 0; i < naoPtr3->nels; i++) {
	    shape[i] = naoPtr3->data.I32[i];
	}
	new = Nap_ReshapeNAO2(nap_cd, naoPtr1, naoPtr1->dataType, naoPtr3->nels, shape, 1, 0);
	Nap_IncrRefCount(nap_cd, new);
	Nap_DecrRefCount(nap_cd, naoPtr3);
	CHECK2NULL(new, "m4NAME: error calling Nap_ReshapeNAO2");
	Nap_DecrRefCount(nap_cd, naoPtr2);
    } else {
	shape[0] = naoPtr1->nels;
	new = Nap_ReshapeNAO2(nap_cd, naoPtr1, naoPtr1->dataType, 1, shape, 1, 0);
	Nap_IncrRefCount(nap_cd, new);
	CHECK2NULL(new, "m4NAME: error calling Nap_ReshapeNAO2");
    }
    Nap_DecrRefCount(nap_cd, naoPtr1);
    --new->count;
    return new ? new->id : NULL;
}

/*
 *  mixedBase --
 *	Convert an ordinary number to a mixed base number.
 *
 *  Returns 0 if OK, 1 for error.
 *
 *  Example: Following converts 65 inches to 1 yard, 2 feet and 5 inches.
 *	long        base[] = {3, 12};
 *	long        result[3];
 *	int         status;
 *	status = mixedBase(65, 2, base, result);
 *  This sets result[0] to 1, result[1] to 2, result[2] to 5.
 */

EXTERN int
mixedBase(
    long	n,		/* number to be converted to mixed base */
    size_t	nbases,		/* number of elements in base */
    long	base[],		/* base vector */
    long	result[])	/* mixed-base result (nbases+1 elements) */
{
    ldiv_t	d;
    size_t	i;

    result[nbases] = n;
    if (nbases > 0) {
	for (i = nbases; i > 0; i--) {
	    if (base[i-1] > 0) {
		d = ldiv(result[i], base[i-1]);
		result[i]   = d.rem;
		result[i-1] = d.quot;
	    } else {
		return 1;
	    }
	}
    }
    return 0;
}

/*
 *  Nap_Transpose --
 *	nap function "transpose(a ?,order?)"
 *	2nd argument specifies new order of old dimensions. If type C8 then either dim. names or
 *	int values.
 *	If only 1 arg then dimension order is reversed.
 */

m4define(`m4NAME', `Nap_Transpose')

static char *
Nap_Transpose(
    NapClientData       *nap_cd,
    char		*str1,
    char		*str2)
{
    int			found;			/* Has match been found? */
    size_t		i;
    long		indexOld[NAP_MAX_RANK];
    Tcl_Interp		*interp = nap_cd->interp;
    int			j;
    size_t		k;
    Tcl_Obj		*listPtr;		/* list defined by type C8 order arg */
    int			n;			/* # elements in order arg */
    Nap_NAO		*naoArray;		/* array to be transposed */
    Nap_NAO		*naoOrder;		/* new order of dimensions */
    Nap_NAO		*naoResult;
    Nap_NAO		*naoTmp;
    Tcl_Obj		*objPtr;		/* element of list listPtr */
    int			order[NAP_MAX_RANK];
    int			rank;			/* of naoArray & naoResult */
    size_t		shape[NAP_MAX_RANK];
    long		shapeLong[NAP_MAX_RANK];
    int			status;

    naoArray = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoArray, "m4NAME: Illegal x in 'transpose(a ?,order?)'");
    Nap_IncrRefCount(nap_cd, naoArray);
    naoOrder = Nap_GetNumericNaoFromId(nap_cd, str2);
    rank = naoArray->rank;
    if (naoOrder) {
	Nap_IncrRefCount(nap_cd, naoOrder);
	if (naoOrder->dataType == NAP_C8) {
	    listPtr = Tcl_NewStringObj(naoOrder->data.c, naoOrder->nels);
	    Tcl_IncrRefCount(listPtr);
	    status = Tcl_ListObjLength(interp, listPtr, &n);
	    CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Tcl_ListObjLength");
	    for (i = 0; i < n; i++) {
		status = Tcl_ListObjIndex(interp, listPtr, i, &objPtr);
		CHECK2NULL(status == TCL_OK, "m4NAME: Error calling Tcl_ListObjIndex");
		Tcl_IncrRefCount(objPtr);
		order[i] = Nap_StrToDimNum(nap_cd, naoArray, Tcl_GetString(objPtr));
		CHECK2NULL(order[i] >= 0, "m4NAME: illegal dimension name/number");
		Tcl_DecrRefCount(objPtr);
	    }
	    Tcl_DecrRefCount(listPtr);
	} else {
	    naoTmp = Nap_CastNAO(nap_cd, naoOrder, NAP_I16);
	    Nap_IncrRefCount(nap_cd, naoTmp);
	    n = naoTmp->nels;
	    for (i = 0; i < n; i++) {
		order[i] = naoTmp->data.I16[i];
	    }
	    Nap_DecrRefCount(nap_cd, naoTmp);
	}
	Nap_DecrRefCount(nap_cd, naoOrder);
	for (i = n; i < rank; i++) {
	    for (j = 0; j < rank; j++) {
		found = FALSE;
		for (k = 0; k < i; k++) {
		    found = found || j == order[k];
		}
		if (!found) {
		    order[i] = j;
		    break;
		}
	    }
	}
    } else {
	for (i = 0; i < rank; i++) {
	    order[i] = rank - i - 1;
	}
    }
    for (i = 0; i < rank; i++) {
	order[i] = Nap_mod(order[i], rank);
	shapeLong[i] = naoArray->shape[i];
	shape[i] = naoArray->shape[order[i]];
    }
    naoResult = Nap_NewNAO(nap_cd, naoArray->dataType, rank, shape);
    Nap_IncrRefCount(nap_cd, naoResult);
    for (i = 0; i < rank; i++) {
	j = order[i];
	naoTmp = Nap_GetNaoFromSlot(naoArray->coordVarSlot[j]);
	Nap_IncrRefCount(nap_cd, naoTmp);
	status = Nap_AttachCoordVar(nap_cd, naoResult, naoTmp, naoArray->dimName[j], i);
	Nap_DecrRefCount(nap_cd, naoTmp);
    }
    for (i = 0; i < rank-1; i++) {
	shape[i] = shape[i+1];
    }
    shape[rank-1] = Nap_SizeOf(naoArray->dataType);
    for (i = 0; i < naoArray->nels; i++) {
	status = mixedBase(i, rank-1, shapeLong+1, indexOld);
	CHECK2NULL(status == 0, "m4NAME: Dimension has size 0");
	k = 0;
	for (j = 0; j < rank; j++) {
	    k = (k + indexOld[order[j]]) * shape[j];
	}
	memcpy(naoResult->data.c + k, naoArray->data.c + i * shape[rank-1], shape[rank-1]);
    }
    Nap_DecrRefCount(nap_cd, naoArray);
    --naoResult->count;
    return naoResult->id;
}

/*
 *  Nap_Func2 --
 *	Handler for functions with 2 arguments.
 */

m4define(`m4NAME', `Nap_Func2')

EXTERN char *
Nap_Func2(
    NapClientData	*nap_cd,
    char		*name,			/* name of function */
    char		*str1,			/* id of argument 1 */
    char		*str2)			/* id of argument 2 */
{
    Nap_NAO		*naoPtr1;
    Nap_NAO		*naoPtr2;
    Nap_NAO		*new;

    if (!name) {
	assert(FALSE);
    } else if (strcmp(name, "atan2") == 0) {
	return Nap_Atan2(nap_cd, str1, str2);
    } else if (strcmp(name, "atan") == 0) {
	return Nap_Atan2(nap_cd, str1, str2);
    } else if (strcmp(name, "coordinate_variable") == 0) {
	return Nap_CV(nap_cd, str1, str2);
    } else if (strcmp(name, "hypot") == 0) {
	return Nap_Hypot(nap_cd, str1, str2);
    } else if (strcmp(name, "fmod") == 0) {
	return Nap_Rem(nap_cd, str1, str2);
    } else if (strcmp(name, "log") == 0) {
	return Nap_Log(nap_cd, str1, str2);
    } else if (strcmp(name, "pow") == 0) {
	return Nap_Power(nap_cd, str1, str2);
    } else if (strcmp(name, "reshape") == 0) {
	return Nap_Reshape(nap_cd, str1, str2);
    } else if (strcmp(name, "solve_linear") == 0) {
	return Nap_SolveLinear(nap_cd, str1, str2);
    } else if (strcmp(name, "transpose") == 0) {
	return Nap_Transpose(nap_cd, str1, str2);
    }
    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    naoPtr2 = Nap_GetNumericNaoFromId(nap_cd, str2);
    Nap_IncrRefCount(nap_cd, naoPtr1);
    Nap_IncrRefCount(nap_cd, naoPtr2);
    new = Nap_Reduce(nap_cd, name, naoPtr1, naoPtr2);
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    return new ? new->id : NULL;
}
