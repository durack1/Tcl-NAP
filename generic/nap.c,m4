m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (nap.c). It was produced from source file nap.c,m4 */

/*
 *	nap.c,m4 --
 *
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: nap.c,m4,v 1.213 2004/04/27 04:28:47 dav480 Exp $";
#endif /* not lint */

#include <time.h>

#include "nap.h"
#include "nap_check.h"
#include "napInt.h"


/*
 * Nap_Cmd --
 *
 *  Process 'nap' command.
 *
 *  Concatenate arguments with ' ' separator.  Prefix result with '\n' which is
 *  needed for error handling.
 *  Substitute for any '$VAR' or '[SCRIPT]' not already substituted by tcl.
 *  Call parser generated by bison (yacc dialect).
 *
 *  Prevent auto-exec by ensuring tcl var. 'auto_noexec' is defined.
 *  Otherwise tcl would attempt to exec programs with same name as function.
 *  If 'auto_noexec' originally undefined, then unset at end.
 */

m4define(`m4NAME', `Nap_Cmd')

EXTERN int
Nap_Cmd(
    ClientData		clientData,
    Tcl_Interp		*interp,
    int			objc,
    Tcl_Obj *CONST	objv[])
{
    NapClientData	*nap_cd = (NapClientData *) clientData;
    Tcl_Obj		*obj_auto_noexec;	/* var auto_noexec */
    Tcl_Obj		*obj_str_auto_noexec;	/* string "auto_noexec" */
    Tcl_Obj		*objArgs;
    Tcl_Obj		*objNapCommand;
    Tcl_Obj		*objResult;		/* result of nap command */
    Tcl_Obj		*objTmp;
    int			rl;			/* new NAP recursion limit = Tcl recursion limit */
    char		*str;
    int			status;			/* return code */

    rl = Tcl_SetRecursionLimit(interp, 0);
    assert(nap_cd->parseLevel >= -1);
    if (nap_cd->recursionLimit == 0) {
	nap_cd->scanString    = (char **)  MALLOC(rl * sizeof(char **));
	nap_cd->commandLength = (size_t *) MALLOC(rl * sizeof(size_t *));
	nap_cd->recursionLimit = rl;
    } else if (nap_cd->recursionLimit < rl) {
	nap_cd->scanString    = (char **)  REALLOC(nap_cd->scanString,    rl * sizeof(char **));
	nap_cd->commandLength = (size_t *) REALLOC(nap_cd->commandLength, rl * sizeof(size_t *));
	nap_cd->recursionLimit = rl;
    }
    CHECK2(nap_cd->parseLevel < nap_cd->recursionLimit, "m4NAME: Too many recursion levels");
    ++nap_cd->parseLevel;
    if (nap_cd->parseLevel == 0) {
	nap_cd->message[0] = '\0';
    }
    objArgs = Tcl_ConcatObj(objc-1, objv+1);
    assert(objArgs);
    Tcl_IncrRefCount(objArgs);
    objNapCommand = Tcl_NewStringObj("\n", -1);
    assert(objNapCommand);
    Tcl_IncrRefCount(objNapCommand);
    Tcl_AppendObjToObj(objNapCommand, objArgs);
    Tcl_DecrRefCount(objArgs);
    str = Tcl_GetStringFromObj(objNapCommand, NULL);
    assert(str);
    nap_cd->commandLength[nap_cd->parseLevel] = strlen(str);
    str = Nap_StrCat(str, " ", str, NULL); /* 2nd copy for lex tokens */
    assert(str);
    str[nap_cd->commandLength[nap_cd->parseLevel]] = '\0';
    Tcl_DecrRefCount(objNapCommand);
    nap_cd->scanString[nap_cd->parseLevel] = str + 1; /* skip '\n' at start */
    obj_str_auto_noexec = Tcl_NewStringObj("auto_noexec", -1);
    assert(obj_str_auto_noexec);
    Tcl_IncrRefCount(obj_str_auto_noexec);
    obj_auto_noexec = Tcl_ObjGetVar2(interp, obj_str_auto_noexec, NULL, 0);
    if (!obj_auto_noexec) {
	objTmp = Tcl_ObjSetVar2(interp, obj_str_auto_noexec, NULL,
		Tcl_NewBooleanObj(1), 0);
	assert(objTmp);
    }
    status = Nap_parse(nap_cd);
    objResult = Tcl_GetObjResult(interp);
    assert(objResult);
    Tcl_IncrRefCount(objResult);
    if (!obj_auto_noexec) {
	status = Tcl_UnsetVar(interp, "auto_noexec", 0);
	assert(status == TCL_OK);
    }
    Tcl_DecrRefCount(obj_str_auto_noexec);
    --nap_cd->parseLevel;
    if (nap_cd->message[0] || status) {
	Tcl_SetResult(interp, nap_cd->message, TCL_STATIC);
	status = TCL_ERROR;
    } else {
	Tcl_SetObjResult(interp, objResult);
	status = TCL_OK;
    }
    FREE(str);
    Tcl_DecrRefCount(objResult);
    return status;
}

/*
 *  Nap_InfoCmd --
 *
 *  nap_info command.
 *
 *  Usage:
 *	nap_info bytes
 *	    Return following two values:
 *		(a) current number of bytes allocated to NAOs
 *		(b) maximum (so far) number of bytes allocated to NAOs
 *
 *	nap_info seconds
 *	    Return processor (CPU) time in seconds used by tcl since it commenced execution.
 *	    The value is that provided by the standard C function clock().
 *	    The resolution is 1 tick (typically about 0.02 second).
 *
 *	nap_info sequence
 *	    Return sequence number of most recently created NAO.
 */

m4define(`m4NAME', `Nap_InfoCmd')

EXTERN int
Nap_InfoCmd(
    ClientData		clientData,
    Tcl_Interp		*interp,
    int			objc,
    Tcl_Obj		*CONST objv[])
{
    int			index;
    NapClientData	*nap_cd = (NapClientData *) clientData;
    double		seconds;		/* clock value */
    int			status;
    CONST char		*str;
    char		tmp_str[32];		/* temp. string */

    CONST char		*subCommands[] = {
				"bytes",
				"seconds",
				"sequence",
				(char *) NULL};

    nap_cd->message[0] = '\0';
    CHECK_NUM_ARGS(objc == 2, 1, "bytes|seconds|sequence");
    status = Tcl_GetIndexFromObj(interp, objv[1], subCommands, "sub-command", 0, &index);
    if (status != TCL_OK) {
	str = Tcl_GetStringResult(interp);
	CHECK3(FALSE, "m4NAME %s", str);
    }
    switch (index) {
    case 0: /* bytes */
	sprintf(tmp_str, "%u %u",
		(unsigned int) nap_cd->totalBytesNAO,
		(unsigned int) nap_cd->maxTotalBytesNAO);
	break;
    case 1: /* seconds */
	seconds = (double) clock() / (double) CLOCKS_PER_SEC;
	sprintf(tmp_str, "%g", seconds);
	break;
    case 2: /* sequence */
	sprintf(tmp_str, "%u", (unsigned int) nap_cd->seqNum);
	break;
    default:
	assert(0);
    }
    Tcl_SetResult(interp, tmp_str, TCL_VOLATILE);
    return TCL_OK;
}

/*
 * Nap_CreateStandardMissingValues --
 *	For every data type create new scalar NAO with standard missing value
 *	for that type.
 */

m4begin

m4define(`m4NAME', `Nap_CreateStandardMissingValues')

#	m4createMissingValues(DataType)	 e.g. m4createMissingValues(I16)
m4define(`m4createMissingValues', `
	naoPtr = Nap_NewScalarNAO(nap_cd, m4DataTypeEnum($1), m4DataTypeMissingValue($1));
	naoPtr->mortal = FALSE;
	Nap_IncrRefCount(nap_cd, naoPtr);
	assert(Nap_IsNAO(nap_cd, naoPtr));
	str = Nap_Assign(nap_cd, "::NAP::standard`$1'MissingValue", naoPtr->id);
	assert(str);
	nap_cd->`$1'MissingValueNao = naoPtr;')

m4end

EXTERN void
Nap_CreateStandardMissingValues(
    NapClientData	*nap_cd)
{
    Nap_NAO		*naoPtr;
    char		*str;

    m4ForAllDataType(`m4createMissingValues(', `)')
    naoPtr = Nap_NewScalarNAO(nap_cd, NAP_I32, 0);
    assert(naoPtr);
    nap_cd->RaggedMissingValueNao->raggedStartSlot = naoPtr->slot;
    Nap_IncrRefCount(nap_cd, naoPtr);
}
