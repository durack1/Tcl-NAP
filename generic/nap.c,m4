m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (nap.c). It was produced from source file nap.c,m4 */

/*
 *	nap.c,m4 --
 *
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: nap.c,m4,v 1.223 2006/09/29 12:38:29 dav480 Exp $";
#endif /* not lint */

#include <time.h>

#include "nap.h"
#include "nap_check.h"
#include "napInt.h"


/*
 * Nap_expression --
 *
 *  Process 'nap' expression.
 *  Return OOC-name (ID) of resultant NAO. Also set Tcl result to this value.
 *
 *  Prefix args with '\n' which is needed for error handling.
 *  Substitute for any '$VAR' or '[SCRIPT]' not already substituted by tcl.
 *  Call parser generated by bison (yacc dialect).
 *
 *  Prevent auto-exec by ensuring tcl var. 'auto_noexec' is defined.
 *  Otherwise tcl would attempt to exec programs with same name as function.
 *  If 'auto_noexec' originally undefined, then unset at end.
 */

m4define(`m4NAME', `Nap_expression')

EXTERN char *
Nap_expression(
    NapClientData	*nap_cd,
    Tcl_Obj		*obj_expr,		/* expression (string) */
    Nap_NAO		*indexBaseCV)		/* Specify if expression is index, else NULL */
{
    Tcl_Obj		*obj_auto_noexec;	/* var auto_noexec */
    Tcl_Obj		*obj_str_auto_noexec;	/* string "auto_noexec" */
    Tcl_Obj		*objNapCommand;
    Tcl_Obj		*objTmp;
    int			rl;			/* new NAP recursion limit = Tcl recursion limit */
    char		*result;		/* OOC-name (ID) of resultant NAO */
    char		*str;
    int			status;			/* return code */

    rl = Tcl_SetRecursionLimit(nap_cd->interp, 0);
    assert(nap_cd->parseLevel >= -1);
    if (nap_cd->recursionLimit == 0) {
	nap_cd->scanString    = (char **)    NAP_ALLOC(nap_cd, rl * sizeof(char **));
	nap_cd->token	      = (char **)    NAP_ALLOC(nap_cd, rl * sizeof(char **));
	nap_cd->commandLength = (size_t *)   NAP_ALLOC(nap_cd, rl * sizeof(size_t *));
	nap_cd->indexBaseCV   = (Nap_NAO **) NAP_ALLOC(nap_cd, rl * sizeof(Nap_NAO **));
	nap_cd->indexDimNum   = (int *)      NAP_ALLOC(nap_cd, rl * sizeof(int *));
	nap_cd->braceLevel    = (int *)      NAP_ALLOC(nap_cd, rl * sizeof(int *));
    } else if (nap_cd->recursionLimit < rl) {
	nap_cd->scanString = (char **) NAP_REALLOC(nap_cd, nap_cd->scanString, rl * sizeof(char **));
	nap_cd->token = (char **) NAP_REALLOC(nap_cd, nap_cd->token, rl * sizeof(char **));
	nap_cd->commandLength =
		(size_t *) NAP_REALLOC(nap_cd, nap_cd->commandLength,rl * sizeof(size_t *));
	nap_cd->indexBaseCV =
		(Nap_NAO **) NAP_REALLOC(nap_cd, nap_cd->indexBaseCV, rl * sizeof(Nap_NAO **));
	nap_cd->indexDimNum = (int *) NAP_REALLOC(nap_cd, nap_cd->indexDimNum, rl * sizeof(int *));
	nap_cd->braceLevel = (int *) NAP_REALLOC(nap_cd, nap_cd->braceLevel, rl * sizeof(int *));
    }
    nap_cd->recursionLimit = rl;
    ++nap_cd->parseLevel;
    if (nap_cd->parseLevel == 0) {
	nap_cd->errorCode = 0;
    }
    assert(obj_expr);
    nap_cd->indexBaseCV[nap_cd->parseLevel] = indexBaseCV;
    nap_cd->indexDimNum[nap_cd->parseLevel] = 0;
    nap_cd->braceLevel[nap_cd->parseLevel] = 0;
    nap_cd->resultNao = NULL;
    Nap_InitTclResult(nap_cd);
    objNapCommand = Tcl_NewStringObj("\n", -1);
    assert(objNapCommand);
    Tcl_IncrRefCount(objNapCommand);
    Tcl_AppendObjToObj(objNapCommand, obj_expr);
    str = Tcl_GetStringFromObj(objNapCommand, NULL);
    assert(str);
    nap_cd->commandLength[nap_cd->parseLevel] = strlen(str);
    str = Nap_StrCat(nap_cd, str, " ", str, NULL); /* 2nd copy for lex tokens */
    assert(str);
    str[nap_cd->commandLength[nap_cd->parseLevel]] = '\0';
    Tcl_DecrRefCount(objNapCommand);
    nap_cd->scanString[nap_cd->parseLevel] = str + 1; /* skip '\n' at start */
    obj_str_auto_noexec = Tcl_NewStringObj("auto_noexec", -1);
    assert(obj_str_auto_noexec);
    Tcl_IncrRefCount(obj_str_auto_noexec);
    obj_auto_noexec = Tcl_ObjGetVar2(nap_cd->interp, obj_str_auto_noexec, NULL, 0);
    if (!obj_auto_noexec) {
	objTmp = Tcl_ObjSetVar2(nap_cd->interp, obj_str_auto_noexec, NULL,
		Tcl_NewBooleanObj(1), 0);
	assert(objTmp);
    }
    status = Nap_parse(nap_cd);
    if (!obj_auto_noexec) {
	status = Tcl_UnsetVar(nap_cd->interp, "auto_noexec", 0);
	assert(status == TCL_OK);
    }
    Tcl_DecrRefCount(obj_str_auto_noexec);
    --nap_cd->parseLevel;
    NAP_FREE(nap_cd, str);
    if (nap_cd->errorCode) {
	nap_cd->resultNao = NULL;
    }
    return nap_cd->resultNao ? nap_cd->resultNao->id : NULL;
}


/*
 * Nap_Cmd --
 *
 *  Process 'nap' command.
 *  Concatenate arguments with ' ' separator.  
 */

m4define(`m4NAME', `Nap_Cmd')

EXTERN int
Nap_Cmd(
    ClientData		clientData,
    Tcl_Interp		*interp,
    int			objc,
    Tcl_Obj *CONST	objv[])
{
    NapClientData	*nap_cd = (NapClientData *) clientData;
    Tcl_Obj		*obj_expr;		/* expression (string) */
    char		*result;		/* OOC-name (ID) of resultant NAO */
    int			status;			/* return code */

    obj_expr = Tcl_ConcatObj(objc-1, objv+1);
    assert(obj_expr);
    Tcl_IncrRefCount(obj_expr);
    result = Nap_expression(nap_cd, obj_expr, NULL);
    Tcl_DecrRefCount(obj_expr);
    if (result) {
	Tcl_SetObjResult(nap_cd->interp, Tcl_NewStringObj(result, -1));
	status = TCL_OK;
    } else {
	status = TCL_ERROR;
    }
    return status;
}


/*
 *  Nap_InfoCmd --
 *
 *  nap_info command.
 *
 *  Usage:
 *	nap_info bytes
 *	    Return following four values:
 *		(a) current number of bytes allocated to NAOs
 *		(b) maximum (so far) number of bytes allocated to NAOs
 *		(c) current number of bytes allocated by NAP_ALLOC (excludes (a) above)
 *		(d) maximum (so far) number of bytes allocated by NAP_ALLOC
 *
 *	nap_info nodes
 *	    Return number of parse-nodes (should be 0)
 *
 *	nap_info seconds
 *	    Return processor (CPU) time in seconds used by tcl since it commenced execution.
 *	    The value is that provided by the standard C function clock().
 *	    The resolution is 1 tick (typically about 0.02 second).
 *
 *	nap_info sequence
 *	    Return sequence number of most recently created NAO.
 */

m4define(`m4NAME', `Nap_InfoCmd')

EXTERN int
Nap_InfoCmd(
    ClientData		clientData,
    Tcl_Interp		*interp,
    int			objc,
    Tcl_Obj		*CONST objv[])
{
    int			index;
    NapClientData	*nap_cd = (NapClientData *) clientData;
    double		seconds;		/* clock value */
    int			status;
    CONST char		*str;
    char		tmp_str[32];		/* temp. string */

    CONST char		*subCommands[] = {
				"bytes",
				"nodes",
				"seconds",
				"sequence",
				(char *) NULL};

    nap_cd->errorCode = 0;
    CHECK_NUM_ARGS(objc == 2, 1, "bytes|nodes|seconds|sequence");
    status = Tcl_GetIndexFromObj(interp, objv[1], subCommands, "sub-command", 0, &index);
    if (status != TCL_OK) {
	CHECK(FALSE);
    }
    switch (index) {
    case 0: /* bytes */
	sprintf(tmp_str, "%u %u %u %u",
		(unsigned int) nap_cd->totalBytesNAO,
		(unsigned int) nap_cd->maxTotalBytesNAO,
		(unsigned int) nap_cd->otherBytes,
		(unsigned int) nap_cd->maxOtherBytes);
	break;
    case 1: /* nodes */
	sprintf(tmp_str, "%u", (unsigned int) nap_cd->numberPNodes);
	break;
    case 2: /* seconds */
	seconds = (double) clock() / (double) CLOCKS_PER_SEC;
	sprintf(tmp_str, "%g", seconds);
	break;
    case 3: /* sequence */
	sprintf(tmp_str, "%u", (unsigned int) nap_cd->seqNum);
	break;
    default:
	assert(0);
    }
    Tcl_SetResult(interp, tmp_str, TCL_VOLATILE);
    return TCL_OK;
}

/*
 * Nap_CreateStandardMissingValues --
 *	For every data type create new scalar NAO with standard missing value
 *	for that type.
 */

m4begin

m4define(`m4NAME', `Nap_CreateStandardMissingValues')

#	m4createMissingValues(DataType)	 e.g. m4createMissingValues(I16)
m4define(`m4createMissingValues', `
	naoPtr = Nap_NewScalarNAO(nap_cd, m4DataTypeEnum($1), m4DataTypeMissingValue($1));
	naoPtr->mortal = FALSE;
	Nap_IncrRefCount(nap_cd, naoPtr);
	assert(Nap_IsNAO(nap_cd, naoPtr));
	str = Nap_Assign(nap_cd, "::NAP::standard`$1'MissingValue", naoPtr->id);
	assert(str);
	nap_cd->`$1'MissingValueNao = naoPtr;')

m4end

EXTERN void
Nap_CreateStandardMissingValues(
    NapClientData	*nap_cd)
{
    Nap_NAO		*naoPtr;
    char		*str;

    m4ForAllDataType(`m4createMissingValues(', `)')
    naoPtr = Nap_NewScalarNAO(nap_cd, NAP_I32, 0);
    assert(naoPtr);
    nap_cd->RaggedMissingValueNao->raggedStartSlot = naoPtr->slot;
    Nap_IncrRefCount(nap_cd, naoPtr);
}
