m4dnl   This is m4 source.
m4dnl   Process using m4 to produce 'C' language file.
m4dnl
m4dnl   If you see this line, you can ignore the next one.
/* Do not edit this file (nap.c). It was produced from source file nap.c,m4 */

/* 
 *      napSpatial.c,m4 --
 *
 *      Copyright 1999, CSIRO Australia
 *      Author: P.J. Turner, CSIRO Atmospheric Research
 */

#ifndef lint
static char *rcsid="@(#) $Id: napSpatial.c,m4,v 1.10 2002/05/14 00:32:03 dav480 Exp $"
;
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"

/* Nap_moving_range --
 *
 * Compute the maximum difference between elements
 * in a sliding window of size m*n If m and n
 * are odd the result is placed in the center
 * position of the window. Otherwise the result
 * is positioned in the top left corner.
 *
 * Method: Find the maximum and minimum values in the
 *         kernel area to get the maximum difference.
 *
 * Usage:
 *	moving_range(data,kernel_shape)
 *
 *      where data is an array or vector
 *      and shape specifies dimensions (less than or equal data)
 */

m4begin

m4define(`m4MRSUBS',`
static int
movrange_$1(
    void *in,		/* input data array	*/
    size_t ySize,	/* ysize		*/
    size_t xSize,	/* xsize		*/
    size_t yksize,	/* ysize of the kernel	*/
    size_t xksize,	/* xsize of the kernel	*/
    void *out		/* output data array	*/
)

{
    size_t xlag;	/* number of x steps across the input data	*/
    size_t ylag;	/* number of y steps across the input data	*/
    size_t resultOffset;	/* amount to offset result wrt kernel	*/
    m4DataTypeName($1) *pixelPtr;	/* current input pixelpointer	*/
    m4DataTypeName($1) *lineInPtr;	/* current input line pointer 	*/ 
    m4DataTypeName($1) *pixelOutPtr;	/* current output pixel pointer	*/ 
    m4DataTypeName($1) *lineOutPtr;	/* current output line pointer	*/ 
    m4DataTypeName($1) *kpixelPtr;	/* pixel pointer  current window area */
    m4DataTypeName($1) *klinePtr;	/* line pointer inthe window area */
    m4DataTypeName($1) kmax;	/* current maximum kernel value		*/
    m4DataTypeName($1) kmin;	/* current minimum kernel value		*/
    int i,j;	/* integer x,y positions in the data space	*/
    int m,n,xwo,ywo;

    if(xSize + 1 < xksize || ySize + 1 < yksize) {
        return(-1);
    }

    xlag = xSize - xksize + 1;
    ylag = ySize - yksize + 1;

/*
 * Put the result as close to the center of the
 * sliding window as possible
 */
    xwo = (xksize - 1)/2;
    ywo = (yksize - 1)/2;
    resultOffset = ywo*xSize + xwo;

/*
 * Clear regions the window is not going to write to.
 */

    lineOutPtr = out;
    for(i=0; i < ySize; i++) {
        pixelOutPtr = lineOutPtr;
        if(i < ywo || i >= (ylag + ywo)) {
            for(j=0; j < xSize; j++) {
                *pixelOutPtr = m4DataTypeMissingValue($1);
                pixelOutPtr++;
            }
        } else {
            for(j=0; j < xwo; j++) {
                *pixelOutPtr = m4DataTypeMissingValue($1);
                pixelOutPtr++;
            }
            pixelOutPtr = lineOutPtr + xlag + xwo;
            for(j=xlag+xwo; j < xSize; j++) {
                *pixelOutPtr = m4DataTypeMissingValue($1);
                pixelOutPtr++;
            }

        }
        lineOutPtr = lineOutPtr + xSize;
    }

    lineInPtr = in;
    lineOutPtr = out;
    lineOutPtr = lineOutPtr + resultOffset;
    for(i=0; i < ylag; i++) {
        pixelPtr = lineInPtr;
        for(j=0; j < xlag; j++) {
/*
 * At this point we are positioned at some i,j pixel
 * in the input data array. The i,j represents the
 * top left corner of the operator kernel.
 */
            m = 0;
            klinePtr = pixelPtr;
            kpixelPtr = pixelPtr;
/* case here */
            kmax = kmin = *kpixelPtr;
            for(m=0; m < yksize; m++) {
                for(n=0; n < xksize; n++) {
                    if(*kpixelPtr > kmax) kmax = *kpixelPtr;
                    if(*kpixelPtr < kmin) kmin = *kpixelPtr;
                    kpixelPtr++;
                }
                klinePtr = klinePtr + xSize;
                kpixelPtr = klinePtr;
            }
/*
 * Put the result somewhere!
 */
            pixelOutPtr = lineOutPtr + j;
            *pixelOutPtr = kmax - kmin;
/*
 * Move to the next pixel position
 */
            pixelPtr++;
        }
        lineOutPtr = lineOutPtr + xSize;
        lineInPtr = lineInPtr + xSize;
    }
    return(0);
}
')

m4define(`m4CASES', `
        case m4DataTypeEnum($1):
	    movrange_$1(in_nao->data.$1, shape[0], shape[1],
		    yWinSize,xWinSize, result->data.$1); 
            break;
')

m4define(`m4NAME', `Nap_moving_range')
 
m4end

m4ForAllNumericDataType(`m4MRSUBS(', `)')

EXTERN char *
Nap_moving_range(
    NapClientData       *nap_cd,
    Nap_NAO		*box_nao)	/* points to user's arguments	*/
{
    Nap_NAO		*in_nao;	/* input array			*/ 
    Nap_NAO		*winShape;	/* window shape			*/ 
    Nap_NAO		*result;	/* output array			*/ 
    Nap_dataType	dataType;
    size_t		shape[3];	/* input data shape -> output   */
    size_t		rank;		/* input data rank -> output	*/
    size_t		yWinSize;	/* sliding window dimension	*/
    size_t		xWinSize;	/* sliding window dimension	*/
    int			i;		/* loop counter			*/
    int			status;


    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels == 2,
             "m4NAME: Usage should be 'maxdiff(data,windowShape)' ");
    in_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    assert(in_nao);
    dataType = in_nao->dataType;
    rank = in_nao->rank;
    CHECK2NULL(rank == 2, "m4NAME: input NAO rank not 2");

    winShape = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(winShape->nels == 2, "m4NAME: window dimensions not 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */
    winShape = Nap_CastNAO(nap_cd, winShape, NAP_I32);
    Nap_IncrRefCount(nap_cd, winShape);

    yWinSize = winShape->data.I32[0];
    xWinSize = winShape->data.I32[1];

    Nap_DecrRefCount(nap_cd, winShape);

    for(i=0; i < rank; i++) {
        shape[i] = in_nao->shape[i];
    }
    result = Nap_NewNAO(nap_cd, dataType, rank, shape);
    CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");
/*
 * Copy and attach all the input data CV's
 * to the output nao "result".
 */
    status = Nap_CopyDims(nap_cd, in_nao, result);
    CHECK2NULL(status == TCL_OK, "m4Name: Error Calling Nap_CopyDims");

    switch (dataType) {
        m4ForAllNumericDataType(`m4CASES(', `)')
        default:		/* Error		*/
            return NULL;
    }

    return result->id;
}

/* Nap_dilate --
 *
 * Perform a dilation operation.
 *
 * Method: Slide the structuring element over all elements in the
 * image undergoing analysis. Where the center of the structure
 * element encounters a non zero value, replicate that value
 * at all non zero structure element positions
 *
 *
 * P.J. Turner, CSIRO Atmospheric Research, August 1999
 */
 
m4begin

m4define(`m4DISUBS',`
static int
dilate_$1(
    m4DataTypeName($1) *in,		/* input data array	*/
    size_t ySize,	/* ysize		*/
    size_t xSize,	/* xsize		*/
    m4DataTypeName($1) *se,		/* structure element	*/
    size_t ySeSize,	/* ysize of the structure element	*/
    size_t xSeSize,	/* xsize of the structure element	*/
    size_t ySeOrigin,	/* y structure element origin	*/
    size_t xSeOrigin,	/* x structure element origin	*/
    m4DataTypeName($1) *out		/* output data array	*/
)

{
    size_t xLag;	/* number of x steps across the input data	*/
    size_t yLag;	/* number of y steps across the input data	*/
    m4DataTypeName($1) *imagePixelInPtr;	/* image pixel pointer	*/ 
    m4DataTypeName($1) *imageLineInPtr;		/* image line pointer 	*/ 
    m4DataTypeName($1) *imagePixelOutPtr;	/* output pixel pointer	*/ 
    m4DataTypeName($1) *imageLineOutPtr;	/* output line pointer	*/ 
    m4DataTypeName($1) *sePixelPtr;		/* pixel pointer se	*/
    m4DataTypeName($1) *seLinePtr;		/* line pointer se	*/
    m4DataTypeName($1) *seImageLineInPtr;	/* image line pointer se */ 
    m4DataTypeName($1) *seImageLineOutPtr; 	/* output line pointer se */
    m4DataTypeName($1) *seImagePixelOutPtr;	/* output pixel pointer se */
    m4DataTypeName($1) seImageOriginValue;	/* image value at se origin */
    int i,j;	/* integer x,y positions in the data space	*/
    int m,n;
   
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
        return(-1);
    }

    xLag = xSize - xSeSize + 1;
    yLag = ySize - ySeSize + 1;

/* 
 * We have to zero everything in the output first !
 */
    
    imageLineOutPtr = out;
    for(i=0; i < ySize; i++) {
        imagePixelOutPtr = imageLineOutPtr;
        for(j=0; j < xSize; j++) {
            *imagePixelOutPtr = 0.0;
            imagePixelOutPtr++;
        }
        imageLineOutPtr = imageLineOutPtr + xSize;
    }

/*
 * Calculate the result offset !
 */

    imageLineInPtr = in;
    imageLineOutPtr = out;

    for(i=0; i < yLag; i++) {
        imagePixelInPtr = imageLineInPtr;
        imagePixelOutPtr = imageLineOutPtr;
        for(j=0; j < xLag; j++) {
/*
 * At this point we are positioned at some i,j pixel
 * in the input data array. The i,j represents the
 * top left corner of the operator kernel.
 *
 * Test to see if the origin structure element position
 * in the image is > 0. If this test is true set all the
 * values in the image corresponding to no zero values in the structure
 * element to the image value.
 */

/* 
 * START of Structure element Block!
 */

            seImageLineInPtr = imagePixelInPtr;
            seImageLineOutPtr = imagePixelOutPtr;

            seImageOriginValue = *(seImageLineInPtr + ySeOrigin*xSize + xSeOrigin);
            if(seImageOriginValue > 0.0) {
                seLinePtr = se;
                for(m=0; m < ySeSize; m++) {
                    seImagePixelOutPtr = seImageLineOutPtr;
                    sePixelPtr = seLinePtr;
                    for(n=0; n < xSeSize; n++) {
                        if(*sePixelPtr > 0.0) {
                            *seImagePixelOutPtr = seImageOriginValue;
                        }
                        sePixelPtr++;
                        seImagePixelOutPtr++;
                    }
                    seLinePtr = seLinePtr + xSeSize;
                    seImageLineOutPtr = seImageLineOutPtr + xSize;
                }
            }

/*
 * END of Structure Element Block !
 */

/*
 * Move to the next image pixel position
 */
            imagePixelInPtr++;
            imagePixelOutPtr++;
        }
/*
 * increment according to line length
 */
        imageLineInPtr =  imageLineInPtr  + xSize;
        imageLineOutPtr = imageLineOutPtr + xSize;
    }
    return(0);
}
')

m4define(`m4CASES', `
        case m4DataTypeEnum($1):
	    dilate_$1(in_nao->data.$1, ySize, xSize, se_nao->data.$1, ySeSize, xSeSize, ySeOrigin,
		    ySeOrigin, result->data.$1); 
            break;
')

m4define(`m4NAME', `Nap_dilate')
 
m4end

m4ForAllNumericDataType(`m4DISUBS(', `)')

EXTERN char *
Nap_dilate(
    NapClientData       *nap_cd,
    Nap_NAO		*box_nao)	/* points to user's arguments	*/
{
    Nap_NAO		*in_nao;	/* input array			*/ 
    Nap_NAO		*se_nao;	/* structure element		*/ 
    Nap_NAO		*org_nao;	/* position of se origin	*/
    Nap_NAO		*result;	/* output array			*/ 
    Nap_dataType	dataType;
    size_t		ySize;	/* input data shape -> output   */
    size_t		xSize;	/* input data shape -> output   */
    size_t		rank;		/* input data rank -> output	*/
    size_t		ySeSize;	/* structure element dimension	*/
    size_t		xSeSize;	/* structure element dimension	*/
    size_t		ySeOrigin;	/* structure element dimension	*/
    size_t		shape[3];	/* structure element dimension	*/
    int			status;


    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels == 3,
             "m4NAME: Usage should be 'dilate(data,structureElement,Origin)' ");
    in_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    assert(in_nao);
    dataType = in_nao->dataType;
    rank = in_nao->rank;
    shape[0] = ySize = in_nao->shape[0];
    shape[1] = xSize = in_nao->shape[1];

    CHECK2NULL(rank == 2, "m4NAME: input NAO rank not 2");

    se_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(se_nao->rank <= 2, "m4NAME: structure element dimensions > 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */
    se_nao = Nap_CastNAO(nap_cd, se_nao, dataType);
    Nap_IncrRefCount(nap_cd, se_nao);

    if(se_nao->rank == 1) { 
        xSeSize = se_nao->shape[0];
        ySeSize = 1;
    } else {
        ySeSize = se_nao->shape[0];
        xSeSize = se_nao->shape[1];
    }

    org_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[2]);
    CHECK2NULL(org_nao->nels == 2, "m4NAME: origin values not 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */

    org_nao = Nap_CastNAO(nap_cd, org_nao, NAP_I32);
    Nap_IncrRefCount(nap_cd, org_nao);
    CHECK2NULL(org_nao->data.I32[0] >= 0 && org_nao->data.I32[0] < ySeSize,
	    "m4NAME: SE y coord outside SE");
    CHECK2NULL(org_nao->data.I32[1] >= 0 && org_nao->data.I32[1] < xSeSize,
	    "m4NAME: SE x coord outside SE");

    ySeOrigin = org_nao->data.I32[0];
    Nap_DecrRefCount(nap_cd, org_nao);
    result = Nap_NewNAO(nap_cd, dataType, rank, shape);
    CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");

/*
 * Copy and attach all the input data CV's
 * to the output nao "result".
 */
    status = Nap_CopyDims(nap_cd, in_nao, result);
    CHECK2NULL(status == TCL_OK, "m4Name: Error Calling Nap_CopyDims");

    switch (dataType) {
        m4ForAllNumericDataType(`m4CASES(', `)')
        default:		/* Error		*/
            return NULL;
    }

    Nap_DecrRefCount(nap_cd, se_nao);

    return result->id;
}

/* Nap_erode --
 *
 * Perform a erosion operation.
 *
 * Method: Slide the structuring element over all elements in the
 * image undergoing analysis. Where the center of the structure
 * element encounters a non zero value, replicate that value
 * at all non zero structure element positions
 *
 *
 * P.J. Turner, CSIRO Atmospheric Research, August 1999
 */
 
m4begin

m4define(`m4ERSUBS',`
static int
erode_$1(
    m4DataTypeName($1) *in,	/* input data array			*/
    size_t ySize,		/* ysize				*/
    size_t xSize,		/* xsize				*/
    m4DataTypeName($1) *se,	/* structure element			*/
    size_t ySeSize,		/* ysize of the structure element	*/
    size_t xSeSize,		/* xsize of the structure element	*/
    size_t ySeOrigin,		/* y structure element origin		*/
    size_t xSeOrigin,		/* x structure element origin		*/
    m4DataTypeName($1) *out	/* output data arra		y	*/
)

{
    size_t xLag;	/* number of x steps across the input data	*/
    size_t yLag;	/* number of y steps across the input data	*/
    m4DataTypeName($1) *imagePixelInPtr; 	/* input pixel		*/ 
    m4DataTypeName($1) *imageLineInPtr; 	/* input line  		*/ 
    m4DataTypeName($1) *imagePixelOutPtr; 	/* output pixel		*/ 
    m4DataTypeName($1) *imageLineOutPtr; 	/* output line 		*/ 
    m4DataTypeName($1) *sePixelPtr;		/* SE pixel 		*/
    m4DataTypeName($1) *seLinePtr;		/* SE line 		*/
    m4DataTypeName($1) *seImageLineInPtr;  /* SE image line   in 	*/ 
    m4DataTypeName($1) *seImagePixelInPtr; /* SE image pixel  in	*/
    size_t seImageOriginOffset; 	/* image value the SE origin	*/
    m4DataTypeName($1) *fPtr;		/* temporary pointer		*/
    int erodeFlag;	/* true implies set the output to 0		*/
    int i,j;	/* integer x,y positions in the data space	*/
    int m,n;
   
    if(xSize + 1 < xSeSize || ySize + 1 < ySeSize) {
        return(-1);
    }

    xLag = xSize - xSeSize + 1;
    yLag = ySize - ySeSize + 1;

/*
 * We have to zero everything in the output first !
 */

    imageLineOutPtr = out;
    for(i=0; i < ySize; i++) {
        imagePixelOutPtr = imageLineOutPtr;
        for(j=0; j < xSize; j++) {
            *imagePixelOutPtr = 0.0;
            imagePixelOutPtr++;
        }
        imageLineOutPtr = imageLineOutPtr + xSize;
    }

/*
 * Calculate the result offset !
 */
   

    imageLineInPtr = in;
    imageLineOutPtr = out;
    seImageOriginOffset =  ySeOrigin*xSize + xSeOrigin;

    for(i=0; i < yLag; i++) {
        imagePixelInPtr = imageLineInPtr;
        imagePixelOutPtr = imageLineOutPtr;
        for(j=0; j < xLag; j++) {
/*
 * At this point we are positioned at some i,j pixel
 * in the input data array. The i,j represents the
 * top left corner of the operator kernel.
 *
 * Test to see if the origin structure element position
 * in the image is > 0. If this test is true set all the
 * values in the image corresponding to no zero values in the structure
 * element to the image value.
 */

/* 
 * START of Structure element Block!
 */

            seImageLineInPtr = imagePixelInPtr;

            seLinePtr = se;
            erodeFlag = 0;
            for(m=0; m < ySeSize; m++) {
                seImagePixelInPtr = seImageLineInPtr;
                sePixelPtr = seLinePtr;
                for(n=0; n < xSeSize; n++) {
                    if(*sePixelPtr > 0.0) {
                        if(*seImagePixelInPtr <= 0.0) {
                            erodeFlag++;
                        }
                    }
                    sePixelPtr++;
                    seImagePixelInPtr++;
                }
                seLinePtr = seLinePtr + xSeSize;
                seImageLineInPtr = seImageLineInPtr + xSize;
            }

/*
 * Not sure what to do here! The problem is that if the
 * structure element origin is zero and the corresponding
 * image element is zero we get no element where we should get one.
 */
            if(erodeFlag > 0) {
                *(imagePixelOutPtr + seImageOriginOffset) = 0.0; 
            } else {
                fPtr = (imagePixelOutPtr + seImageOriginOffset);
                *fPtr = *(imagePixelInPtr + seImageOriginOffset);
               if(*fPtr <= 0.0) {
                   *fPtr = 1.0;
               } 
            }

/*
 * END of Structure Element Block !
 */

/*
 * Move to the next image pixel position
 */
            imagePixelInPtr++;
            imagePixelOutPtr++;
        }
/*
 * increment according to line length
 */
        imageLineInPtr = imageLineInPtr + xSize;
        imageLineOutPtr = imageLineOutPtr + xSize;
    }
    return(0);
}

')

m4define(`m4CASES', `
        case m4DataTypeEnum($1):
               erode_$1(in_nao->data.$1, ySize, xSize, se_nao->data.$1, ySeSize, xSeSize,
			ySeOrigin, ySeOrigin, result->data.$1); 
            break;
')

m4define(`m4NAME', `Nap_erode')
 
m4end

m4ForAllNumericDataType(`m4ERSUBS(', `)')

EXTERN char *
Nap_erode(
    NapClientData       *nap_cd,
    Nap_NAO		*box_nao)	/* points to user's arguments	*/
{
    Nap_NAO		*in_nao;	/* input array			*/ 
    Nap_NAO		*se_nao;	/* structure element		*/ 
    Nap_NAO		*org_nao;	/* position of se origin	*/
    Nap_NAO		*result;	/* output array			*/ 
    Nap_dataType	dataType;
    size_t		ySize;	/* input data shape -> output   */
    size_t		xSize;	/* input data shape -> output   */
    size_t		rank;		/* input data rank -> output	*/
    size_t		ySeSize;	/* structure element dimension	*/
    size_t		xSeSize;	/* structure element dimension	*/
    size_t		ySeOrigin;	/* structure element dimension	*/
    size_t		shape[3];	/* structure element dimension	*/
    int			status;

    assert(box_nao);
    assert(box_nao->dataType == NAP_BOXED);
    CHECK2NULL(box_nao->rank == 1, "m4NAME: Argument rank not 1");
    CHECK2NULL(box_nao->nels == 3,
             "m4NAME: Usage should be 'dilate(data,structureElement,Origin)' ");
    in_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[0]);
    assert(in_nao);
    dataType = in_nao->dataType;
    rank = in_nao->rank;
    shape[0] = ySize = in_nao->shape[0];
    shape[1] = xSize = in_nao->shape[1];

    CHECK2NULL(rank == 2, "m4NAME: input NAO rank not 2");

    se_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[1]);
    CHECK2NULL(se_nao->rank <= 2, "m4NAME: structure element dimensions > 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */
    se_nao = Nap_CastNAO(nap_cd, se_nao, dataType);
    Nap_IncrRefCount(nap_cd, se_nao);

    if(se_nao->rank == 1) { 
        xSeSize = se_nao->shape[0];
        ySeSize = 1;
    } else {
        ySeSize = se_nao->shape[0];
        xSeSize = se_nao->shape[1];
    }

    org_nao = Nap_GetNaoFromSlot(box_nao->data.Boxed[2]);
    CHECK2NULL(org_nao->nels == 2, "m4NAME: origin values not 2");

/*
 * We create a new NAO (if necessary) of type i32.
 * We increment the reference count and then decrement
 * the reference count to get rid of it. This is much safer
 * than freeing the NAO.
 */

    org_nao = Nap_CastNAO(nap_cd, org_nao, NAP_I32);
    Nap_IncrRefCount(nap_cd, org_nao);
    CHECK2NULL(org_nao->data.I32[0] >= 0 && org_nao->data.I32[0] < ySeSize,
	    "m4NAME: SE y coord outside SE");
    CHECK2NULL(org_nao->data.I32[1] >= 0 && org_nao->data.I32[1] < xSeSize,
	    "m4NAME: SE x coord outside SE");
    ySeOrigin = org_nao->data.I32[0];
    Nap_DecrRefCount(nap_cd, org_nao);
    result = Nap_NewNAO(nap_cd, dataType, rank, shape);
    CHECK2NULL(result, "m4NAME: error calling Nap_NewNAO");

/*
 * Copy and attach all the input data CV's
 * to the output nao "result".
 */
    status = Nap_CopyDims(nap_cd, in_nao, result);
    CHECK2NULL(status == TCL_OK, "m4Name: Error Calling Nap_CopyDims");

    switch (dataType) {
        m4ForAllNumericDataType(`m4CASES(', `)')
        default:		/* Error		*/
            return NULL;
    }

    Nap_DecrRefCount(nap_cd, se_nao);

    return result->id;
}
