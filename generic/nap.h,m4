m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (nap.h). It was produced from source file nap.h,m4 */

/*
 * nap.h,m4 --
 *
 * numeric array processor (nap)
 *
 * Copyright (c) 1999, CSIRO Australia
 *
 * Author: Harvey Davies, CSIRO Atmospheric Research
 *
 * $Id: nap.h,m4,v 1.219 2007/11/01 09:00:17 dav480 Exp $
 */

#ifndef _NAP
#define _NAP

#include <assert.h>
#include <ctype.h>
#include <fcntl.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <setjmp.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef HAVE_IEEEFP_H
#include <ieeefp.h>
#endif /* HAVE_IEEEFP_H */

#include <tcl.h>

/*
 * Following from Scriptics page headed (sic) "Building Extentions on Windows".
 */

#ifdef BUILD_nap
#  undef  TCL_STORAGE_CLASS
#  define TCL_STORAGE_CLASS DLLEXPORT
#endif

#ifndef Max
#define Max(a,b) ((a) > (b) ? (a) : (b))
#endif /* Max */

#ifndef Min
#define Min(a,b) ((a) < (b) ? (a) : (b))
#endif /* Min */

#ifndef Abs
#define Abs(x)	((x) < 0 ? -(x) : (x))
#endif /* Abs */

#ifndef AbsDiff
#define AbsDiff(x,y)  ((x) > (y) ? (x)-(y) : (y)-(x))
#endif /* AbsDiff */

#ifndef Sign
#define Sign(x) ((x) < 0 ? -1 : (x) > 0)
#endif /* Sign */

#ifndef Sign2
#define Sign2(x,y) (Abs(x) * Sign(y))
#endif /* Sign2 */

#ifndef Sq
#define Sq(x) ((x)*(x))
#endif /* Sq */

#ifndef Nint
#define Nint(x) floor((x) + 0.5)
#endif /* Nint */

#ifndef Pow
#define Pow(x,y) ((x)==0.0 && (y)==0.0 ? 1.0 : pow(x,y))
#endif /* Pow */

#ifndef hypot
#define hypot(x,y) sqrt(Sq(x) + Sq(y))
#endif /* hypot */

/*
 *  Is str1 prefix of str2?
 */
#ifndef isPrefixOf
#define isPrefixOf(str1,str2) (strstr(str2, str1) == str2)
#endif /* isPrefixOf */

/*
 *  IsMissing tests whether element i of NAO is missing
 */
#ifndef IsMissing
#define IsMissing(naoPtr, i) (naoPtr->isMissing(naoPtr, i))
#endif /* IsMissing */

/*
 *  IsNaN64 tests for double NaN.
 */
#ifndef IsNaN64
    #ifdef ISNAN64
	#define IsNaN64(x) ISNAN64(x)
    #else
	#define IsNaN64(x) Nap_NE_f64(x, x)
    #endif /* ISNAN64 */
#endif /* IsNaN64 */

/*
 *  IsNaN32 tests for float NaN.
 */
/* Following definition from ieeefp.h (assume 32-bit int) */
#define IsNaN32(x)	(((*(int *)&(x) & 0x7f800000)==0x7f800000)&& \
			 ((*(int *)&(x) & 0x007fffff)!=0x00000000) )
#ifndef IsNaN32
#define IsNaN32(x) Nap_NE_f32(x, x)
#endif /* IsNaN32 */

#ifndef IsNaN_F64
    #define IsNaN_F64 IsNaN64
#endif /* IsNaN_F64 */

#ifndef IsNaN_F32
    #define IsNaN_F32 IsNaN32
#endif /* IsNaN_F32 */

#ifndef IsInf_F32
    #define IsInf_F32(x)       ((x) == -napF32Inf  ||  (x) == napF32Inf)
#endif /* IsInf_F32 */
#ifndef IsInf_F64
    #define IsInf_F64(x)       ((x) == -napF64Inf  ||  (x) == napF64Inf)
#endif /* IsInf_F64 */

/*
 *  Nap_GetNaoFromSlot gives pointer to nao corresponding to its slot
 */
#ifndef Nap_GetNaoFromSlot
#define Nap_GetNaoFromSlot(slot) nap_cd->lookup[slot]
#endif /* Nap_GetNaoFromSlot */

/*
 *  These macros for character & integer types are similar to functions SAME_f32, SAME_f64.
 */

#ifndef SAME_c8
#define SAME_c8(x,y) ((x) == (y))
#endif /* SAME_c8 */

m4define(`m4tmp', `
#ifndef `SAME_'m4LowerCase($1)
#define `SAME_'m4LowerCase($1)`(x,y) ((x) == (y))'
#endif
')

m4ForAllIntegerDataType(`m4tmp(', `)')

#define NAP_MAX_MESSAGE_LENGTH 10000	/* max length of error message */
#define NAP_MAX_RANK 32			/* equals MAX_VAR_DIMS in HDF hlimits.h */
#define NAP_MAX_LEVEL 8			/* max. # levels indirection */
#define NAP_NAMESPACE "::NAP::"
#define NAP_NAO_ID_PREFIX NAP_NAMESPACE

/*
 *  Possible values for step field of NAO.  Only defined if rank = 1.
 *  Indicates whether sizes of steps are equal, & if not their sign.
 *  Thus indicates whether vector is monotonically ascending or descending,
 *  & if so whether it is arithmetic progression.
 */
typedef enum {
    NAP_STEP_UNKNOWN,
    NAP_STEP_NULL,		/* contains missing values or rank not 1 or nels < 2 */
    NAP_STEP_BOTH,		/* at least one positive step & one negative step */
    NAP_STEP_NON_NEGATIVE,	/* all steps >= 0 */
    NAP_STEP_NON_POSITIVE,	/* all steps <= 0 */
    NAP_STEP_EQUAL		/* equal steps (except final one - may be shorter) */
} Nap_step;

#define Nap_Valid_step(x) ( (x) >= NAP_STEP_UNKNOWN && (x) <= NAP_STEP_EQUAL )

    /* nap data types */
typedef unsigned char	Nap_c8;
typedef signed	 char	Nap_i8;
typedef unsigned char	Nap_u8;
typedef signed	 short	Nap_i16;
typedef unsigned short	Nap_u16;
typedef signed	 int	Nap_i32;
typedef unsigned int	Nap_u32;
typedef float		Nap_f32;
typedef double		Nap_f64;
typedef int		Nap_ragged;
typedef int		Nap_boxed;

typedef enum {
    m4ForAllDataType(`	  m4DataTypeEnum(', `),')
    NAP_NULL_TYPE			/* For undefined type, etc. */
} Nap_dataType;

m4define(`m4tmp',    `#define Nap_TypeIs$1(dataType)   (dataType == m4DataTypeEnum($1))')

m4ForAllDataType(`m4tmp(', `)')

#define Nap_TypeIsUnsignedInteger(dataType) \
	(Nap_TypeIsU8(dataType) || Nap_TypeIsU16(dataType) || Nap_TypeIsU32(dataType))

#define Nap_TypeIsSignedInteger(dataType) \
	(Nap_TypeIsI8(dataType) || Nap_TypeIsI16(dataType) || Nap_TypeIsI32(dataType))

#define Nap_TypeIsReal(dataType) \
	(Nap_TypeIsF32(dataType) || Nap_TypeIsF64(dataType))

#define Nap_TypeIsInteger(dataType) \
	(Nap_TypeIsUnsignedInteger(dataType) || Nap_TypeIsSignedInteger(dataType))

#define Nap_TypeIsNumeric(dataType) \
	(Nap_TypeIsInteger(dataType) || Nap_TypeIsReal(dataType))

#define Nap_TypeIsUnboxed(dataType) \
	(Nap_TypeIsNumeric(dataType) || Nap_TypeIsC8(dataType))

#define Nap_ValidDataType(dataType) \
	(Nap_TypeIsUnboxed(dataType) || Nap_TypeIsRagged(dataType) || Nap_TypeIsBoxed(dataType))

#define Nap_IsUnsignedInteger(nao) Nap_TypeIsUnsignedInteger((nao)->dataType)

#define Nap_IsSignedInteger(nao) Nap_TypeIsSignedInteger((nao)->dataType)

#define Nap_IsReal(nao) Nap_TypeIsReal((nao)->dataType)

#define Nap_IsInteger(nao) Nap_TypeIsInteger((nao)->dataType)

#define Nap_IsNumeric(nao) Nap_TypeIsNumeric((nao)->dataType)

#define Nap_IsBoxed(nao) Nap_TypeIsBoxed((nao)->dataType)

#define Nap_IsUnboxed(nao) Nap_TypeIsUnboxed((nao)->dataType)

/* Following explicit numeric definitions allow use in #if as described below */

#define NAP_C8_VALUE		0
#define NAP_I8_VALUE		1
#define NAP_U8_VALUE		2
#define NAP_I16_VALUE		3
#define NAP_U16_VALUE		4
#define NAP_I32_VALUE		5
#define NAP_U32_VALUE		6
#define NAP_F32_VALUE		7
#define NAP_F64_VALUE		8
#define NAP_RAGGED_VALUE	9
#define NAP_BOXED_VALUE		10
#define NAP_NULL_TYPE_VALUE	11

/*
 * Following used in #if.
 * E.g. #if Nap_TypeIsC8Value(U8)
 */

m4define(`m4tmp',
`#define Nap_TypeIs$1`'Value(dataType) (NAP_ ## dataType ## _VALUE == m4DataTypeEnum($1)_VALUE)')

m4ForAllDataType(`m4tmp(', `)')

#define Nap_TypeIsUnsignedIntegerValue(dataType) \
	(Nap_TypeIsU8Value(dataType) || Nap_TypeIsU16Value(dataType) \
	|| Nap_TypeIsU32Value(dataType))

#define Nap_TypeIsSignedIntegerValue(dataType) \
	(Nap_TypeIsI8Value(dataType) || Nap_TypeIsI16Value(dataType) \
	|| Nap_TypeIsI32Value(dataType))

#define Nap_TypeIsRealValue(dataType) \
	(Nap_TypeIsF32Value(dataType) || Nap_TypeIsF64Value(dataType))

#define Nap_TypeIsIntegerValue(dataType) \
	(Nap_TypeIsUnsignedIntegerValue(dataType) || Nap_TypeIsSignedIntegerValue(dataType))

#define Nap_TypeIsNumericValue(dataType) \
	(Nap_TypeIsIntegerValue(dataType) || Nap_TypeIsRealValue(dataType))

#define Nap_TypeIsUnboxedValue(dataType) \
	(Nap_TypeIsNumericValue(dataType) || Nap_TypeIsC8Value(dataType))


#define NAP_C8_MIN		0
#define NAP_C8_MAX		UCHAR_MAX
#define NAP_I8_MIN		SCHAR_MIN
#define NAP_I8_MAX		SCHAR_MAX
#define NAP_U8_MIN		0
#define NAP_U8_MAX		UCHAR_MAX
#define NAP_I16_MIN		SHRT_MIN
#define NAP_I16_MAX		SHRT_MAX
#define NAP_U16_MIN		0
#define NAP_U16_MAX		USHRT_MAX
#define NAP_I32_MIN		INT_MIN
#define NAP_I32_MAX		INT_MAX
#define NAP_U32_MIN		0
#define NAP_U32_MAX		UINT_MAX
#define NAP_F32_MIN		(-napF32Inf)
#define NAP_F32_MAX		napF32Inf
#define NAP_F64_MIN		(-napF64Inf)
#define NAP_F64_MAX		napF64Inf
#define NAP_RAGGED_MIN		0
#define NAP_RAGGED_MAX		INT_MAX
#define NAP_BOXED_MIN		0
#define NAP_BOXED_MAX		INT_MAX

/*
 * Following is similar except that 32-bit & 64-bit values are just integer ranks defined
 * by adding a small integer to USHRT_MAX or subtracting a small integer from SHRT_MIN.
 * This enables use in #if statements to compare range of different data-types.
 * (since float types not allowed in #if)
 */

#define NAP_C8_MIN_RANK		0
#define NAP_C8_MAX_RANK		UCHAR_MAX
#define NAP_I8_MIN_RANK		SCHAR_MIN
#define NAP_I8_MAX_RANK		SCHAR_MAX
#define NAP_U8_MIN_RANK		0
#define NAP_U8_MAX_RANK		UCHAR_MAX
#define NAP_I16_MIN_RANK	SHRT_MIN
#define NAP_I16_MAX_RANK	SHRT_MAX
#define NAP_U16_MIN_RANK	0
#define NAP_U16_MAX_RANK	USHRT_MAX
#define NAP_I32_MIN_RANK	(NAP_I16_MIN_RANK-1)
#define NAP_I32_MAX_RANK	(NAP_U16_MAX_RANK+1)
#define NAP_U32_MIN_RANK	0
#define NAP_U32_MAX_RANK	(NAP_I32_MAX_RANK+1)
#define NAP_F32_MIN_RANK	(NAP_I32_MIN_RANK-1)
#define NAP_F32_MAX_RANK	(NAP_U32_MAX_RANK+1)
#define NAP_F64_MIN_RANK	(NAP_F32_MIN_RANK-1)
#define NAP_F64_MAX_RANK	(NAP_F32_MAX_RANK+1)
#define NAP_RAGGED_MIN_RANK	0
#define NAP_RAGGED_MAX_RANK	INT_MAX
#define NAP_BOXED_MIN_RANK	0
#define NAP_BOXED_MAX_RANK	INT_MAX

#define NAP_C8_NULL		NAP_C8_MIN
#define NAP_I8_NULL		NAP_I8_MIN
#define NAP_U8_NULL		NAP_U8_MAX
#define NAP_I16_NULL		NAP_I16_MIN
#define NAP_U16_NULL		NAP_U16_MAX
#define NAP_I32_NULL		NAP_I32_MIN
#define NAP_U32_NULL		NAP_U32_MAX
#define NAP_F32_NULL		napF32NaN
#define NAP_F64_NULL		napF64NaN
#define NAP_RAGGED_NULL		0
#define NAP_BOXED_NULL		0

m4begin
m4define(`m4Number', `	m4DataTypeName($1)	$1;')
m4define(`m4Nao',    `	m4DataTypeName($2)	$1'`$2;')
m4end

typedef struct Number{			/* numeric scalar value */
    Nap_dataType	dataType;
m4ForAllNumericDataType(`m4Number(', `)')
} Nap_Number;

typedef struct Nao {			/* numeric array object */
    size_t		slot;		/* e.g. 9 for "nao.42-9" */
    size_t		seqNum;		/* e.g. 42 for "nao.42-9" */
    char		*id;		/* e.g. "nao.42-9" */
    int			count;		/* reference count */
    struct NapClientData_struct	*nap_cd; /* structure containing data previously global */
    Nap_dataType	dataType;	/* current data-type */
    Nap_dataType	dataType0;	/* original data-type */
    Nap_step		step;		/* efficiency hint for vectors */
    char		mortal;		/* FALSE = do not delete */
    char		*format;	/* C format for printing */
    char		*label;		/* title, description of data, etc. */
    char		*unit;		/* unit of measure in string form */
    int			rank;		/* # dimensions */
    size_t		nels;		/* product(shape) */
    size_t		nels0;		/* original value of nels */
    size_t		nbytes;		/* size of nao. Mainly for debugging */
    struct Nao		*boxedCV;	/* boxed NAO pointing to coord-vars (NULL if no Cvs) */
    int			linkSlot;	/* slot of link NAO (0 = none) */
    int			nextSlot;	/* used internally to create NAO "death list" (0 = none) */
    int			missingValueSlot; /* slot of missing value (0=none ) */
    struct Nao		*missingValuePtr; /* pointer to missing value NAO */
    int (*isMissing)(struct Nao *, size_t);  /* missing value function */
    int			raggedStartSlot; /* ragged startVector slot (0=none) */
    size_t		*shape;		/* sizes of dimensions */
    char		**dimName;	/* names (if any) of dimensions */
    union {
	char		*c;		/* useful when want to treat data as char */
m4ForAllDataType(`m4Nao(`*', ', `)')
    }		data;
} Nap_NAO;

typedef enum {				/* values for Nap_PNode.class */
    NAP_VALUE = 99,
    NAP_EXPR,
    NAP_NAO,
    NAP_NAME,
    NAP_LIST
} Nap_PNclass;

#define Nap_ValidPNclass(x) ( (x) >= NAP_VALUE && (x) <= NAP_LIST )

typedef struct PNode {			/* parse node */
    Nap_PNclass		class;		/* node type: NAP_VALUE, NAP_EXPR, etc. */
    Nap_Number		number;		/* numeric value for NAP_VALUE */
    char		*scanPtr;	/* pointer to input buffer */
    char		*str;		/* NAO ID for NAP_NAO, name for NAP_NAME */
    int			op;		/* operator token for NAP_EXPR */
    struct PNode	*left;		/* left operand for NAP_EXPR */
    struct PNode	*right;		/* right operand for NAP_EXPR */
    int			repCount;	/* repetition count for NAP_LIST, NAP_VALUE */
    struct PNode	*list;		/* list of lower level for NAP_LIST */
    struct PNode	*next;		/* next element in same list for NAP_LIST */
    struct PNode	*tail;		/* final element in same list for NAP_LIST */
} Nap_PNode;

typedef union {				/* Used by parser */
    int		op;
    char	*str;
    Nap_Number	number;
    Nap_PNode	*pnode;
} Nap_stype;

/*
 * Following 'NapClientData' structure holds admin. data needed for each interpreter.
 *
 * Lookup table 'lookup' gives fast mapping from slot to NAO address.
 * Start with single entry lookup[0] == NULL for special case of ID == 0.
 *
 * Free stack 'free' is list of deleted (NULL) entries in lookup table.
 * These can be reused.
 */

typedef struct NapClientData_struct {
    Tcl_Interp			*interp;	/* interpreter which created this stucture */
    int				parseLevel;   	/* -1: outside parser; > 0: recursive call */
    int				recursionLimit;	/* max. NAP nesting depth */
    char 			**token;	/* in flex input stream */
    char 			**scanString;	/* flex input stream */
    size_t			*commandLength; /* # characters in command */
    int				errorCode;	/* 0 = OK, 1 = error */
    size_t			otherBytes;	/* total # bytes currently allocated */
    size_t			maxOtherBytes;	/* max. so far */
    size_t			totalBytesNAO;	/* total # bytes currently in NAOs */
    size_t			maxTotalBytesNAO; /* max. so far */
    size_t			numberPNodes;	/* total # PNodes */
    Nap_NAO			*resultNao;	/* most recent NAO result of Nap_expression */
    char  			*result;	/* result-buffer for Tcl-result */
    size_t			result_bs;	/* result-buffer size */
    size_t			result_n;	/* # chars in current result */
    size_t			seqNum;		/* sequence # of most recently created NAO */
    int				slotList;	/* slot of head of internal "death list" of NAOs */
    Nap_NAO			**lookup;	/* NAO lookup table */
    size_t			lookupSize;	/* size of lookup table */
    size_t			*free;		/* Free stack */
    size_t			freeN;		/* current # entries in Free stack */
    Nap_NAO			**indexBaseCV;	/* CVs of NAO being indexed (NULL if none) */
    int				*indexDimNum;	/* dimension number of indexing */
    int				*braceLevel;	/* nesting level within array constant */
    struct NapClientData_struct	*next;		/* next element in list of these structures */
    m4ForAllDataType(`Nap_NAO	*', `MissingValueNao;') /* standard missing value NAOs */
} NapClientData;

/*
 * Global variables
 */

EXTERN float		napF32NaN;		/* NaN */
EXTERN float		napF32Inf;		/* Infinity */
EXTERN double		napF64NaN;		/* NaN */
EXTERN double		napF64Inf;		/* Infinity */

EXTERN NapClientData	*nap_client_data_new;	/* Most recently created NapClientData structure */

EXTERN int		mixedBase(long n, size_t nbases, long base[], long result[]);
EXTERN int		SAME_f64(double x, double y);
EXTERN int		SAME_f32(float x, float y);
EXTERN char		*Nap_Add(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_And(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_AP(NapClientData *nap_cd, char *str1, char *str2);
EXTERN int		Nap_AppendListElement(NapClientData *nap_cd, char *str);
EXTERN void		Nap_AppendStr(NapClientData *nap_cd, char *str);
EXTERN Nap_PNode	*Nap_AppendToPNodeList(NapClientData *nap_cd, Nap_PNode *head,
				Nap_PNode *new);
EXTERN int		Nap_AppendWords(NapClientData *nap_cd, char *str);
EXTERN int		Nap_AppendLines(NapClientData *nap_cd, char *str);
EXTERN char		*Nap_ArrayConstant(NapClientData *nap_cd, Nap_PNode *list);
EXTERN char		*Nap_Assign(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_Atan2(NapClientData *nap_cd, char *str1, char *str2);
EXTERN int		Nap_AttachCoordVar(NapClientData *nap_cd, Nap_NAO *mainNaoPtr,
				Nap_NAO *coordNaoPtr, char *dimName, int dimNum);
EXTERN int		Nap_AttachCV(NapClientData *nap_cd, Nap_NAO *mainNaoPtr,
				Nap_NAO *coordNaoPtr, int dimNum);
EXTERN int		Nap_AttachLink(NapClientData *nap_cd, Nap_NAO *mainNaoPtr,
				Nap_NAO *linkNaoPtr);
EXTERN char		*Nap_BitAnd(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_BitOr(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_BitXor(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_cart_proj_fwd(NapClientData *nap_cd, Nap_NAO *box_nao);
EXTERN char		*Nap_cart_proj_inv(NapClientData *nap_cd, Nap_NAO *box_nao);
EXTERN char		*Nap_clip2d(NapClientData *nap_cd, Nap_NAO *box_nao);
EXTERN Nap_NAO		*Nap_CastNAO(NapClientData *nap_cd, Nap_NAO *old, Nap_dataType dataType);
EXTERN char		*Nap_Cat(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_Ceil(NapClientData *nap_cd, char *str);
EXTERN char		*Nap_Choice(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_Closest(NapClientData *nap_cd, char *str1, char *str2);
EXTERN void		Nap_CmdDelete(NapClientData *nap_cd);
EXTERN char		*Nap_Complement(NapClientData *nap_cd, char *str);
EXTERN char		*Nap_Copy(NapClientData *nap_cd, char *str1, char *str2);
EXTERN int		Nap_CopyDims(NapClientData *nap_cd, Nap_NAO *srcPtr, Nap_NAO *dstPtr);
EXTERN Nap_NAO		*Nap_CopyNAO(NapClientData *nap_cd, Nap_NAO *old);
EXTERN int		Nap_CopyTrailingDims(NapClientData *nap_cd, Nap_NAO *srcPtr,
				Nap_NAO *dstPtr);
EXTERN void		Nap_CreatePhotoImageFormat(void);
EXTERN NapClientData	*Nap_CreateClientData(Tcl_Interp *interp);
EXTERN void		Nap_CreateStandardMissingValues(NapClientData *nap_cd);
EXTERN Nap_dataType	Nap_DataType2(Nap_dataType t1, Nap_dataType t2);
EXTERN char		*Nap_DataTypeToText(NapClientData *nap_cd, Nap_dataType dataType);
EXTERN void		Nap_DecrRefCount(NapClientData *nap_cd, Nap_NAO *naoPtr);
EXTERN char		*Nap_dilate(NapClientData *nap_cd, Nap_NAO *box_nao);
EXTERN char		*Nap_Div(NapClientData *nap_cd, char *str1, char *str2);
EXTERN Nap_NAO		*Nap_DupNAO(NapClientData *nap_cd, Nap_NAO *old);
EXTERN Nap_NAO		*Nap_DupAllNAO(NapClientData *nap_cd, Nap_NAO *old);
EXTERN char		*Nap_Eq(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_erode(NapClientData *nap_cd, Nap_NAO *box_nao);
EXTERN char		*Nap_expression(NapClientData *nap_cd, Tcl_Obj *obj_expr,
				Nap_NAO *indexBaseCV);
EXTERN int		Nap_F64ScalarValue(NapClientData *nap_cd, Nap_NAO *naoPtr, double *result);
EXTERN size_t		Nap_Find(NapClientData *nap_cd, float v[], size_t n, float x, size_t g);
EXTERN char		*Nap_Floor(NapClientData *nap_cd, char *str);
EXTERN double		Nap_fmod(double x, double y);
EXTERN float		Nap_fmod_f32(float x, float y);
EXTERN void		Nap_FreeNAO(NapClientData *nap_cd, Nap_NAO *naoPtr);
EXTERN void		Nap_FreePNodeTree(NapClientData *nap_cd, Nap_PNode *tree);
EXTERN char		*Nap_Func(NapClientData *nap_cd, char *name, char *str);
EXTERN char		*Nap_Ge(NapClientData *nap_cd, char *str1, char *str2);
EXTERN NapClientData	*Nap_GetClientData(Tcl_Interp *interp);
EXTERN Nap_NAO		*Nap_GetCoordVar(NapClientData *nap_cd, Nap_NAO *naoPtr, int dimNum);
EXTERN double		Nap_GetF64MissingValue(NapClientData *nap_cd, int id);
EXTERN char		*Nap_GetFileName(NapClientData *nap_cd, char *name);
EXTERN char		*Nap_GetMissingValueCharPtr(NapClientData *nap_cd, Nap_NAO *naoPtr);
EXTERN Nap_NAO		*Nap_GetMissingValueNAO(NapClientData *nap_cd, Nap_NAO *naoPtr);
EXTERN Nap_NAO		*Nap_GetNaoFromObj(NapClientData *nap_cd, Tcl_Obj *CONST objPtr);
EXTERN Nap_NAO		*Nap_GetNaoFromId(NapClientData *nap_cd, char *name);
EXTERN char		*Nap_Negate(NapClientData *nap_cd, char *str);
EXTERN char		*Nap_GetNaoIdFromId(NapClientData *nap_cd, char *name);
EXTERN Nap_NAO		*Nap_GetNumericNaoFromId(NapClientData *nap_cd, char *name);
EXTERN int		Nap_GetStringLengthFromObj(Tcl_Obj *CONST objPtr);
EXTERN char		*Nap_GreaterOf(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_Gt(NapClientData *nap_cd, char *str1, char *str2);
EXTERN size_t		Nap_HuntF32(NapClientData *nap_cd, float v[], size_t n, float x, size_t g);
EXTERN size_t		Nap_HuntNao(NapClientData *nap_cd, Nap_NAO *nao_ptr, void *x_ptr, size_t g);
EXTERN char		*Nap_Hypot(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_Identity(NapClientData *nap_cd, char *str);
EXTERN char		*Nap_Indirect(NapClientData *nap_cd, int op, char *str);
EXTERN void		Nap_IncrRefCount(NapClientData *nap_cd, Nap_NAO *naoPtr);
EXTERN char		*Nap_Index(NapClientData *nap_cd, char *str1, char *str2);
EXTERN float		Nap_IndexOfNao(NapClientData *nap_cd, Nap_NAO *nao_ptr,
				void *x_ptr, float g);
EXTERN char		*Nap_IndexOf2(NapClientData *nap_cd, char *str1, char *str2);
EXTERN void		Nap_InitTclResult(NapClientData *nap_cd);
EXTERN char		*Nap_InnerProd(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_inPolygon(NapClientData *nap_cd, Nap_NAO *box_nao);
EXTERN void		Nap_InterpDeleteProc(ClientData clientData, Tcl_Interp *interp);
EXTERN int		Nap_IsNAO(NapClientData *nap_cd, Nap_NAO *naoPtr);
EXTERN char 		*Nap_isort(NapClientData *nap_cd, char *str1, int is_ascending);
EXTERN char		*Nap_Laminate(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_Le(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_LesserOf(NapClientData *nap_cd, char *str1, char *str2);
EXTERN int		Nap_lex(Nap_stype *lvalp, NapClientData	*nap_cd);
EXTERN size_t		Nap_lexID(char *str);
EXTERN size_t		Nap_lexName(char *str);
EXTERN size_t		Nap_lexSimpleName(char *str);
EXTERN char		*Nap_Link(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_Link2(NapClientData *nap_cd, char *str1, char *str2);
EXTERN long		Nap_lmod(long x, long y);
EXTERN char		*Nap_Log(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_Lt(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_Match(NapClientData *nap_cd, char *str1, char *str2);
EXTERN double		Nap_MaxOf(Nap_dataType dataType);
EXTERN double		Nap_MinOf(Nap_dataType dataType);
EXTERN int		Nap_mod(int x, int y);
EXTERN char		*Nap_moving_range(NapClientData *nap_cd, Nap_NAO *box_nao);
EXTERN char		*Nap_Mul(NapClientData *nap_cd,  char *str1, char *str2);
EXTERN int		Nap_NE_f32(float x, float y);
EXTERN int		Nap_NE_f64(double x, double y);
EXTERN char		*Nap_Ne(NapClientData *nap_cd, char *str1, char *str2);
EXTERN Nap_Number	Nap_NegateNumber(NapClientData *nap_cd, Nap_Number n);
EXTERN Nap_PNode	*Nap_NewExprPNode(NapClientData *nap_cd, 
				Nap_PNode *left, int token, Nap_PNode *right);
EXTERN Nap_PNode	*Nap_NewListPNode(NapClientData *nap_cd, char *repCount, Nap_PNode *list);
EXTERN Nap_PNode	*Nap_NewNamePNode(NapClientData *nap_cd, char *name);
EXTERN Nap_PNode	*Nap_NewNaoPNode(NapClientData *nap_cd, char *naoID);
EXTERN Nap_NAO		*Nap_NewNAO(NapClientData *nap_cd, Nap_dataType dataType, int rank,
				size_t *shape);
EXTERN Nap_NAO		*Nap_NewScalarNAO(NapClientData *nap_cd, Nap_dataType dataType,
				double value);
EXTERN Nap_PNode	*Nap_NewValuePNode(NapClientData *nap_cd, char *repCount,
				Nap_Number number);
EXTERN char		*Nap_Niladic(NapClientData *nap_cd, int op);
EXTERN char		*Nap_Not(NapClientData *nap_cd, char *str);
EXTERN int		Nap_OilNao(Nap_NAO *nao_ptr);
EXTERN char		*Nap_Or(NapClientData *nap_cd, char *str1, char *str2);
EXTERN int		Nap_ObjectCommand(ClientData clientData,
				Tcl_Interp *interp, int objc,
				Tcl_Obj *CONST objv[]);
EXTERN char		*Nap_pad(NapClientData *nap_cd, char *str1, char *str2);
EXTERN int		Nap_parse(void *Nap_param); /* Defined in napParse.y */
EXTERN char		*Nap_Power(NapClientData *nap_cd, char *str1, char *str2);
EXTERN Nap_NAO		*Nap_Promote(NapClientData *nap_cd, Nap_NAO *naoPtr,
				Nap_dataType minDataType, int minRank, size_t *altShape);
EXTERN Nap_NAO		*Nap_Reduce(NapClientData *nap_cd, char *name, Nap_NAO *naoPtr,
				Nap_NAO *verbRankNaoPtr);
EXTERN char		*Nap_Rem(NapClientData *nap_cd, char *str1, char *str2);
EXTERN Nap_NAO		*Nap_ReshapeNAO(NapClientData *nap_cd, Nap_NAO *old,
				Nap_dataType dataType, int rank, size_t *shape);
EXTERN Nap_NAO		*Nap_ReshapeNAO2(NapClientData *nap_cd, Nap_NAO *old,
				Nap_dataType dataType, int rank, size_t *shape,
				int want_text, int want_dims, int want_mv);
EXTERN Nap_NAO		*Nap_ReshapeNAO_trailing(NapClientData *nap_cd, Nap_NAO *old,
				Nap_dataType dataType, int rank, size_t *shape);
EXTERN char		*Nap_Round(NapClientData *nap_cd, char *str);
EXTERN char		*Nap_ScalarConstant(NapClientData *nap_cd, Nap_Number n);
EXTERN int		Nap_SetDimName(NapClientData *nap_cd, Nap_NAO *mainNaoPtr, char *dimName,
				int dimNum);
EXTERN int		Nap_SetMissing(NapClientData *nap_cd, Nap_NAO *np, int missingValueSlot);
EXTERN char		*Nap_SetParseResult(NapClientData *nap_cd, Nap_PNode *expr);
EXTERN void		Nap_SetTclResult(NapClientData *nap_cd);
EXTERN char		*Nap_ShiftLeft(NapClientData *nap_cd, char *str1, char *str2);
EXTERN char		*Nap_ShiftRight(NapClientData *nap_cd, char *str1, char *str2);
EXTERN int		Nap_SizeOf(Nap_dataType dataType);
EXTERN Nap_NAO		*Nap_StandardMissingValueNAO(NapClientData *nap_cd, Nap_dataType dataType);
EXTERN char		*Nap_StrCat(NapClientData *nap_cd, char *str1, ...);
EXTERN char		*Nap_StrDup0(NapClientData *nap_cd, const char *file, const int line, 
				CONST char *str);
EXTERN char		Nap_StrTail(char *string);
EXTERN int		Nap_StrTailMatch(char *string, char *tail);
EXTERN int		Nap_StrToDimNum(NapClientData *nap_cd, Nap_NAO *naoPtr, char *str);
EXTERN char		*Nap_StringConstant(NapClientData *nap_cd, char *str);
EXTERN int		Nap_StringToNumber(NapClientData *nap_cd, char *str, Nap_Number *result);
EXTERN char		*Nap_Sub(NapClientData *nap_cd, char *str1, char *str2);
EXTERN int		Nap_Substitute(NapClientData *nap_cd, char *expr, char **pnew);
EXTERN char		*Nap_Subscript(NapClientData *nap_cd, char *str1, char *str2);
EXTERN int		Nap_swap_bytes(NapClientData *nap_cd, char *a, int n, int size); 
EXTERN char		*Nap_Tally(NapClientData *nap_cd, char *str);
EXTERN char		*Nap_TclGetVar(NapClientData *nap_cd, char *name);
EXTERN char		*Nap_Triangulate(NapClientData *nap_cd, Nap_NAO *box_nao);
EXTERN char		*Nap_TriangulateEdges(NapClientData *nap_cd, Nap_NAO *box_nao);
EXTERN Nap_dataType	Nap_TextToDataType(char *str);

EXTERN Nap_NAO		*Nap_UnboxedElement1(NapClientData *nap_cd, Nap_NAO *naoPtr);

m4define(`m4indexOf', `
EXTERN float
Nap_IndexOf`$1'(
    NapClientData		*nap_cd,
    m4DataTypeName(`$1')	v[],
    size_t			n,
    m4DataTypeName(`$1')	x,
    float			g);')

m4ForAllNumericDataType(`m4indexOf(', `)')

#endif /* _NAP */
