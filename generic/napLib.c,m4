m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (napLib.c) */
/* It was produced from source file napLib.c,m4 */

/* 
 *	napLib.c,m4 --
 *
 *	Copyright 1998, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napLib.c,m4,v 1.198 2005/03/07 05:48:26 dav480 Exp $";
#endif /* not lint */

#include <float.h>
#include "nap_hdf.h"

#define PR_MALLOC       /*  Do   print MALLOC info */
#undef  PR_MALLOC       /* Don't print MALLOC info */

#define PR_NAO_ALLOC    /*  Do   print info on creation/deletion of NAOs */
#undef  PR_NAO_ALLOC    /* Don't print info on creation/deletion of NAOs */

#define CKALLOC(N) ckalloc(N)
#define CKFREE(P) if (P) ckfree(P)

#define RESULT_BS0 4096		/* Initial size of result-buffer for Tcl result */


/*
 * Global variables
 */

DLLEXPORT float		napF32NaN;		/* NaN */
DLLEXPORT float		napF32Inf;		/* Infinity */
DLLEXPORT double	napF64NaN;		/* NaN */
DLLEXPORT double	napF64Inf;		/* Infinity */

/*
 * Most recently created NapClientData structure
 */

DLLEXPORT NapClientData	*nap_client_data_new = NULL;

/*
 * Nap_CheckAppendLine --
 *
 * Called by Nap_Check to append line to message.
 */

m4define(`m4NAME', `Nap_CheckAppendLine')

EXTERN void
Nap_CheckAppendLine(
    NapClientData       *nap_cd,
    const char		*str)		/* string to append */
{
    size_t		n1;
    size_t		n2;

    assert(str);
    n1 = strlen(nap_cd->message);
    n2 = strlen(str);
    if (n2 > 0  &&  n1+n2 < NAP_MAX_MESSAGE_LENGTH) {
	if (n1 > 0) {
	    (void) strcpy(nap_cd->message+n1, "\n");
	    ++n1;
	}
	(void) strcpy(nap_cd->message+n1, str);
    }
}

/*
 * Nap_Check --
 *
 * Error handler
 *
 * Before command is executed, message should be initialised to "".
 * Each time Nap_Check is called it appends message to message (if room).
 * If outside parser (parseLevel < 0) then Nap_Check sets Tcl result to
 * message.
 */

m4define(`m4NAME', `Nap_Check')

EXTERN void
Nap_Check(
    NapClientData       *nap_cd,
    const char          *file,                  /* name of source file */
    const int           line,                   /* line # in source file */
    const char		*format,                /* format of message */
    ...)
{
    va_list             argPtr;                 /* variable-arg pointer */
    char		*endLine;               /* pointer to end of line */
    int			i;			/* subscript */
    int			level;			/* parse level */
    char		s[NAP_MAX_MESSAGE_LENGTH]; /* temp string */
    char		saveChar;               /* '\n' or '\0' at end */
    char		*startLine;             /* pointer to start of line */
    int			status;

    assert(file);
    assert(format);
    level = nap_cd->parseLevel;
    assert(level < nap_cd->recursionLimit);
    if (level >= 0) {
	assert(nap_cd->scanString[level]);
	startLine = nap_cd->scanString[level];
	while (startLine  &&  *(startLine-1) != '\n') {
	    startLine = nap_cd->scanString[level]-startLine < 200
		    ? startLine-1 : NULL;
	}
	if (startLine) {
	    endLine = startLine;
	    while (endLine  &&  *endLine  &&  *endLine != '\n') {
		endLine = endLine-nap_cd->scanString[level] < 200
			? endLine+1 : NULL;
	    }
	} else {
	    endLine = NULL;
	}
	if (endLine) {
	    saveChar = *endLine;
	    *endLine = '\0';
	    Nap_CheckAppendLine(nap_cd, startLine);
	    i = nap_cd->scanString[level] - startLine;
	    status = sprintf(s, "%*s", i, "^");
	    assert(status > 0  &&  status < NAP_MAX_MESSAGE_LENGTH);
	    Nap_CheckAppendLine(nap_cd, s);
	    *endLine = saveChar;
	} else {
	    Nap_CheckAppendLine(nap_cd, "m4NAME: Error generating error message. "
		    "Input line too long!");
	    status = sprintf(s, "%200s", startLine);
	    assert(status > 0  &&  status < NAP_MAX_MESSAGE_LENGTH);
	    Nap_CheckAppendLine(nap_cd, s);
	}
    }
    va_start(argPtr, format) ;
    status = vsprintf(s, format, argPtr) ;
    assert(status < NAP_MAX_MESSAGE_LENGTH);
    va_end(argPtr);
    Nap_CheckAppendLine(nap_cd, s);
#ifndef NDEBUG
    status = sprintf(s, "Error at line %i of file %s", line, file);
    assert(status > 0  &&  status < NAP_MAX_MESSAGE_LENGTH);
    Nap_CheckAppendLine(nap_cd, s);
#endif
    if (level < 0) {
	Tcl_SetResult(nap_cd->interp, nap_cd->message, TCL_STATIC);
    }
}
m4begin

m4define(`m4Nap_DataTypeToText', `
        case m4DataTypeEnum($1):
            result = Nap_StrDup("m4LowerCase($1)");
            break;')

m4define(`m4Nap_TextToDataType', `
    } else if (strcmp(str, "m4LowerCase($1)") == 0) {
        result = m4DataTypeEnum($1);')

m4define(`m4sizeof', `
        case m4DataTypeEnum($1):        return sizeof(m4DataTypeName($1));')
m4define(`m4maxof', `
        case m4DataTypeEnum($1):	return m4DataTypeEnum($1)_MAX;')
m4define(`m4minof', `
        case m4DataTypeEnum($1):	return m4DataTypeEnum($1)_MIN;')
m4define(`m4nap2hdf', `
        case m4DataTypeEnum($1):   return m4DataTypeEnum($1)_HDF_DATA_TYPE;')
m4define(`m4hdf2nap', `
        if (dataType == m4DataTypeEnum($1)_HDF_DATA_TYPE) {
	    return m4DataTypeEnum($1);
	}')

m4end


/*
 *  SAME_f64 --
 *
 *  Test whether double arguments are equal or both NaN.
 */

EXTERN int
SAME_f64(
    double	x,
    double	y)
{
    int		x_is_nan = IsNaN64(x);
    int		y_is_nan = IsNaN64(y);
    int		result;

    if (x_is_nan) {
	result = y_is_nan;
    } else {
	if (y_is_nan) {
	    result = 0;
	} else {
	    result = x == y;
	}
    }
    return result;
}


/*
 *  SAME_f32 --
 *
 *  Test whether float arguments are equal or both NaN.
 */

EXTERN int
SAME_f32(
    float	x,
    float	y)
{
    int		x_is_nan = IsNaN32(x);
    int		y_is_nan = IsNaN32(y);
    int		result;

    if (x_is_nan) {
	result = y_is_nan;
    } else {
	if (y_is_nan) {
	    result = 0;
	} else {
	    result = x == y;
	}
    }
    return result;
}


/*
 *  Nap_StrTail --
 *      Final character of string.
 *      Nap_StrTail(NULL) & Nap_StrTail("") return '\0'.
 */

EXTERN char
Nap_StrTail(
    char                *string)
{
    size_t              n;
    char                result;

    result = '\0';
    if (string) {
        n = strlen(string);
        if (n != 0U) {
            result = string[n-1];
        }
    }
    return result;
}


/*
 *  Nap_StrTailMatch --
 *      Does tail of <string> match <tail>?
 */

EXTERN int
Nap_StrTailMatch(
    char                *string,
    char                *tail)
{
    size_t              n_string;
    size_t              n_tail;
    int			result;

    result = 0;
    if (string && tail) {
        n_string = strlen(string);
        n_tail = strlen(tail);
	if (n_string >= n_tail) {
	    result = strcmp(string + n_string - n_tail, tail) == 0;
	}
    }
    return result;
}


/*
 * Nap_mod --
 *
 *  Nap_mod(x,y) is like mod(x,y), except that (even if x <= 0):
 *  If y <  0 then y < result <= 0
 *  If y == 0 then result == 0
 *  If y >  0 then 0 <= result < y
 */

EXTERN int
Nap_mod(
    int         x,
    int         y)
{
    int         result;

    if (y == 0) {
	result = 0;
    } else {
	result = x % y;
	if (y > 0 && result < 0  ||  y < 0 && result > 0) {
	    result += y;
	}
    }
    return result;
}

/*
 * Nap_lmod --
 *
 * long version of Nap_mod
 */

EXTERN long
Nap_lmod(
    long	x,
    long	y)
{
    long	result;

    if (y == 0) {
	result = 0;
    } else {
	result = x % y;
	if (y > 0 && result < 0  ||  y < 0 && result > 0) {
	    result += y;
	}
    }
    return result;
}

/*
 * Nap_fmod --
 *
 *  Nap_fmod(x,y) is like fmod(x,y), except that (even if x <= 0):
 *  If y <  0 then y < result <= 0
 *  If y == 0 then result == 0
 *  If y >  0 then 0 <= result < y
 *
 *  Note the need to be careful with rounding error to ensure these are true
 */

EXTERN double
Nap_fmod(
    double      x,
    double      y)
{
    double      result;

    if (y == 0.0) {
	result = 0.0;
    } else {
	result = fmod(x, y);
	if (y > 0.0) {
	    if (result < 0.0) {
		result += y;
	    }
	    if (result > y * (1.0 - DBL_EPSILON)) {
		result = 0.0;
	    }
	} else {
	    if (result > 0.0) {
		result += y;
	    }
	    if (result < y * (1.0 - DBL_EPSILON)) {
		result = 0.0;
	    }
	}
    }
    return result;
}

/*
 * Nap_fmod_f32 --
 *
 *  Nap_fmod_f32(x,y) is like Nap_fmod, except that float rather than double
 */

EXTERN float
Nap_fmod_f32(
    float	x,
    float	y)
{
    float	result;

    if (y == 0.0f) {
	result = 0.0f;
    } else {
	result = fmod(x, y);
	if (y > 0.0f) {
	    if (result < 0.0f) {
		result += y;
	    }
	    if (result > y * (1.0f - FLT_EPSILON)) {
		result = 0.0f;
	    }
	} else {
	    if (result > 0.0f) {
		result += y;
	    }
	    if (result < y * (1.0f - FLT_EPSILON)) {
		result = 0.0f;
	    }
	}
    }
    return result;
}

/*
 * Nap_NE_f64 --
 *
 *      Tests whether x != y.
 *      Called by macro IsNaN64
 */

EXTERN int
Nap_NE_f64(
    double	x,
    double	y)
{
    return x != y;
}

/*
 * Nap_NE_f32 --
 *
 *      Tests whether x != y.
 *      Called by macro IsNaN32
 */

EXTERN int
Nap_NE_f32(
    float	x,
    float	y)
{
    return x != y;
}

/*
 * Nap_DataTypeToText --
 *
 *      Convert data-type to text
 *      Return NULL if error.
 */

EXTERN char *
Nap_DataTypeToText(
    Nap_dataType        dataType)
{
    char                *result;

    switch (dataType) {
        m4ForAllDataType(`m4Nap_DataTypeToText(', `)')
        default:
            result = NULL;
    }
    return result;
}

/*
 * Nap_GetFileName --
 *
 *      If name is that of tcl variable then use it recursively.
 *      Otherwise remove any enclosing apostophes (') and treat as filename.
 *      Do tilde substitution.
 *      Treat name commencing with "http://" as URL & return as is.
 *      Return NULL for error.
 */

EXTERN char *
Nap_GetFileName(
    NapClientData       *nap_cd,
    char                *name)          /* name of tcl variable or file */
{
    int                 count;          /* levels of indirection */
    Tcl_DString         ds;             /* dynamic string buffer */
    char                *fullName;
    Tcl_Interp          *interp;
    char                *result;
    char                *oldName;

    if (!name) {
        return NULL;
    }
    for (count = 1; name; ++count) {
        if (count > NAP_MAX_LEVEL) {
            return NULL;
        }
        oldName = name;
        name = (char *) Tcl_GetVar(nap_cd->interp, oldName, 0);
    }
    if (oldName[0] == '\''  &&  Nap_StrTail(oldName) == '\'') {
        name = Nap_StrDup(oldName+1);
        name[strlen(name)-1] = '\0';
    } else {
        name = Nap_StrDup(oldName);
    }
    if (isPrefixOf("http://" , name)) {
	result = name;
    } else {
	interp = Tcl_CreateInterp();
	fullName = Tcl_TranslateFileName(interp, name, &ds);
	if (fullName) {
	    result = Nap_StrDup(fullName);
	    Tcl_DStringFree(&ds);
	} else {
	    result = NULL;
	}
	Tcl_DeleteInterp(interp);
	FREE(name);
    }
    return result;
}

/*
 * Nap_TextToDataType --
 *
 *      Convert text to data-type
 */

Nap_dataType
Nap_TextToDataType(
    char                *str)
{
    Nap_dataType        result;

    if (!str) {
        result = NAP_NULL_TYPE;
    m4ForAllDataType(`m4Nap_TextToDataType(', `)')
    } else {
        result = NAP_NULL_TYPE;
    }
    return result;
}

/*
 * Nap_Alloc --
 *	Allocate memory from heap.
 */

EXTERN void *
Nap_Alloc(
    size_t		size)
{
    int			n;
    char		*p;

    n = Max(1, size);
    p = ckalloc(n);
#ifdef PR_MALLOC
    printf("Nap_Alloc: %p %d bytes\n", p, n);
#endif /* PR_MALLOC */
    return (void *) p;
}

/*
 * Nap_Alloc0 --
 *	Allocate memory from heap and set it to zero.
 */

EXTERN void *
Nap_Alloc0(
    size_t		size)
{
    int			i;
    int			n;
    char		*p;

    n = Max(1, size);
    p = ckalloc(n);
#ifdef PR_MALLOC
    printf("Nap_Alloc0: %d bytes from %p\n", n, p);
#endif /* PR_MALLOC */
    for (i = 0; i < n; i++) {
	p[i] = 0;
    }
    return (void *) p;
}

/*
 * Nap_Realloc --
 *	Allocate memory from heap.
 */

EXTERN void *
Nap_Realloc(
    void		*p,
    size_t		size)
{
    int			n;
    char		*result;

    n = Max(1, size);
    result = ckrealloc(p, n);
#ifdef PR_MALLOC
    printf("Nap_Realloc: %d bytes from %p\n", n, result);
#endif /* PR_MALLOC */
    return (void *) result;
}

/*
 * Nap_Free --
 */

EXTERN void
Nap_Free(
    void            *p)
{
    if (p) {
#ifdef PR_MALLOC
	printf("Nap_Free: %p\n", p);
#endif /* PR_MALLOC */
        ckfree((char *) p);
    }
}

/*
 * Nap_SizeOf --
 *	number of bytes of specified data type.
 */

EXTERN int
Nap_SizeOf(
    Nap_dataType	dataType)
{
    switch (dataType) {
	m4ForAllDataType(`m4sizeof(', `)')
	default: 		assert(FALSE);	/* error */
    }
    return -1;
}

/*
 * Nap_MaxOf --
 *	Max value of specified data type.
 */

EXTERN double
Nap_MaxOf(
    Nap_dataType	dataType)
{
    switch (dataType) {
	m4ForAllDataType(`m4maxof(', `)')
	default: 		assert(FALSE);	/* error */
    }
    return 0.0;
}

/*
 * Nap_MinOf --
 *	Min value of specified data type.
 */

EXTERN double
Nap_MinOf(
    Nap_dataType	dataType)
{
    switch (dataType) {
	m4ForAllDataType(`m4minof(', `)')
	default: 		assert(FALSE);	/* error */
    }
    return 0.0;
}

/*
 * Nap_Nap2HdfDataType --
 *
 *	Convert nap data-type to HDF data-type.
 *	If argument is NAP_RAGGED, NAP_BOXED or NAP_NULL_TYPE then result is
 *	DFNT_NONE.  This is also result if error.
 */

EXTERN int32
Nap_Nap2HdfDataType(
    Nap_dataType	dataType)
{
    switch (dataType) {
	m4ForAllUnboxedDataType(`m4nap2hdf(', `)')
	default: 		return DFNT_NONE;
    }
}

/*
 * Nap_Hdf2NapDataType --
 *
 *	Convert HDF data-type to nap data-type.
 *	If error then result is NAP_NULL_TYPE.
 */

EXTERN Nap_dataType
Nap_Hdf2NapDataType(
    int32		dataType)
{
    m4ForAllUnboxedDataType(`m4hdf2nap(', `)')
    return NAP_NULL_TYPE;
}

/*
 * Nap_StrDup --
 *      My version of strdup (which is non-standard, though commonly available).
 *      If error return NULL.
 */

EXTERN char *
Nap_StrDup(
    CONST char *src)
{
    char        *dest;

    if (src) {
        dest = (char *) MALLOC(strlen(src) + 1);
        if (dest) {
            (void) strcpy(dest, src);
	}
    } else {
        dest = NULL;
    }
    return dest;
}

/*
 * Nap_StrCat --
 *      Concatenate 0 or more strings.
 *	Usage:  Nap_StrCat(str1, str2, str3, ..., NULL);
 *      Result is malloc string.
 */

EXTERN char *
Nap_StrCat(
    char *str1, 
    ...)
{
    va_list		ap;		/* unnmamed argument pointer */
    Tcl_DString		ds;		/* dynamic string */
    char		*result;	/* final result pointer */
    char		*strPtr;	/* temp. string pointer */

    Tcl_DStringInit(&ds);
    va_start(ap, str1);
    for (strPtr = str1; strPtr; strPtr = va_arg(ap, char *)) {
	(void) Tcl_DStringAppend(&ds, strPtr, -1);
    }
    va_end(ap);
    strPtr = Tcl_DStringValue(&ds);
    result = Nap_StrDup(strPtr);
    Tcl_DStringFree(&ds);
    return result;
}

/*
 *  Nap_InitTclResult --
 *  Initialise tcl result buffer.
 */

EXTERN void
Nap_InitTclResult(
    NapClientData	*nap_cd)
{
    nap_cd->result_bs = RESULT_BS0;
    nap_cd->result = (char *) MALLOC(nap_cd->result_bs);
    nap_cd->result_n = 0;
}

/*
 *  Nap_SetTclResult --
 *  Set tcl result to contents of tcl result buffer.
 *  Use system encoding (default iso8859-1 code).
 */

EXTERN void
Nap_SetTclResult(
    NapClientData	*nap_cd)
{
    Tcl_DString		ds;			/* dynamic string */

    Tcl_ExternalToUtfDString(NULL, nap_cd->result, nap_cd->result_n, &ds);
    Tcl_DStringResult(nap_cd->interp, &ds);
    FREE(nap_cd->result);
    nap_cd->result = NULL;
    nap_cd->result_bs = 0;
    nap_cd->result_n = 0;
}

/*
 *  Nap_AppendStr --
 *  Append string to tcl result buffer.
 *  If str is NULL or empty do nothing.
 */

EXTERN void
Nap_AppendStr(
    NapClientData	*nap_cd,
    char		*str)
{
    if (str) {
	while (*str) {
	    if (nap_cd->result_n == nap_cd->result_bs) {
		nap_cd->result_bs *= 2;
		nap_cd->result = (char *) REALLOC(nap_cd->result, nap_cd->result_bs);
	    }
	    nap_cd->result[(nap_cd->result_n)++] = *(str++);
	}
    }
}

/*
 *  Nap_AppendWords --
 *  Append string to tcl result buffer (with prefixed space if not start of line).
 *  If str is NULL do nothing.
 */

EXTERN int
Nap_AppendWords(
    NapClientData	*nap_cd,
    char		*str)
{
    if (str) {
	if (nap_cd->result_n > 0) {
	    if (nap_cd->result[nap_cd->result_n - 1] != '\n') {
		Nap_AppendStr(nap_cd, " ");
	    }
	}
	Nap_AppendStr(nap_cd, str);
    }
    return TCL_OK;
}

/*
 *  Nap_AppendLines --
 *  Append string to tcl result buffer (with prefixed newline if old result not empty).
 *  If str is NULL do nothing.
 */

EXTERN int
Nap_AppendLines(
    NapClientData	*nap_cd,
    char		*str)
{
    if (str) {
	if (nap_cd->result_n > 0) {
	    Nap_AppendStr(nap_cd, "\n");
	}
	Nap_AppendStr(nap_cd, str);
    }
    return TCL_OK;
}

/*
 *  Nap_AppendListElement --
 *  Append string (treated as list element) to tcl result buffer
 *  If str is NULL do nothing.
 */

EXTERN int
Nap_AppendListElement(
    NapClientData	*nap_cd,
    char		*str)
{
    Tcl_Obj		*objResult;		/* Tcl result as object */
    Tcl_Obj		*objStr;		/* str as object */
    int                 status;
    char		*strResult;

    if (str) {
	objStr = Tcl_NewStringObj(str, -1);
	Tcl_IncrRefCount(objStr);
	objResult = Tcl_NewStringObj(nap_cd->result, nap_cd->result_n);
	Tcl_IncrRefCount(objResult);
	status = Tcl_ListObjAppendElement(nap_cd->interp, objResult, objStr);
	strResult = Tcl_GetString(objResult); 
	nap_cd->result_n = 0;
	Nap_AppendStr(nap_cd, strResult);
	Tcl_DecrRefCount(objStr);
	Tcl_DecrRefCount(objResult);
    }
    return TCL_OK;
}

/*
 * Nap_GetNaoFromId --
 *
 * Get nao corresponding to nao ID, tcl variable-name or other NAP expression.
 * If it is tcl variable-name then value can also be nao ID, tcl variable-name
 * or other NAP expression.  Allow up to 8 levels of such indirection.
 *
 *	If error return NULL.
 */

m4define(`m4NAME', `Nap_GetNaoFromId')

EXTERN Nap_NAO *
Nap_GetNaoFromId(
    NapClientData	*nap_cd,
    char                *name)		/* nao ID, tcl variable-name or expr */
{
    int			count;		/* levels of indirection */
    Tcl_CmdInfo         infoPtr;
    const int		maxLevel = 8;	/* max. # levels of indirection */
    size_t		n;		/* previous length of error message */
    Nap_NAO             *result;
    CONST char		*str;
    int                 status;

    name = Nap_StrDup(name);
    count = 0;
    while (name && Nap_lexID(name) != strlen(name)) {
	if (++count > maxLevel) {
	    FREE(name);
	    name = NULL;
	} else if (Nap_lexName(name) == strlen(name)) {
	    str = Tcl_GetVar(nap_cd->interp, name, 0);
	    FREE(name);
	    if (str) {
		name = Nap_StrDup(str);
	    } else {
		name = NULL;
	    }
	} else {
	    str = Nap_StrCat("nap \"", name, "\"", NULL);
	    FREE(name);
	    n = strlen(nap_cd->message);
	    status = Tcl_Eval(nap_cd->interp, str);
	    if (status == TCL_OK) {
		name = Nap_StrDup(Tcl_GetStringResult(nap_cd->interp));
	    } else {
		name = NULL;
	    }
	    FREE(str);
	    nap_cd->message[n] = '\0';
	}
    }
    status = name ? Tcl_GetCommandInfo(nap_cd->interp, name, &infoPtr) : 0;
    if (status) {
	result = (Nap_NAO *) infoPtr.objClientData;
	assert(Nap_IsNAO(nap_cd, result));
    } else {
	result = NULL;
    }
    FREE(name);
    return result;
}

/*
 * Nap_GetNumericNaoFromId --
 *
 * Like Nap_GetNaoFromId except that if dataType == NAP_RAGGED then pad to
 * make numeric.
 *
 *	If error or other non-numeric return NULL.
 */

m4define(`m4NAME', `Nap_GetNumericNaoFromId')

EXTERN Nap_NAO *
Nap_GetNumericNaoFromId(
    NapClientData	*nap_cd,
    char                *name)		/* nao ID, tcl variable-name or expr */
{
    Nap_NAO             *naoPtr;
    char		*str;

    naoPtr = Nap_GetNaoFromId(nap_cd, name);
    if (naoPtr  &&  naoPtr->dataType == NAP_RAGGED) {
        str = Nap_Func(nap_cd, "pad", naoPtr->id);
        Nap_FreeNAO(nap_cd, naoPtr);
        naoPtr = Nap_GetNaoFromId(nap_cd, str);
    }
    return naoPtr;
}

/*
 * Nap_GetNumericNaoFromSlot --
 *
 * Like Nap_GetNaoFromSlot except that if dataType == NAP_RAGGED then pad to
 * make numeric.
 *
 *	If error or other non-numeric return NULL.
 */

m4define(`m4NAME', `Nap_GetNumericNaoFromSlot')

Nap_NAO *
Nap_GetNumericNaoFromSlot(
    NapClientData	*nap_cd,
    size_t              slot)		/* nao slot no. */
{
    Nap_NAO             *naoPtr;
    char		*str;

    naoPtr = Nap_GetNaoFromSlot(slot);
    if (naoPtr  &&  naoPtr->dataType == NAP_RAGGED) {
        str = Nap_Func(nap_cd, "pad", naoPtr->id);
        Nap_FreeNAO(nap_cd, naoPtr);
        naoPtr = Nap_GetNaoFromId(nap_cd, str);
    }
    return naoPtr;
}

/*
 * Nap_GetNaoFromObj --
 *
 *	Get nao corresponding to Tcl object.
 *
 *	If error return NULL.
 */

m4define(`m4NAME', `Nap_GetNaoFromObj')

Nap_NAO *
Nap_GetNaoFromObj(
    NapClientData	*nap_cd,
    Tcl_Obj *CONST	objPtr)
{
    Nap_NAO             *naoPtr;
    char                *str;

    str = Tcl_GetStringFromObj(objPtr, NULL);
    if (str && *str) {
	naoPtr = Nap_GetNaoFromId(nap_cd, str);
	assert(!naoPtr  ||  Nap_IsNAO(nap_cd, naoPtr));
    } else {
	naoPtr = NULL;
    }
    return naoPtr;
}

/*
 * Nap_StandardMissingValueNAO --
 *
 *      Return pointer to standard missing value NAO for data type.
 *	If error return NULL.
 */

m4begin

m4define(`m4NAME', `Nap_StandardMissingValueNAO')

m4define(`m4missingNAO', `
	    case m4DataTypeEnum($1):
		result = nap_cd->`$1'MissingValueNao;
		break;')

m4end

Nap_NAO* 
Nap_StandardMissingValueNAO(
    NapClientData	*nap_cd,
    Nap_dataType	dataType)
{
    Nap_NAO             *result = NULL;

    switch (dataType) {
    m4ForAllDataType(`m4missingNAO(', `)')
    default:            /* error */
	assert(FALSE);
    }
    return result;
}

/*
 * Nap_GetMissingValueNAO --
 *
 *	Return pointer to missing value NAO corresponding to specified NAO.
 *	If missingValueSlot is 0 then return pointer to standard missing value
 *	NAO for data type.
 *	If error return NULL.
 */

m4define(`m4NAME', `Nap_GetMissingValueNAO')

Nap_NAO* 
Nap_GetMissingValueNAO(
    NapClientData	*nap_cd,
    Nap_NAO		*naoPtr)
{
    Nap_NAO             *result = NULL;
    Nap_NAO             *tmp_nao;

    if (naoPtr) {
	if (naoPtr->missingValueSlot > 0) {
	    tmp_nao = Nap_GetNaoFromSlot(naoPtr->missingValueSlot);
	    result = Nap_CastNAO(nap_cd, tmp_nao, naoPtr->dataType);
	    if (result != tmp_nao) {
		Nap_FreeNAO(nap_cd, tmp_nao);
	    }
	} else {
	    result = Nap_StandardMissingValueNAO(nap_cd, naoPtr->dataType);
	}
    }
    return result;
}

/*
 * Nap_GetStringLengthFromObj --
 *
 *	Get length of string in Tcl object.
 *
 *	If error return NULL.
 */

m4define(`m4NAME', `Nap_GetStringLengthFromObj')

EXTERN int
Nap_GetStringLengthFromObj(
    Tcl_Obj *CONST	objPtr)
{
    int			result;
    char                *str;

    assert(objPtr);
    str = Tcl_GetStringFromObj(objPtr, &result);
    assert(str);
    return result;
}

/*
 * Nap_GetCoordVar --
 *
 *	Get coordinate variable nao corresponding to specified dimension of 
 *	specified parent nao.
 *
 *	If error return NULL.
 */

Nap_NAO *
Nap_GetCoordVar(
    NapClientData       *nap_cd,
    Nap_NAO		*naoPtr, 	/* Parent NAO */
    int			i)		/* Dimension number 0,1,2,.. (rank-1) */
{
    Nap_NAO             *result = NULL;

    if (naoPtr && i >= 0 && i < naoPtr->rank && naoPtr->coordVarSlot[i]) {
	assert(naoPtr->id);
	assert(Nap_IsNAO(nap_cd, naoPtr));
        result = Nap_GetNaoFromSlot(naoPtr->coordVarSlot[i]);
    }
    return result;
}

/*
 * Nap_TclGetVar --
 *
 *	Interface to Tcl_GetVar
 *	If error return name.
 */

EXTERN char *
Nap_TclGetVar(
    NapClientData       *nap_cd,
    char		*name)		/* name of tcl variable */
{
    char		*result;

    result = (char *) Tcl_GetVar(nap_cd->interp, name, 0);
    if (! result) {
	result = name;
    }
    result = Nap_StrDup(result);
    return result;
}

m4define(`m4NAME', `Nap_SetParseResult')

EXTERN char *
Nap_SetParseResult(
    NapClientData	*nap_cd,
    char		*str)		/* nao id of result from parser */
{
    CHECK2NULL(str, "m4NAME: Result undefined");
    Tcl_SetResult(nap_cd->interp, str, TCL_VOLATILE);
    return str;
}

/*
 * Nap_TraceUnsets --
 *
 * Called when tcl variable is unset.
 * Decrement ref. count of nao.
 * Remove trace on tcl variable.
 * See Ousterhout chapter 34.
 *
 * It is possible that NAO (which clientData points to) no longer exists.
 * This can happen if user has done something weird like "set count 0" or
 * deleted the NAO command using "rename".
 */

static char *
Nap_TraceUnsets(
    ClientData		clientData,
    Tcl_Interp		*interp,
    CONST char		*name1,			/* name of variable */
    CONST char		*name2,			/* NULL here */
    int			flags)
{
    Nap_NAO             *list_nao;
    Nap_NAO             *naoPtr;
    Nap_NAO		**naoPtrPtr;
    NapClientData       *nap_cd;
    Nap_NAO             *tail_nao;

    assert(!name2);
    naoPtrPtr = (Nap_NAO **) clientData;
    naoPtr = *naoPtrPtr;
    nap_cd = Nap_GetClientData(interp);
    assert(nap_cd->interp == interp);
    if (Nap_IsNAO(nap_cd, naoPtr)) {
	if (naoPtr->count < 2  &&  nap_cd->slotList > 0) {
	    list_nao = Nap_GetNaoFromSlot(nap_cd->slotList);
	    assert(list_nao);
	    tail_nao = Nap_GetNaoFromSlot(list_nao->data.I32[0]);
	    assert(tail_nao);
	    list_nao->data.I32[0] = tail_nao->nextSlot = naoPtr->slot;
	} else {
	    Nap_DecrRefCount(nap_cd, naoPtr);
	}
    }
    Tcl_UntraceVar(interp, name1, TCL_TRACE_UNSETS | TCL_TRACE_WRITES, Nap_TraceUnsets, clientData);
    FREE(naoPtrPtr);
    return NULL;
}

/*
 * Nap_Assign --
 *
 * If tcl variable already defined then unset it.
 * Set tcl variable to nao ID.
 * Increment ref. count of nao.
 * Set unset-trace on tcl variable.
 * Side effect: Reset tcl result.
 * Return string ID of NAO.
 * If error return NULL.
 *
 * It is important that each clientData value be unique. Had bug caused by two identical names
 * within different procedures pointing to same NAO. So now use address of malloc area containing
 * unique pointer (to pointer to nao).
 */

m4define(`m4NAME', `Nap_Assign')

EXTERN char *
Nap_Assign(
    NapClientData	*nap_cd,
    char		*name,		/* name of tcl variable */
    char		*id)		/* ID of nao (could be name) */
{
    ClientData          clientData;
    CONST char		*cstr;
    Nap_NAO		**naoPtrPtr;
    Nap_NAO		*newNaoPtr;
    Nap_NAO		*oldNaoPtr;
    int			status;
    char		*str;

    newNaoPtr = Nap_GetNaoFromId(nap_cd, id);
    CHECK2NULL(name, "m4NAME: Illegal name on left of '='")
    CHECK2NULL(newNaoPtr, "m4NAME: Illegal expression on right of '='")
    Nap_IncrRefCount(nap_cd, newNaoPtr);

	/*
	 * Following allows for possibility that tcl variable may point to
	 * NAO with ref. count of 0.  E.g. if created by:
	 * set x [nap 9]
	 */

    cstr = Tcl_GetVar(nap_cd->interp, name, 0);
    str = Nap_StrDup(cstr);
    if (str && Nap_lexID(str) == strlen(str)) {
	oldNaoPtr = Nap_GetNaoFromId(nap_cd, str);
	if (Nap_IsNAO(nap_cd, oldNaoPtr)) {
	    Nap_IncrRefCount(nap_cd, oldNaoPtr);
	    status = Tcl_UnsetVar(nap_cd->interp, name, 0);
	    Nap_DecrRefCount(nap_cd, oldNaoPtr);
	}
    }
    FREE(str);
    cstr = Tcl_SetVar(nap_cd->interp, name, newNaoPtr->id, 0);
    CHECK3NULL(cstr, "m4NAME: Illegal name '%s' on left of '='", name)
    naoPtrPtr = (Nap_NAO **) MALLOC(sizeof(Nap_NAO *));
    *naoPtrPtr = newNaoPtr;
    clientData = (ClientData) naoPtrPtr;
    status = Tcl_TraceVar(nap_cd->interp, name, TCL_TRACE_UNSETS | TCL_TRACE_WRITES,
	    Nap_TraceUnsets, clientData);
    assert(status == TCL_OK);
    Tcl_ResetResult(nap_cd->interp);
    return newNaoPtr->id;
}

/*
 * Nap_IsNAO --
 *
 * Check whether thing pointed to looks like a sensible NAO.
 */

EXTERN int
Nap_IsNAO(
    NapClientData       *nap_cd,
    Nap_NAO             *naoPtr)
{
    const int		n = strlen(NAP_NAO_ID_PREFIX);
    size_t		slot;

    if (! naoPtr) return FALSE;
    if (! naoPtr->id) return FALSE;
    if (! Nap_ValidDataType(naoPtr->dataType)) return FALSE;
    if (naoPtr->nap_cd != nap_cd) return FALSE;
    if (naoPtr->slot >= nap_cd->lookupN) return FALSE;
    if (naoPtr->rank < 0) return FALSE;
    if (naoPtr->rank > NAP_MAX_RANK) return FALSE;
    if (naoPtr->nbytes < sizeof(Nap_NAO)) return FALSE;
    if (naoPtr->missingValueSlot < 0) return FALSE;
    if (naoPtr->raggedStartSlot < 0) return FALSE;
    if (! Nap_Valid_step(naoPtr->step)) return FALSE;
    if (strncmp(naoPtr->id, NAP_NAO_ID_PREFIX, n) != 0) return FALSE;
    if (atoi(naoPtr->id + n) != naoPtr->seqNum) return FALSE;
    slot = atoi(1 + strchr(naoPtr->id, '-'));
    if (slot != naoPtr->slot) return FALSE;
    if (nap_cd->lookup[slot] != naoPtr) return FALSE;
    return TRUE;
}

/*
 * Nap_NAOsSimilar --
 *
 *      Compare data-types & shapes of two NAOs
 *      Return TRUE if both NULL or both same data-type, rank and shape
 */

EXTERN int
Nap_NAOsSimilar(
    Nap_NAO             *x,
    Nap_NAO             *y)
{
    int                 i;

    if (x) {
        if (y) {
            if (x->dataType == y->dataType  &&  x->rank == y->rank) {
                for (i = 0; i < x->rank; i++) {
                    if (x->shape[i] != y->shape[i]) {
                        return FALSE;
                    }
                }
            } else {
                return FALSE;
            }
        } else {
            return FALSE;
        }
    } else {
        return y == NULL;
    }
    return TRUE;
}

/*
 * Nap_FreeNAO --
 * If mortal & ref. count is 0 (or 1 if NAO is coord var. of itself) then delete nao command.
 * Note that this results in function Nap_Delete being called.
 */

EXTERN void
Nap_FreeNAO(
    NapClientData	*nap_cd,
    Nap_NAO             *naoPtr)
{
    char                id[64];
    int			isOwnCV;	/* Is NAO coord. var of itself? */

    if (naoPtr  &&  naoPtr->mortal) {
        assert(Nap_IsNAO(nap_cd, naoPtr));
	isOwnCV = naoPtr->rank == 1  &&  naoPtr->slot == naoPtr->coordVarSlot[0];
	if (naoPtr->count <= isOwnCV) {
	    (void) strncpy(id, naoPtr->id, 64);
	    (void) Tcl_DeleteCommand(nap_cd->interp, id);
	}
    }
}

/*
 * Nap_Delete --
 *
 *   Free memory associated with nao, including dim. names.
 *   Decrement ref count of following, & release if their counts are then 0:
 *	coord vars
 *	missing value
 *	elements if boxed array
 *
 * Specified to Tcl_CreateObjCommand as deletion callback function.
 */

m4define(`m4NAME', `Nap_Delete')

static void
Nap_Delete(
    ClientData          clientData)
{
    NapClientData       *nap_cd;
    const int		delta = 1000;	/* free stack expansion increment */
    int                 i;
    size_t		slot;
    Nap_NAO             *naoPtr;
    Nap_NAO             *tmpPtr;

    naoPtr = (Nap_NAO *) clientData;
    if (naoPtr  &&  naoPtr->mortal) {
	nap_cd = naoPtr->nap_cd;
        assert(Nap_IsNAO(nap_cd, naoPtr));
	slot = naoPtr->slot;
        nap_cd->totalBytesNAO -= naoPtr->nbytes;
#ifdef PR_NAO_ALLOC
        printf("m4NAME: %p %s %+10d bytes making total %12d bytes\n",
            naoPtr, naoPtr->id, -((int) naoPtr->nbytes),
	    (int) nap_cd->totalBytesNAO);
#endif /* PR_NAO_ALLOC */
	tmpPtr = Nap_GetNaoFromSlot(naoPtr->linkSlot);
	Nap_DecrRefCount(nap_cd, tmpPtr);
	tmpPtr = Nap_GetNaoFromSlot(naoPtr->missingValueSlot);
	Nap_DecrRefCount(nap_cd, tmpPtr);
	tmpPtr = Nap_GetNaoFromSlot(naoPtr->raggedStartSlot);
	Nap_DecrRefCount(nap_cd, tmpPtr);
        for (i = 0; i < naoPtr->rank; i++) {
            FREE(naoPtr->dimName[i]);
            tmpPtr = Nap_GetCoordVar(nap_cd, naoPtr, i);
            if (tmpPtr) {
                assert(Nap_IsNAO(nap_cd, tmpPtr));
                -- tmpPtr->count;
		if (tmpPtr != naoPtr) {
		    Nap_FreeNAO(nap_cd, tmpPtr);
		}
            }
        }
        if (naoPtr->dataType == NAP_BOXED  ||  naoPtr->dataType == NAP_RAGGED) {
            for (i = 0; i < naoPtr->nels; i++) {
                tmpPtr = Nap_GetNaoFromSlot(naoPtr->data.Boxed[i]);
                if (tmpPtr) {
                    assert(Nap_IsNAO(nap_cd, tmpPtr));
                    -- tmpPtr->count;
		    if (tmpPtr != naoPtr) {
			Nap_FreeNAO(nap_cd, tmpPtr);
		    }
                }
            }
        }
        FREE(naoPtr->format);
        FREE(naoPtr->label);
        FREE(naoPtr->unit);
	/* need to expand free stack? */
	if (nap_cd->freeN >= nap_cd->freeSize) {
	    nap_cd->freeSize += delta;
	    nap_cd->free = (size_t *) realloc(nap_cd->free,
		    nap_cd->freeSize * sizeof(size_t));
	    assert(nap_cd->free);
	    for (i = nap_cd->freeSize - delta; i < nap_cd->freeSize; i++) {
		nap_cd->free[i] = 0;
	    }
	}
	nap_cd->lookup[slot] = NULL;
	assert(nap_cd->freeN < nap_cd->freeSize);
	nap_cd->free[nap_cd->freeN++] = slot;
        CKFREE((char *) naoPtr);
    }
}

/*
 * Nap_DecrRefCount --
 *
 *   Decrement nao->count.  If this is then <= 0 then free the NAO.
 */

EXTERN void
Nap_DecrRefCount(
    NapClientData	*nap_cd,
    Nap_NAO             *naoPtr)
{
    if (naoPtr) {
	assert(Nap_IsNAO(nap_cd, naoPtr));
	--naoPtr->count;
	Nap_FreeNAO(nap_cd, naoPtr);
    }
}

/*
 * Nap_IncrRefCount --
 *
 *   Increment nao->count
 */

EXTERN void
Nap_IncrRefCount(
    NapClientData	*nap_cd,
    Nap_NAO             *naoPtr)
{
    if (naoPtr) {
	assert(Nap_IsNAO(nap_cd, naoPtr));
	++naoPtr->count;
    }
}

/*
 * ndigits --
 *
 *      Number of digits in unsigned int
 *
 *      Examples:
 *      ndigits(0) is 1
 *      ndigits(9) is 1
 *      ndigits(10) is 2
 *      ndigits(999) is 3
 */

static unsigned int
ndigits(
    unsigned int        i)
{
    return i == 0 ? 1 : 1 + (int) floor(log10(i+0.5));
}

/*
 * roundUpToMultipleOf --
 *
 *      Round i up to multiple of j
 *
 *      Examples:
 *      roundUpToMultipleOf(4,4) is 4
 *      roundUpToMultipleOf(5,4) is 8
 *      roundUpToMultipleOf(6,4) is 8
 *      roundUpToMultipleOf(7,4) is 8
 *      roundUpToMultipleOf(8,4) is 8
 *      roundUpToMultipleOf(9,4) is 12
 */

static size_t
roundUpToMultipleOf(
    size_t              i,
    size_t              j)
{
    assert(j > 0);
    return i + (j - i % j) % j;
}

/*
 * Nap_IsMissingFalse --
 *
 *   Simply returns FALSE.  Use when no missing value defined.
 */

static int
Nap_IsMissingFalse(
    Nap_NAO	*np,		/* pointer to NAO */
    size_t	i)		/* subscript of element to test */
{
    return FALSE;
}

/*
 * Nap_IsMissingNaN64 --
 *
 *   Use when missing value is double NaN.
 */

static int
Nap_IsMissingNaN64(
    Nap_NAO	*np,		/* pointer to NAO */
    size_t	i)		/* subscript of element to test */
{
    return IsNaN64(np->data.F64[i]);
}


/*
 * Nap_IsMissingNaN32 --
 *
 *   Use when missing value is float NaN.
 */

static int
Nap_IsMissingNaN32(
    Nap_NAO	*np,		/* pointer to NAO */
    size_t	i)		/* subscript of element to test */
{
    return IsNaN32(np->data.F32[i]);
}

/*
 * Nap_IsMissing* --
 *
 *   Family of functions (one for each data type) testing whether data value
 *   is equal to missing value.
 */

static int
Nap_IsMissingF64(
    Nap_NAO	*np,		/* pointer to NAO */
    size_t	i)		/* subscript of element to test */
{
    return IsNaN64(np->data.F64[i])  ||
	    np->data.F64[i] == np->missingValuePtr->data.F64[0];
}

static int
Nap_IsMissingF32(
    Nap_NAO	*np,		/* pointer to NAO */
    size_t	i)		/* subscript of element to test */
{
    return IsNaN32(np->data.F32[i])  ||
	    np->data.F32[i] == np->missingValuePtr->data.F32[0];
}

m4begin

#	m4isMissing(dataType)
m4define(`m4isMissing', `
static int
Nap_IsMissing$1(
    Nap_NAO	*np,		/* pointer to NAO */
    size_t	i)		/* subscript of element to test */
{
    return np->data.$1[i] == np->missingValuePtr->data.$1[0];
}
')

#       m4setIsMissing(type)   e.g. m4setIsMissing(F32)
m4define(`m4setIsMissing', `
	case m4DataTypeEnum($1): np->isMissing = Nap_IsMissing$1; break;
')

m4end

m4ForAllBoxedDataType(`m4isMissing(', `)')
m4ForAllCharacterDataType(`m4isMissing(', `)')
m4ForAllIntegerDataType(`m4isMissing(', `)')

/*
 * Nap_SetMissing --
 *      Set NAO members 'missingValueSlot', 'isMissing' & 'missingValuePtr'.
 *	Decrement ref. count of old missing value NAO.
 *	Increment ref. count of new missing value NAO.
 */

m4define(`m4NAME', `Nap_SetMissing')

EXTERN int
Nap_SetMissing(
    NapClientData	*nap_cd,
    Nap_NAO		*np,			/* pointer to main NAO */
    int                 missingValueSlot)	/* slot of missing value (0=none ) */
{
    Nap_NAO		*mv_nao;		/* missing value nao */

    CHECK2(np, "m4NAME: Pointer to main NAO is NULL");
    mv_nao = Nap_GetNaoFromSlot(np->missingValueSlot);
    Nap_DecrRefCount(nap_cd, mv_nao);
    np->missingValueSlot = missingValueSlot;
    if (missingValueSlot) {
	mv_nao = Nap_GetNaoFromSlot(missingValueSlot);
	CHECK2(mv_nao, "m4NAME: Pointer to missing value NAO is NULL");
	np->missingValuePtr = mv_nao;
	Nap_IncrRefCount(nap_cd, mv_nao);
	switch (np->dataType) {
	    m4ForAllDataType(`m4setIsMissing(', `)')
	    default:            /* error */
		assert(FALSE);
	}
	switch (np->dataType) {	/* Handle case of NaN */
	    case NAP_F32:
		if (IsNaN32(mv_nao->data.F32[0])) {
		    np->isMissing = Nap_IsMissingNaN32;
		}
		break;
	    case NAP_F64:
		if (IsNaN64(mv_nao->data.F64[0])) {
		    np->isMissing = Nap_IsMissingNaN64;
		}
		break;
	}
    } else {
	np->missingValuePtr = NULL;
	np->isMissing = Nap_IsMissingFalse;
    }
    return TCL_OK;
}

/*
 * Nap_NewNAO4 --
 *      Create new NAO with specified data-type, null-value & shape.
 *      If error return NULL.
 */

m4define(`m4NAME', `Nap_NewNAO4')

static Nap_NAO *
Nap_NewNAO4(
    NapClientData	*nap_cd,
    Nap_dataType        dataType,
    int                 rank,
    size_t              *shape,
    int                 missingValueSlot)	/* missing value (0 = none) */
{
    char                *basePtr;               /* pointer to whole nao */
    const int		delta = 10000;		/* table expansion increment */
    int                 i;                      /* subscript */
    size_t              slot;
    size_t              nbytes;                 /* total # bytes in nao */
    size_t              nels;                   /* # elements in array */
    size_t              offset_coordVarSlot;	/* offset of nao section */
    size_t              offset_data;            /* offset of nao section */
    size_t              offset_dimName;         /* offset of nao section */
    size_t              offset_id;              /* offset of nao section */
    size_t              offset_shape;           /* offset of nao section */
    Nap_NAO             *result;                /* pointer to whole nao */
    int			status;

    if (rank > NAP_MAX_RANK  ||  !Nap_ValidDataType(dataType)) {
        return NULL;
    }
    ++nap_cd->seqNum;
    nels = 1;
    for (i = 0; i < rank; i++) {
	nels *= shape[i];
    }
    if (dataType == NAP_RAGGED  &&  rank > 0) {
	nels /= shape[rank-1];
    }
    /* room at end of lookup table? */
    if (nap_cd->lookupN < nap_cd->lookupSize) {
	slot = nap_cd->lookupN++;
    } else {
	if (nap_cd->freeN > 0) {		/* any free slots anywhere else? */
	    slot = nap_cd->free[--nap_cd->freeN];
	    assert(slot < nap_cd->lookupN);
	} else {
	    nap_cd->lookupSize += delta;
	    nap_cd->lookup = (Nap_NAO **) realloc(nap_cd->lookup,
		    nap_cd->lookupSize * sizeof(Nap_NAO *));
	    if (!nap_cd->lookup) {
		return NULL;
	    }
	    for (i = nap_cd->lookupSize - delta; i < nap_cd->lookupSize; i++) {
		nap_cd->lookup[i] = NULL;
	    }
	    slot = nap_cd->lookupN++;
	}
    }
    assert(nap_cd->lookupN <= nap_cd->lookupSize);
    assert(slot < nap_cd->lookupN);
    offset_id = sizeof(Nap_NAO);
    offset_shape = roundUpToMultipleOf(
            offset_id + strlen(NAP_NAO_ID_PREFIX) + ndigits(nap_cd->seqNum) + ndigits(slot) + 2,
            sizeof(size_t));
    offset_dimName = roundUpToMultipleOf(offset_shape + rank * sizeof(size_t), sizeof(char *));
    offset_coordVarSlot = roundUpToMultipleOf(offset_dimName + rank * sizeof(char *), sizeof(int));
    offset_data = roundUpToMultipleOf(
            offset_coordVarSlot + rank * sizeof(int), Nap_SizeOf(dataType));
    nbytes = offset_data + nels * Nap_SizeOf(dataType) + (dataType == NAP_C8);
    result = (Nap_NAO *) CKALLOC(nbytes);
    if (result) {
        basePtr			= (char *)    result;
        result->id		=            (basePtr + offset_id);
        result->shape		= (size_t *) (basePtr + offset_shape);
        result->dimName		= (char **)  (basePtr + offset_dimName);
        result->coordVarSlot	= (int *)    (basePtr + offset_coordVarSlot);
        result->data.c		=            (basePtr + offset_data);
	result->slot = slot;
	result->seqNum = nap_cd->seqNum;
	result->nap_cd = nap_cd;
        sprintf(result->id, "%s%lu-%lu",
		NAP_NAO_ID_PREFIX, (unsigned long) nap_cd->seqNum, (unsigned long) slot);
        result->count = 0;
        result->dataType = dataType;
        result->rank = rank;
        result->nels = nels;
        result->nbytes = nbytes;
        result->format = NULL;
        result->label = NULL;
        result->unit = NULL;
        result->linkSlot = 0;
        result->nextSlot = 0;
        result->raggedStartSlot = 0;
        result->step = NAP_UNKNOWN;
        result->mortal = TRUE;
        result->missingValueSlot = 0;
	status = Nap_SetMissing(nap_cd, result, missingValueSlot);
	CHECK1NULL(status == TCL_OK);
        for (i = 0; i < rank; i++) {
            result->shape[i] = shape[i];
            result->dimName[i] = NULL;
            result->coordVarSlot[i] = 0;
        }
	if (dataType == NAP_C8) {
	    result->data.c[nels] = '\0';
        }
        Tcl_CreateObjCommand(nap_cd->interp, result->id, Nap_ObjectCommand,
                (ClientData) result, Nap_Delete);
	nap_cd->totalBytesNAO += nbytes;
	nap_cd->maxTotalBytesNAO =
		Max(nap_cd->maxTotalBytesNAO, nap_cd->totalBytesNAO);
#ifdef PR_NAO_ALLOC
	printf("m4NAME: %p %s %+10d bytes making total %12d bytes\n",
		result, result->id, (int) nbytes, (int) nap_cd->totalBytesNAO);
#endif /* PR_NAO_ALLOC */
    }
    nap_cd->lookup[slot] = result;
    return result;
}

/*
 * Nap_NewNAO --
 *      Create new NAO with specified data-type & shape.
 *      If error return NULL.
 */

m4begin

m4define(`m4NAME', `Nap_NewNAO')

#       m4missingValue(DataType)  e.g. m4missingValue(I16)
m4define(`m4missingValue', `
            case m4DataTypeEnum($1):
		missingValueNao = nap_cd->`$1'MissingValueNao;
                break;')

m4end

Nap_NAO *
Nap_NewNAO(
    NapClientData	*nap_cd,
    Nap_dataType        dataType,
    int                 rank,
    size_t              *shape)
{
    Nap_NAO             *missingValueNao;	/* standard missing value */
    int                 missingValueSlot;	/* missing value (0 = none) */
    Nap_NAO             *result;                /* pointer to new nao */

    switch (dataType) {
        case NAP_U8:
        case NAP_C8:
            missingValueNao = NULL;
            break;
	default:
	    switch (dataType) {
		m4ForAllDataType(`m4missingValue(', `)')
		default:
		    assert(0);
	}
    }
    missingValueSlot = missingValueNao ? missingValueNao->slot : 0;
    result = Nap_NewNAO4(nap_cd, dataType, rank, shape, missingValueSlot);
    return result;
}

/*
 * Nap_NewScalarNAO --
 *      Create new scalar NAO with specified data-type & value.
 *      If error return NULL.
 */

m4begin

m4define(`m4NAME', `Nap_NewScalarNAO')

#       m4scalar(DataType)  e.g. m4scalar(I16)
m4define(`m4scalar', `
            case m4DataTypeEnum($1):
                result->data.$1[0] = value;
                break;')

m4end

Nap_NAO *
Nap_NewScalarNAO(
    NapClientData	*nap_cd,
    Nap_dataType        dataType,
    double		value)
{
    Nap_NAO             *result;		/* pointer to new nao */

    result = Nap_NewNAO(nap_cd, dataType, 0, NULL);
    if (result) {
	switch (dataType) {
	    m4ForAllDataType(`m4scalar(', `)')
	default:		/* error */
	    result = NULL;
	}
    }
    return result;
}

/*
 * Nap_GetF64MissingValue --
 *      Return missing value as double value.
 */

m4begin

m4define(`m4NAME', `Nap_GetF64MissingValue')

#       m4doubleMissingValue(DataType)  e.g. m4doubleMissingValue(I16)
m4define(`m4doubleMissingValue', `
            case m4DataTypeEnum($1):
	    result = naoPtr->data.$1[0];
                break;')

m4end

EXTERN double
Nap_GetF64MissingValue(
    NapClientData       *nap_cd,
    int			id)
{
    Nap_NAO             *naoPtr;
    double		result;

    naoPtr = Nap_GetNaoFromSlot(id);
    assert(naoPtr);
    id = naoPtr->missingValueSlot;
    naoPtr = Nap_GetNaoFromSlot(id);
    assert(naoPtr);
    switch (naoPtr->dataType) {
	m4ForAllDataType(`m4doubleMissingValue(', `)')
    default:		/* error */
	assert(FALSE);
    }
    return result;
}

/*
 * Nap_GetMissingValueCharPtr --
 *      Return (char *) pointer to missing value.
 */

m4define(`m4NAME', `Nap_GetMissingValueCharPtr')

EXTERN char *
Nap_GetMissingValueCharPtr(
    NapClientData       *nap_cd,
    Nap_NAO             *naoPtr)
{
    char		*result = NULL;

    if (naoPtr) {
	naoPtr = Nap_GetNaoFromSlot(naoPtr->missingValueSlot);
	if (naoPtr) {
	    result = naoPtr->data.c;
	}
    }
    return result;
}


/*
 * Nap_F64ScalarValue --
 *      Define (double) value of scalar NAO.
 */

m4define(`m4NAME', `Nap_F64ScalarValue')

EXTERN int
Nap_F64ScalarValue(
    NapClientData	*nap_cd,
    Nap_NAO             *naoPtr,
    double		*result)
{
    Nap_NAO             *tmp_NAO;

    CHECK2(naoPtr, "m4NAME: naoPtr is NULL");
    CHECK2(naoPtr->rank == 0, "m4NAME: NAO not scalar");
    tmp_NAO = Nap_CastNAO(nap_cd, naoPtr, NAP_F64);
    CHECK2(tmp_NAO, "m4NAME: Error calling Nap_CastNAO");
    *result = tmp_NAO->data.F64[0];
    if (tmp_NAO != naoPtr) {
	Nap_FreeNAO(nap_cd, tmp_NAO);
    }
    return TCL_OK;
}

/* 
 * Nap_ReshapeNAO2 --
 *
 *	Create new NAO with specified shape & data-type.
 *	Do cyclic copy of data from NAO 'old' to 'new'.
 *      If error return NULL.
 */

m4begin
m4copy_nao2(new_type, old_type)  e.g. m4copy_nao2(I16, F32)
m4define(`m4copy_nao2', `
		case m4DataTypeEnum($2):
		    for (i = 0; i < new->nels; i++) {
			j = i % old->nels;
			new->data.$1[i] = IsMissing(old, j)
			    #if NAP_`'m4UpperCase($2)_MIN_RANK < NAP_`'m4UpperCase($1)_MIN_RANK
				||  old->data.$2[j] < NAP_`'m4UpperCase($1)_MIN
			    #endif
			    #if NAP_`'m4UpperCase($2)_MAX_RANK > NAP_`'m4UpperCase($1)_MAX_RANK
				||  old->data.$2[j] > NAP_`'m4UpperCase($1)_MAX
			    #endif
				? m4MissingValue($1) : old->data.$2[j];
		    }
		    break;')

m4copy_nao1(new_type)  e.g. m4copy_nao1(I16)
m4define(`m4copy_nao1', `
	    case m4DataTypeEnum($1):
		switch (old->dataType) {
		m4ForAllDataType(`m4copy_nao2($1, ', `)')
		default:		/* error */
		    return NULL;
		}
		break;')
m4end

Nap_NAO *
Nap_ReshapeNAO2(
    NapClientData	*nap_cd,
    Nap_NAO		*old,
    Nap_dataType	dataType,	/* new data-type */
    int			rank,		/* new rank */
    size_t		*shape,		/* new shape */
    int			want_text,	/* Include format, label & unit? */
    int			want_dims)	/* Include dims & CVs? */
{
    size_t		i;
    size_t		j;
    Nap_NAO		*new;
    int			status;

    if (old) {
	assert(old->id);
	assert(Nap_IsNAO(nap_cd, old));
	new = Nap_NewNAO(nap_cd, dataType, rank, shape);
	if (new) {
	    if (old->nels == 0  &&  new->nels > 0) {
		return NULL;
	    }
	    if (want_dims) {
		status = Nap_CopyDims(nap_cd, old, new);
		if (status != TCL_OK) {
		    return NULL;
		}
	    }
	    if (want_text) {
		new->format = Nap_StrDup(old->format);
		new->label = Nap_StrDup(old->label);
		new->unit = Nap_StrDup(old->unit);
	    }
	    switch (new->dataType) {
	    m4ForAllDataType(`m4copy_nao1(', `)')
	    default:		/* error */
		return NULL;
	    }
	}
	if (dataType >= old->dataType) {
	    new->step = old->step;
	}
	return new;
    } else {
	return NULL;
    }
}


/* 
 * Nap_ReshapeNAO --
 *
 *	Create new NAO with specified shape & data-type.
 *	Do cyclic copy of data from NAO 'old' to 'new'.
 *      If error return NULL.
 */

Nap_NAO *
Nap_ReshapeNAO(
    NapClientData	*nap_cd,
    Nap_NAO		*old,
    Nap_dataType	dataType,	/* new data-type */
    int			rank,		/* new rank */
    size_t		*shape)		/* new shape */
{
    return Nap_ReshapeNAO2(nap_cd, old, dataType, rank, shape, TRUE, TRUE);
}


/* 
 * Nap_ReshapeNAO_trailing --
 *
 *	Create new NAO with specified shape & data-type.
 *	Do cyclic copy of data from NAO 'old' to 'new'.
 *      If error return NULL.
 */

EXTERN Nap_NAO *
Nap_ReshapeNAO_trailing(
    NapClientData	*nap_cd,
    Nap_NAO		*old,
    Nap_dataType	dataType,	/* new data-type */
    int			rank,		/* new rank */
    size_t		*shape)		/* new shape */
{
    size_t		i;
    size_t		j;
    Nap_NAO		*new;
    int			status;

    if (old) {
	assert(old->id);
	assert(Nap_IsNAO(nap_cd, old));
	new = Nap_NewNAO(nap_cd, dataType, rank, shape);
	if (new) {
	    status = Nap_CopyTrailingDims(nap_cd, old, new);
	    if (status != TCL_OK) {
		return NULL;
	    }
	    if (old->nels == 0  &&  new->nels > 0) {
		return NULL;
	    }
	    new->format = Nap_StrDup(old->format);
	    new->label = Nap_StrDup(old->label);
	    new->unit = Nap_StrDup(old->unit);
	    switch (new->dataType) {
	    m4ForAllDataType(`m4copy_nao1(', `)')
	    default:		/* error */
		return NULL;
	    }
	}
	if (dataType >= old->dataType) {
	    new->step = old->step;
	}
	return new;
    } else {
	return NULL;
    }
}


/* 
 * Nap_CopyNAO3 --
 *
 *	Return pointer to new NAO which is copy of existing one.
 *	Option to include format, label & unit.
 *      If error return NULL.
 */

static Nap_NAO *
Nap_CopyNAO3(
    NapClientData	*nap_cd,
    Nap_NAO		*old,
    int			want_text)		/* Include format, label & unit? */
{
    int                 i;
    Nap_NAO		*result;
    Nap_NAO		*tmpPtr;

    if (!old) {
	return NULL;
    }
    assert(old->id);
    assert(Nap_IsNAO(nap_cd, old));
    result = Nap_ReshapeNAO2(nap_cd, old, old->dataType, old->rank, old->shape, want_text, TRUE);
    if (result->dataType == NAP_BOXED  ||  result->dataType == NAP_RAGGED) {
	for (i = 0; i < result->nels; i++) {
	    tmpPtr = Nap_GetNaoFromSlot(result->data.Boxed[i]);
	    Nap_IncrRefCount(nap_cd, tmpPtr);
	}
    }
    return result;
}


/* 
 * Nap_CopyNAO --
 *
 * Return pointer to new NAO which is copy (excluding format, label & unit) of existing one.
 * If error return NULL.
 */

Nap_NAO *
Nap_CopyNAO(
    NapClientData	*nap_cd,
    Nap_NAO		*old)
{
    return Nap_CopyNAO3(nap_cd, old, FALSE);
}


/* 
 * Nap_DupNAO --
 *
 * Return pointer to new NAO which is copy (including format, label & unit) of existing one.
 * If error return NULL.
 */

Nap_NAO *
Nap_DupNAO(
    NapClientData	*nap_cd,
    Nap_NAO		*old)
{
    return Nap_CopyNAO3(nap_cd, old, TRUE);
}


/* 
 * Nap_CastNAO --
 *
 *	Return pointer to NAO with specified data-type.
 *	If arg is of this data-type then simply return pointer to it.
 *      If error return NULL.
 */

EXTERN Nap_NAO *
Nap_CastNAO(
    NapClientData	*nap_cd,
    Nap_NAO		*old,
    Nap_dataType	dataType)	/* new data-type */
{
    Nap_NAO		*result;

    if (!old) {
	return NULL;
    }
    assert(old->id);
    assert(Nap_IsNAO(nap_cd, old));
    if (old->dataType != dataType) {
	result = Nap_ReshapeNAO(nap_cd, old, dataType, old->rank, old->shape);
    } else {
	result = old;
    }
    return result;
}

/*
 *  Nap_Promote --
 *	Return pointer to NAO which is like *naoPtr, but has a data-type of at
 *	least minDataType & a rank of at least minRank.
 *	If *naoPtr is OK then just return naoPtr.
 *      If error return NULL.
 */

Nap_NAO *
Nap_Promote(
    NapClientData	*nap_cd,
    Nap_NAO		*naoPtr,
    Nap_dataType        minDataType,
    int                 minRank,
    size_t		*altShape)	/* Use this shape to get rank minRank */
{
    Nap_dataType        dataType;
    int                 rank;
    size_t		*shape;
    Nap_NAO		*result;

    if (naoPtr) {
	assert(naoPtr->id);
	assert(Nap_IsNAO(nap_cd, naoPtr));
	dataType = Max(naoPtr->dataType, minDataType);
	if (naoPtr->rank < minRank) {
	    rank = minRank;
	    shape = altShape;
	} else {
	    rank = naoPtr->rank;
	    shape = naoPtr->shape;
	}
	if (naoPtr->rank < rank || naoPtr->dataType < dataType) {
	    result = Nap_ReshapeNAO(nap_cd, naoPtr, dataType, rank, shape);
	} else {
	    result = naoPtr;
	}
    } else {
	return NULL;
    }
    return result;
}

/*
 *  Nap_UnboxedElement1 --
 *
 *	If NAO is boxed/ragged then return first non-NULL element.
 *	If all NULL return NULL.
 *	If not boxed/ragged return argument.
 */

m4define(`m4NAME', `Nap_UnboxedElement1')

Nap_NAO *
Nap_UnboxedElement1(
    NapClientData       *nap_cd,
    Nap_NAO		*naoPtr)
{
    size_t		i;
    Nap_NAO		*result = NULL;

    if (naoPtr) {
	switch (naoPtr->dataType) {
	case NAP_BOXED:
	case NAP_RAGGED:
	    for (i = 0; i < naoPtr->nels && result == NULL; i++) {
		result = Nap_GetNaoFromSlot(naoPtr->data.Boxed[i]);
	    }
	    break;
        default:
            result = naoPtr;
	}
    }
    return result;
}

/*
 * Nap_Find --
 *
 *	Nap_Find performs a binary search of a table (vector v) of values
 *	to find the index i of v such that the specified value (x) is between
 *	x[i-1] and x[i]. The vector v should be either monotonically
 *	increasing or monotonically decreasing (but equal values are allowed).
 *
 *	It is legal for x to be outside the range spanned by v. In this case 
 *	the result is 0 or n.
 *
 *	If an initial guess (g < n) is given then Nap_Find searches locally
 *	to span the required value and then reverts to a binary search.  
 */

m4begin

#	m4huntNao(dataType)
m4define(`m4huntNao', `
	case m4DataTypeEnum($1):
	    switch (nao_ptr->step) {
	    case NAP_NON_NEGATIVE:
	    case NAP_NON_POSITIVE:
		result = Nap_Hunt`$1'(nap_cd, nao_ptr->data.$1, n,
			*(m4DataTypeName($1) *) x_ptr, g);
		break;
	    case NAP_EQUAL:
		x = *(m4DataTypeName($1) *) x_ptr;
		x0 = nao_ptr->data.$1[0];
		x1 = nao_ptr->data.$1[1];
		if (x0 == x1) {
		    if (x0 == x) {
			result = 0;
		    } else {
			result = n;
		    }
		} else {
		    if (n == 2) {
			tmp = (x - x0) / (x1 - x0);
		    } else {
			x1 = nao_ptr->data.$1[n-2];
			tmp = (x - x0) * (n - 2) / (x1 - x0);
			if (tmp > n - 2) {
			    x0 = nao_ptr->data.$1[n-2];
			    x1 = nao_ptr->data.$1[n-1];
			    tmp = n - 2.0 + (x - x0) / (x1 - x0);
			}
		    }
		    if (tmp < 0.5) {
			result = 0;
		    } else if (tmp < n - 1.5) {
			result = tmp + 0.5;
		    } else {
			result = n - 1;
		    }
		}
		break;
	    default:
		assert(FALSE);
	    }
	    break;')

#	m4indexOfNao(dataType)
m4define(`m4indexOfNao', `
        case m4DataTypeEnum($1):
	    switch (nao_ptr->step) {
	    case NAP_BOTH:
		x = *(m4DataTypeName($1) *) x_ptr;
		if (IsNaN32(x)) {
		    return NAP_F32_NULL;
		}
		x0 = x1 = NAP_F32_NULL;
		have0 = !IsMissing(nao_ptr, 0);
		if (have0) {
		    x0 = nao_ptr->data.$1[0];
		    if (x == x0) {
			return 0;
		    }
		}
		have1 = !IsMissing(nao_ptr, 1);
		if (have1) {
		    x1 = nao_ptr->data.$1[1];
		    if (x == x1) {
			return 1;
		    } else if (have0  &&  Sign(x1-x) == Sign(x1-x0)) {
			return (x - x0) / (x1 - x0);
		    }
		}
		for (i = 2; i < n; i++) {
		    x0 = x1;
		    have0 = have1;
		    have1 = !IsMissing(nao_ptr, i);
		    if (have1) {
			x1 = nao_ptr->data.$1[i];
			if (x == x1) {
			    return i;
			} else if (have0  &&  Sign(x-x0) == Sign(x1-x)) {
			    return i - (x1 - x) / (x1 - x0);
			}
		    }
		}
		if (have0  &&  have1  &&  Sign(x-x1) == Sign(x1-x0)) {
		    return n - 2 + (x - x0) / (x1 - x0);
		}
		return NAP_F32_NULL;
	    case NAP_NON_NEGATIVE:
	    case NAP_NON_POSITIVE:
		result = Nap_IndexOf$1(nap_cd, nao_ptr->data.$1, n,
			*(m4DataTypeName($1) *) x_ptr, g);
		break;
	    case NAP_EQUAL:
		if (nao_ptr->data.$1[0] == nao_ptr->data.$1[1]) {
		    if (nao_ptr->data.$1[0] == (*(m4DataTypeName($1) *) x_ptr)) {
			result = 0;
		    } else {
			result = NAP_F32_NULL;
		    }
		} else {
		    x = *(m4DataTypeName($1) *) x_ptr;
		    x0 = nao_ptr->data.$1[0];
		    if (n == 2) {
			x1 = nao_ptr->data.$1[1];
			result = (x - x0) / (x1 - x0);
		    } else {
			x1 = nao_ptr->data.$1[n-2];
			result = (x - x0) * (n - 2) / (x1 - x0);
		    }
		    if (result > n - 2) {
			x0 = nao_ptr->data.$1[n-2];
			x1 = nao_ptr->data.$1[n-1];
			result = n - 2.0 + (x - x0) / (x1 - x0);
		    }
		}
		break;
	    default:
		assert(FALSE);
	    }                                                       
            break;')

#       m4find(dataType)
m4define(`m4find', `
EXTERN size_t
Nap_Find`$1'(
    NapClientData		*nap_cd,
    m4DataTypeName(`$1')	v[],	/* vector of values (in) */
    size_t			n,	/* number of elements in vector (in) */
    m4DataTypeName(`$1')	x,	/* value to search for in v (in) */
    size_t			g)	/* guess (ignored if g >= n) (in) */
{
    size_t			low;		/* low index value, 0 minimum */
    size_t			high;		/* high index value */
    size_t			index;		/* working index */
    
    if (n == 0) {
	return 0;
    }
    low = 0;
    high = n-1;
    if (g < 1) {
	g = 1;
    } else if (g == high) {
	--g;
    }

    /* 
     * For efficiency, have separate code for ascending & descending cases.
     */

    if (v[0] <= v[high]) {
	if (x <= v[0]) {
	    return 0;
	} else if (v[high] < x) {
	    return n;
	} else if (g > high) {
	} else if (v[g-1] < x  &&  x <= v[g]) {
	    return g;
	} else if (v[g] < x  &&  x < v[g+1]) {
	    return g+1;
	}
	while (high - low > 1) {
	    index = (high + low) / 2;
	    if(x < v[index]) {
		high = index;
	    } else {
		low = index;
	    }
	}
    } else {
	if (x >= v[0]) {
	    return 0;
	} else if (v[high] > x) {
	    return n;
	} else if (g > high) {
	} else if (v[g-1] > x  &&  x >= v[g]) {
	    return g;
	} else if (v[g] > x  &&  x > v[g+1]) {
	    return g+1;
	}
	while (high - low > 1) {
	    index = (high + low) / 2;
	    if(x > v[index]) {
		high = index;
	    } else {
		low = index;
	    }
	}
    }
    index = x == v[low] ? low : high;
    return index;
}


/*
 * Nap_Hunt --
 *
 *	Nap_Hunt performs a binary search of a table (vector v) of values
 *	to find the index of the value in the table closest to a
 *	specified value (x). The vector v should be either monotonically
 *	increasing or monotonically decreasing (but equal values are allowed).
 *
 *	It is legal for x to be outside the range spanned by v. In this case 
 *	the result is 0 or n-1.
 *
 *	If an initial guess (g < n) is given then Nap_Hunt searches locally
 *	to span the required value and then reverts to a binary search.  
 */

EXTERN size_t
Nap_Hunt`$1'(
    NapClientData		*nap_cd,
    m4DataTypeName(`$1')	v[],	/* vector of values (in) */
    size_t		n,	/* number of elements in the vector (in) */
    m4DataTypeName(`$1')	x,	/* value to search for in v (in) */
    size_t		g)	/* initial guess (ignored unless g < n) (in) */
{
    size_t	index;
    
    index = Nap_Find$1(nap_cd, v, n, x, g);
    index -= index > 0
	    &&  (index == n 
	    ||  (x != v[index]  &&  AbsDiff(x, v[index-1]) <= AbsDiff(x, v[index])));
    return index;
}

/*
 * Nap_IndexOf --
 *
 *   Nap_IndexOf performs a binary search of a table (vector v) of values
 *   to find the (interpolated) index of the value in the table
 *   corresponding to a specified value (x). The vector v should be either
 *   monotonically increasing or monotonically decreasing (but equal values
 *   are allowed).
 *
 *   For monotonically increasing case:
 *   If v[i] < x < v[i+1] then result is i+(x-v[i])/(v[i+1]-v[i]).
 *   If x < v[0] then result is (x-v[0])/(v[1]-v[0]) which is < 0.
 *   If x > v[n-1] then result is n-2+(x-v[n-2])/(v[n-1]-v[n-2]) which is > n-1.
 *
 *   If an initial guess g (0 <= g <= n-1) is given then Nap_IndexOf
 *   searches locally to span the required value and then reverts to a
 *   binary search.  
 *
 *   Allow ends (v[0] and v[n-1]) to be infinite
 */

EXTERN float
Nap_IndexOf`$1'(
    NapClientData		*nap_cd,
    m4DataTypeName(`$1')	v[],	/* vector of values (in) */
    size_t			n,	/* number of elements in the vector (in) */
    m4DataTypeName(`$1')	x,	/* value to search for in v (in) */
    float			g)	/* guess (ignored unless 0 <= g <= n-1) (in) */
{
    double	step;
    size_t	G;
    size_t	i;
    size_t	j;
    float	index;

    if (n < 2) {
	return NAP_F32_NULL;
    }
    G = 0 <= g && g <= n-1 ? g + 0.5 : n;
    i = Nap_Find`$1'(nap_cd, v, n, x, G);
    i = i < 2 ? 0 : i > n-2 ? n-2 : i-(x != v[i]);
    while (i > 0  &&  v[i-1] == x) {
	--i;
    }
    if (v[i] == v[i+1]) {
	for (j = i+1; j+1 < n  &&  x == v[j+1]; j++) {
	}
	index = 0.5f * (i + j);
    } else {
	step =  (double) v[i+1] - (double) v[i];
	if (i == 0) {
	    index = 1.0 - ((double) v[1] - (double) x) / step;
	} else {
	    index = i + ((double) x - (double) v[i]) / step;
	}
    }
    return index;
}')

m4end

m4ForAllUnboxedDataType(`m4find(', `)')

/*
 * Nap_HuntNao --
 *
 *   This is interface to Nap_Hunt with vector specified as NAO.
 *   This enables optimisation using the step field.
 *   If error return nao_ptr->nels.
 */

EXTERN size_t
Nap_HuntNao(
    NapClientData	*nap_cd,
    Nap_NAO		*nao_ptr,
    void		*x_ptr,	/* value to search for in v (in) */
    size_t		g)	/* guess (ignored unless g < n) (in) */
{
    size_t		n;
    size_t		result;
    int			status;
    double		tmp;
    double		x;
    double		x0;
    double		x1;

    assert(nao_ptr);
    n = nao_ptr->nels;
    if (nao_ptr->rank != 1  ||  n < 2) {
	return n;
    }
    if (nao_ptr->step == NAP_UNKNOWN) {
	status = Nap_OilNao(nao_ptr);
	assert(status == TCL_OK);
    }
    if (nao_ptr->step == NAP_BOTH) {
	return n;
    }
    switch (nao_ptr->dataType) {
        m4ForAllUnboxedDataType(`m4huntNao(', `)')
        default:                /* error */
            assert(0);
    }
    return result;
}

/*
 * Nap_IndexOfNao --
 *
 *   This is interface to Nap_IndexOf with vector specified as NAO.
 *   This enables optimisation using the step field.
 *   Also handle case where vector is not monotonic (sorted).
 */

EXTERN float
Nap_IndexOfNao(
    NapClientData	*nap_cd,
    Nap_NAO		*nao_ptr, /* vector */
    void		*x_ptr,	/* value to search for in v (in) */
    float		g)	/* initial guess (ignored unless 0 <= g <= n-1) (in) */
{
    int			have0;		/* Is x0 present? */
    int			have1;		/* Is x1 present? */
    int			i;
    int			n;
    float		result;
    int			status;
    float		x;
    float		x0;
    float		x1;

    assert(nao_ptr);
    status = Nap_OilNao(nao_ptr);
    assert(status == TCL_OK);
    if (nao_ptr->rank != 1 || nao_ptr->nels < 2) {
	return NAP_F32_NULL;
    }
    n = nao_ptr->nels;
    switch (nao_ptr->dataType) {
	m4ForAllUnboxedDataType(`m4indexOfNao(', `)')
	default:                /* error */
	    return NAP_F32_NULL;
    }
    return result;
}

/*
 * Nap_OilNao --
 *
 *   "Oil" NAO i.e. set step field to improve efficiency.
 */

m4begin

m4define(`m4NAME', `Nap_OilNao')

#       Usage: m4oilInteger(dataType)
m4define(`m4oilInteger', `
	    case m4DataTypeEnum($1):
		istep_min = istep_max = (long) naoPtr->data.$1[1] - (long) naoPtr->data.$1[0];
		for (i = 2; i < n-1; i++) {
		    istep = (long) naoPtr->data.$1[i] - (long) naoPtr->data.$1[i-1];
		    if (istep < istep_min) {
			istep_min = istep;
		    } else if (istep > istep_max) {
			istep_max = istep;
		    }
		    if (Sign(istep_min) * Sign(istep_max) < 0) {
			break;
		    }
		}
		istep = (long) naoPtr->data.$1[n-1] - (long) naoPtr->data.$1[n-2];
		break;')

#       Usage: m4oilReal(dataType)
m4define(`m4oilReal', `
	    case m4DataTypeEnum($1):
		value_max = fabs(naoPtr->data.$1[0]);
		value = fabs(naoPtr->data.$1[n-1]);
		if (value > value_max) {
		    value_max = value;
		}
		step_min = step_max = naoPtr->data.$1[1] - naoPtr->data.$1[0];
		for (i = 2; i < n-1; i++) {
		    value = fabs(naoPtr->data.$1[i]);
		    if (value > value_max) {
			value_max = value;
		    }
		    step = naoPtr->data.$1[i] - naoPtr->data.$1[i-1];
		    if (step < step_min) {
			step_min = step;
		    } else if (step > step_max) {
			step_max = step;
		    }
		    if (Sign(step_min) * Sign(step_max) < 0) {
			break;
		    }
		}
		step = naoPtr->data.$1[n-1] - naoPtr->data.$1[n-2];
		break;')

m4end

EXTERN int
Nap_OilNao(
    Nap_NAO	*naoPtr)
{
    double	eps;		/* tolerance for relative comparison */
    long	istep;
    long	istep_max;
    long	istep_min;
    size_t	i;
    size_t	n;
    double	step;
    double	step_max;
    double	step_min;
    double	value;
    double	value_max;

    if (naoPtr  &&  naoPtr->step == NAP_UNKNOWN  &&  naoPtr->rank < 2) {
	n = naoPtr->nels;
	for (i = 1; i < n; i++) {
	    if (IsMissing(naoPtr, i)) {
		naoPtr->step = NAP_BOTH;
		return TCL_OK;
	    }
	}
	if (naoPtr->rank == 0  ||  n < 3) {
	    naoPtr->step = NAP_EQUAL;
	} else if (naoPtr->dataType == NAP_C8 || Nap_IsInteger(naoPtr)) {
	    switch (naoPtr->dataType) {
	    m4ForAllCharacterDataType(`m4oilInteger(', `)')
	    m4ForAllIntegerDataType(`m4oilInteger(', `)')
	    default:            /* error */
		assert(FALSE);
	    }
	    if (istep_max == istep_min
			&&  Sign(istep) * istep_max >= 0
			&&  abs(istep) <= abs(istep_max)) {
		naoPtr->step = NAP_EQUAL;
	    } else if (istep_max >= 0  &&  istep_min >= 0  &&  istep >= 0) {
		naoPtr->step = NAP_NON_NEGATIVE;
	    } else if (istep_max <= 0  &&  istep_min <= 0  &&  istep <= 0) {
		naoPtr->step = NAP_NON_POSITIVE;
	    } else {
		naoPtr->step = NAP_BOTH;
	    }
	} else if (Nap_IsReal(naoPtr)) {
	    switch (naoPtr->dataType) {
	    m4ForAllRealDataType(`m4oilReal(', `)')
	    default:            /* error */
		assert(FALSE);
	    }
	    if (naoPtr->dataType == NAP_F64) {
		eps = 1e2 * DBL_EPSILON;
	    } else {
		eps = 1e2 * FLT_EPSILON;
	    }
	    if (step_max - step_min < DBL_MAX
	    		&&  step_max - step_min <= eps * value_max
			&&  Sign(step) * step_max >= 0
			&&  fabs(step) < DBL_MAX
			&&  fabs(step) <= fabs(step_max) + eps * value_max) {
		naoPtr->step = NAP_EQUAL;
	    } else if (step_max >= 0.0  &&  step_min >= 0.0  &&  step >= 0) {
		naoPtr->step = NAP_NON_NEGATIVE;
	    } else if (step_max <= 0.0  &&  step_min <= 0.0  &&  step <= 0) {
		naoPtr->step = NAP_NON_POSITIVE;
	    } else {
		naoPtr->step = NAP_BOTH;
	    }
	}
    }
    return TCL_OK;
}


/*
 * Nap_CopyDims --
 *
 *	Copy dimension-names & coordinate variables from one nao to another.
 *	Number of each is min(srcPtr->rank, dstPtr->rank).
 *	If any source CV has too few elements then ignore this dim.
 */

m4define(`m4NAME', `Nap_CopyDims')

EXTERN int
Nap_CopyDims(
    NapClientData	*nap_cd,
    Nap_NAO		*srcPtr, 	/* Source NAO */
    Nap_NAO		*dstPtr) 	/* Destination NAO */
{
    Nap_NAO		*coordNaoPtr;
    char		*dimName;
    int                 i;
    int                 n;
    int                 status;

    assert(srcPtr);
    assert(srcPtr->id);
    assert(Nap_IsNAO(nap_cd, srcPtr));
    assert(dstPtr);
    assert(dstPtr->id);
    assert(Nap_IsNAO(nap_cd, dstPtr));
    n = Min(srcPtr->rank, dstPtr->rank);
    for (i = 0; i < n; i++) {
	coordNaoPtr = Nap_GetCoordVar(nap_cd, srcPtr, i);
	if (coordNaoPtr) {
	    CHECK2(coordNaoPtr->rank == 1,
		    "m4NAME: rank of coordinate variable not 1");
	    if (coordNaoPtr->nels < dstPtr->shape[i]) {
		coordNaoPtr = NULL;
	    }
	}
	dimName = srcPtr->dimName[i];
	status = Nap_AttachCoordVar(nap_cd, dstPtr, coordNaoPtr, dimName, i);
	CHECK(status == TCL_OK);
    }
    return TCL_OK;
}


/*
 * Nap_CopyTrailingDims --
 *
 *	Copy dimension-names & coordinate variables from one nao to another.
 *	Number of each is min(srcPtr->rank, dstPtr->rank).
 *	If any source CV has too few elements then ignore this dim.
 *	Same as Nap_CopyDims except that take trailing rather than leading dims
 */

m4define(`m4NAME', `Nap_CopyTrailingDims')

EXTERN int
Nap_CopyTrailingDims(
    NapClientData	*nap_cd,
    Nap_NAO		*srcPtr, 	/* Source NAO */
    Nap_NAO		*dstPtr) 	/* Destination NAO */
{
    Nap_NAO		*coordNaoPtr;
    int                 d;
    char		*dimName;
    int                 i;
    int                 n;
    int                 s;
    int                 status;

    assert(srcPtr);
    assert(srcPtr->id);
    assert(Nap_IsNAO(nap_cd, srcPtr));
    assert(dstPtr);
    assert(dstPtr->id);
    assert(Nap_IsNAO(nap_cd, dstPtr));
    n = Min(srcPtr->rank, dstPtr->rank);
    for (i = 0; i < n; i++) {
	s = srcPtr->rank - i - 1;
	d = dstPtr->rank - i - 1;
	coordNaoPtr = Nap_GetCoordVar(nap_cd, srcPtr, s);
	if (coordNaoPtr) {
	    CHECK2(coordNaoPtr->rank == 1, "m4NAME: rank of coordinate variable not 1");
	    if (coordNaoPtr->nels < dstPtr->shape[d]) {
		coordNaoPtr = NULL;
	    }
	}
	dimName = srcPtr->dimName[s];
	status = Nap_AttachCoordVar(nap_cd, dstPtr, coordNaoPtr, dimName, d);
	CHECK(status == TCL_OK);
    }
    return TCL_OK;
}


/*
 *  Nap_AttachCV --
 *      Attach coordinate variable to NAO.
 *      If coordinate variable has too many elements then create new one.
 */

m4define(`m4NAME', `Nap_AttachCV')

EXTERN int
Nap_AttachCV(
    NapClientData	*nap_cd,
    Nap_NAO             *mainNaoPtr,	/* Main NAO */
    Nap_NAO             *coordNaoPtr,	/* New coord var (may be NULL) */
    int                 dimNum)		/* Dimension number */
{
    Nap_NAO             *oldCoordNaoPtr; /* Old coord var (may be NULL) */
    Nap_NAO             *tmpNaoPtr;

    assert(mainNaoPtr);
    assert(dimNum >= 0);
    assert(dimNum < mainNaoPtr->rank);
    assert(mainNaoPtr->id);
    assert(Nap_IsNAO(nap_cd, mainNaoPtr));
    oldCoordNaoPtr = Nap_GetNaoFromSlot(mainNaoPtr->coordVarSlot[dimNum]);
    if (coordNaoPtr) {
	assert(coordNaoPtr->id);
	assert(Nap_IsNAO(nap_cd, coordNaoPtr));
	CHECK2(coordNaoPtr->rank == 1,
		"m4NAME: Coordinate variable has rank other than 1");
	CHECK5(coordNaoPtr->nels >= mainNaoPtr->shape[dimNum],
		"m4NAME: Coordinate variable of dimension %d has %d elements which should be >= %d",
		dimNum, coordNaoPtr->nels, mainNaoPtr->shape[dimNum]);
	if (coordNaoPtr->coordVarSlot[0]) {	/* cv has cv, so create copy */
	    tmpNaoPtr = coordNaoPtr;
	    Nap_IncrRefCount(nap_cd, tmpNaoPtr);
	    coordNaoPtr = Nap_NewNAO(nap_cd, tmpNaoPtr->dataType, 1, mainNaoPtr->shape + dimNum);
	    memcpy(coordNaoPtr->data.c, tmpNaoPtr->data.c,
		    Nap_SizeOf(coordNaoPtr->dataType) * coordNaoPtr->nels);
	    Nap_DecrRefCount(nap_cd, tmpNaoPtr);
	}
	if (coordNaoPtr->nels > mainNaoPtr->shape[dimNum]) {
	    tmpNaoPtr = coordNaoPtr;
	    Nap_IncrRefCount(nap_cd, tmpNaoPtr);
	    coordNaoPtr = Nap_ReshapeNAO(nap_cd, tmpNaoPtr,
		    tmpNaoPtr->dataType, 1, mainNaoPtr->shape + dimNum);
	    Nap_DecrRefCount(nap_cd, tmpNaoPtr);
	}
	mainNaoPtr->coordVarSlot[dimNum] = coordNaoPtr->slot;
	Nap_IncrRefCount(nap_cd, coordNaoPtr);
    } else {
	mainNaoPtr->coordVarSlot[dimNum] = 0;
    }
    Nap_DecrRefCount(nap_cd, oldCoordNaoPtr);
    return TCL_OK;
}

/*
 *  Nap_SetDimName --
 *      Assign name to dimension.
 *
 *      Change illegal chars to "_"
 */

m4define(`m4NAME', `Nap_SetDimName')

EXTERN int
Nap_SetDimName(
    NapClientData	*nap_cd,
    Nap_NAO             *mainNaoPtr,	/* Main NAO */
    char		*dimName,	/* New dim. name (ignore if NULL) */
    int                 dimNum)		/* Dimension number */
{
    assert(mainNaoPtr);
    assert(dimNum >= 0);
    assert(dimNum < mainNaoPtr->rank);
    assert(mainNaoPtr->id);
    assert(Nap_IsNAO(nap_cd, mainNaoPtr));
    if (dimName) {
	dimName = Nap_StrDup(dimName);
	CHECK2(dimName, "m4NAME: Error calling Nap_StrDup");
    }
    FREE(mainNaoPtr->dimName[dimNum]);
    mainNaoPtr->dimName[dimNum] = dimName;
    return TCL_OK;
}

/*
 *  Nap_StrToDimNum --
 *      Return dimension number (-1 for error).
 */

m4define(`m4NAME', `Nap_StrToDimNum')

EXTERN int
Nap_StrToDimNum(
    NapClientData	*nap_cd,
    Nap_NAO             *naoPtr,	/* NAO */
    char		*str)	/* string containing prefix of dim. name or number (mod rank) */
{
    int                 i;
    int                 j;
    int                 status;

    assert(naoPtr);
    assert(str);
    status = sscanf(str, "%d", &i);
    if (status == 1) {
	i = Nap_mod(i, naoPtr->rank);
    } else {
	i = -1;
	for (j = 0; j < naoPtr->rank; j++) {
	    if(isPrefixOf(str, naoPtr->dimName[j])) {
		if (i == -1) {
		    i = j;
		} else {
		    return -1;		/* multiple matches! */
		}
	    }
	}
    }
    return i;
}

/*
 *  Nap_AttachCoordVar --
 *      Attach coordinate variable to NAO & assign name to dimension.
 *      If coordinate variable has too many elements then create new one.
 */

m4define(`m4NAME', `Nap_AttachCoordVar')

EXTERN int
Nap_AttachCoordVar(
    NapClientData	*nap_cd,
    Nap_NAO             *mainNaoPtr,	/* Main NAO */
    Nap_NAO             *coordNaoPtr,	/* New coord var (ignore if NULL) */
    char		*dimName,	/* New dim. name (ignore if NULL) */
    int                 dimNum)		/* Dimension number */
{
    int                 status;

    assert(mainNaoPtr);
    assert(dimNum >= 0);
    assert(dimNum < mainNaoPtr->rank);
    assert(mainNaoPtr->id);
    assert(Nap_IsNAO(nap_cd, mainNaoPtr));
    if (coordNaoPtr) {
	status = Nap_AttachCV(nap_cd, mainNaoPtr, coordNaoPtr, dimNum);
	CHECK(status == TCL_OK);
    }
    if (dimName) {
	status = Nap_SetDimName(nap_cd, mainNaoPtr, dimName, dimNum);
	CHECK(status == TCL_OK);
    }
    return TCL_OK;
}

/*
 *  Nap_AttachLink --
 *      Attach link-NAO to NAO after removing any old one.
 */

m4define(`m4NAME', `Nap_AttachLink')

EXTERN int
Nap_AttachLink(
    NapClientData	*nap_cd,
    Nap_NAO             *mainNaoPtr,	/* Main NAO */
    Nap_NAO             *linkNaoPtr)	/* New link NAO (may be NULL) */
{
    assert(mainNaoPtr);
    assert(Nap_IsNAO(nap_cd, mainNaoPtr));
    if (mainNaoPtr->linkSlot > 0) {
	Nap_DecrRefCount(nap_cd, Nap_GetNaoFromSlot(mainNaoPtr->linkSlot));
    }
    if (linkNaoPtr) {
	mainNaoPtr->linkSlot = linkNaoPtr->slot;
	Nap_IncrRefCount(nap_cd, linkNaoPtr);
    } else {
	mainNaoPtr->linkSlot = 0;
    }
    return TCL_OK;
}

/*
 *  Nap_GetClientData --
 *	Return pointer to 'Nap_ClientData' structure for specified interpreter
 */

m4define(`m4NAME', `Nap_GetClientData')

EXTERN NapClientData *
Nap_GetClientData(
    Tcl_Interp		*interp)
{
    NapClientData	*nap_cd;

    nap_cd = nap_client_data_new;
    while (nap_cd  &&  nap_cd->interp != interp) {
	nap_cd = nap_cd->next;
    }
    return nap_cd;
}

/*
 *  Nap_InterpDeleteProc --
 *	Delete 'Nap_ClientData' structure for specified interpreter
 */

m4define(`m4NAME', `Nap_InterpDeleteProc')

EXTERN void
Nap_InterpDeleteProc(
    ClientData		clientData,		/* not used */
    Tcl_Interp		*interp)
{
    NapClientData	*nap_cd;
    NapClientData	**p;

    p = &nap_client_data_new;
    while (*p  &&  (*p)->interp != interp) {
	p = &((*p)->next);
    }
    nap_cd = *p;
    assert(nap_cd);
    *p = nap_cd->next;
    m4ForAllDataType(`Nap_DecrRefCount(nap_cd, nap_cd->', `MissingValueNao);')
    FREE(nap_cd);
}

/*
 * Nap_CreateClientData --
 *
 *      Create NapClientData structure which contains what used to be global data
 */

EXTERN NapClientData *
Nap_CreateClientData(
    Tcl_Interp          *interp)
{
    NapClientData	*nap_cd;

    nap_cd = (NapClientData *) MALLOC(sizeof(NapClientData));
    nap_cd->interp = interp;
    nap_cd->recursionLimit = 0;
    nap_cd->parseLevel = -1;
    nap_cd->totalBytesNAO = 0;
    nap_cd->maxTotalBytesNAO = 0;
    nap_cd->result = NULL;
    nap_cd->result_bs = 0;
    nap_cd->result_n = 0;
    nap_cd->seqNum = 0;
    nap_cd->slotList = 0;
    nap_cd->lookup = NULL;
    nap_cd->lookupN = 1;
    nap_cd->lookupSize = 0;
    nap_cd->free = NULL;
    nap_cd->freeN = 0;
    nap_cd->freeSize = 0;
    nap_cd->next = nap_client_data_new;
    nap_client_data_new = nap_cd;
    m4ForAllDataType(`nap_cd->', `MissingValueNao = NULL;')
    Tcl_CallWhenDeleted(interp, Nap_InterpDeleteProc, 0);
    return nap_cd;
}

/*
 *  Nap_swap_bytes --
 *      Reverse order of bytes in each word of specified size
 */

m4define(`m4NAME', `Nap_swap_bytes')

EXTERN int
Nap_swap_bytes(
    NapClientData       *nap_cd,
    char		*a,	/* array to be adjusted */
    int			n,	/* number of words */
    int			size)	/* number of bytes per word */
{
    int			i;
    int			j;
    int			k0;
    int			k1;
    int			k2;
    int			size2;		/* size/2 */
    char		tmp;

    assert(a);
    CHECK2(size > 0, "m4NAME: size <= 0");
    if (size > 1) {
	CHECK2(size % 2 == 0, "m4NAME: size is odd");
	size2 = size / 2;
	for (i = 0; i < n; i++) {
	    k0 = size * i;
	    for (j = 0; j < size2; j++) {
		k1 = k0 + j;
		k2 = k0 + size - 1 - j;
		tmp = a[k1];
		a[k1] = a[k2];
		a[k2] = tmp;
	    }
	}
    }
    return TCL_OK;
}
