m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (nap_netcdf.c). */
/* It was produced from source file nap_netcdf.c,m4 */

/*
 *	nap_netcdf.c,m4 --
 *
 *	netcdf I/O
 *
 *	Copyright 2000, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Atmospheric Research
 */

#ifndef lint
static char *rcsid="@(#) $Id: nap_netcdf.c,m4,v 1.59 2004/12/08 05:34:36 dav480 Exp $";
#endif /* not lint */

#define CHECK2NC(STATUS, FORMAT) \
    if ((STATUS) != NC_NOERR) { \
	Nap_NetcdfCheck(nap_cd, STATUS); \
	Nap_Check(nap_cd, __FILE__, __LINE__, FORMAT); \
	return TCL_ERROR; \
    }

#define CHECK3NC(STATUS, FORMAT, A) \
    if ((STATUS) != NC_NOERR) { \
	Nap_NetcdfCheck(nap_cd, STATUS); \
	Nap_Check(nap_cd, __FILE__, __LINE__, FORMAT, A); \
	return TCL_ERROR; \
    }

#include "nap_netcdf.h"

#undef DEBUG	/* So D(printf("stuff");) does nothing */
#define DEBUG	/* So D(printf("stuff");) prints */
#ifdef DEBUG
#  define D(x) x
#else
#  define D(x)
#endif


m4define(`m4ForAllNcNumericDataType', `
$1`'U8$2
$1`'I8$2
$1`'I16$2
$1`'I32$2
$1`'F32$2
$1`'F64$2
')

m4define(`m4ForAllNcDataType', `
$1`'C8$2
m4ForAllNcNumericDataType(`$1',`$2')
')

m4define(`m4_C8_nc_name', `c8')
m4define(`m4_U8_nc_name', `uchar')
m4define(`m4_I8_nc_name', `schar')
m4define(`m4_I16_nc_name', `short')
m4define(`m4_I32_nc_name', `int')
m4define(`m4_F32_nc_name', `float')
m4define(`m4_F64_nc_name', `double')

m4define(`m4ncName', `m4_'$1`_nc_name()')


/*
 * Nap_Nap2NetcdfDataType --
 *
 *	Convert nap data-type to netCDF data-type.
 *	If argument is NAP_RAGGED, NAP_BOXED or NAP_NULL_TYPE then result is NC_NAT (Not A Type).
 *	This is also result if error.
 */

static nc_type
Nap_Nap2NetcdfDataType(
    Nap_dataType	dataType)
{
    switch (dataType) {
	case NAP_C8:		return NC_CHAR;
	case NAP_U8:
	case NAP_I8:		return NC_BYTE;
	case NAP_U16:
	case NAP_I16:		return NC_SHORT;
	case NAP_U32:
	case NAP_I32:		return NC_INT;
	case NAP_F32:		return NC_FLOAT;
	case NAP_F64:		return NC_DOUBLE;
    }
    return NC_NAT;
}


/*
 * Nap_Netcdf2NapDataType --
 *
 *	Convert netCDF data-type to nap data-type.
 *	If error then result is NAP_NULL_TYPE.
 */

static Nap_dataType
Nap_Netcdf2NapDataType(
    nc_type		dataType)
{
    switch (dataType) {
	case NC_CHAR:		return NAP_C8;
	case NC_BYTE:		return NAP_U8;
	case NC_SHORT:		return NAP_I16;
	case NC_INT:		return NAP_I32;
	case NC_FLOAT:		return NAP_F32;
	case NC_DOUBLE:		return NAP_F64;
    }
    return NAP_NULL_TYPE;
}

/*
 * Following 4 functions provide interface to netcdf text functions
 */

static int
nc_put_vara_c8(int ncid, int varid, const size_t *startp, const size_t *countp, Nap_c8 *op)
{
    return nc_put_vara_text(ncid, varid, startp, countp, (char *) op);
}

static int
nc_get_vara_c8(int ncid, int varid, const size_t *startp, const size_t *countp, Nap_c8 *ip)
{
    return nc_get_vara_text(ncid, varid, startp, countp, (char *) ip);
}

static int
nc_put_att_c8(int ncid, int varid, const char *name, size_t len, Nap_c8 *op)
{
    return nc_put_att_text(ncid, varid, name, len, (char *) op);
}

static int
nc_get_att_c8(int ncid, int varid, const char *name, Nap_c8 *ip)
{
    return nc_get_att_text(ncid, varid, name, (char *) ip);
}


/*
 * Nap_NetcdfCheck --
 *
 *	Append netcdf error messages to message.
 */

m4define(`m4NAME', `Nap_NetcdfCheck')

static void
Nap_NetcdfCheck(
    NapClientData       *nap_cd,
    int ncerr)
{
    char		msg[201];
    const char		*str;

    str = nc_strerror(ncerr);
    (void) sprintf(msg, "netCDF error code %d.	%0.99s", ncerr, str);
    Nap_CheckAppendLine(nap_cd, msg);
    return;
}

/*
 * Nap_NetcdfVarGetInfo --
 *
 *	Get rank, shape & netCDF (external) data-type
 *	Determine whether dimension 0 is unlimited. (If rank is 0 then false.)
 */

m4define(`m4NAME', `Nap_NetcdfVarGetInfo')

static int
Nap_NetcdfVarGetInfo(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,			/* var handle */
    int			*rank,
    size_t		*shape,
    nc_type		*xtype,
    int			*isRecord)		/* Is dim 0 unlimited? (can be NULL) */
{
    int			dimids[NAP_MAX_RANK];
    int			dimid_unlim;		/* ID of unlimited dimension */
    int			i;
    size_t		n;
    int			status;

    assert(rank);
    assert(shape);
    assert(xtype);
    status = nc_inq_varndims(ncid, varid, rank);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_varndims");
    status = nc_inq_vardimid(ncid, varid, dimids);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_vardimid");
    for (i = 0; i < *rank; i++) {
	status = nc_inq_dimlen(ncid, dimids[i], &n);
	CHECK2NC(status, "m4NAME: Error calling nc_inq_dimlen");
	shape[i] = n;
    }
    status = nc_inq_vartype(ncid, varid, xtype);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_vartype");
    if (isRecord) {
	if (*rank > 0) {
	    status = nc_inq_unlimdim(ncid, &dimid_unlim);
	    CHECK2NC(status, "m4NAME: Error calling nc_inq_unlimdim");
	    *isRecord = dimids[0] == dimid_unlim;
	} else {
	    *isRecord = 0;
	}
    }
    return TCL_OK;
}


/*
 * Nap_NetcdfGetScalingInfo --
 *
 *	Get (uncalibrated) internal_number_type, scale_factor, offset & valid_range.
 *	If unscaled, then set:
 *	    internal_number_type = external_number_type,
 *	    offset = 0, scale_factor = 1,
 *	    valid_range to (min, max) for internal data type.
 */

m4begin

m4define(`m4NAME', `Nap_NetcdfGetScalingInfo')

#  m4range(externalDataType)
m4define(`m4range', `
	case m4DataTypeEnum($1):
	    valid_range[0] = m4DataTypeEnum($1)_MIN;
	    valid_range[1] = m4DataTypeEnum($1)_MAX;
	    break;')

m4end

static int
Nap_NetcdfGetScalingInfo(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,			/* var handle */
    int                 raw,            	/* 1 to request raw data */
    nc_type		*internal_number_type,
    double		*scale_factor,
    double		*offset,
    double		valid_range[2])
{
    nc_type		external_number_type;
    Nap_dataType	externalDataType;
    int			status;
    nc_type		type;

    assert(internal_number_type);
    assert(scale_factor);
    assert(offset);
    status = nc_inq_vartype(ncid, varid, &external_number_type);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_vartype");
    *internal_number_type = external_number_type;
    externalDataType = Nap_Netcdf2NapDataType(external_number_type);
    CHECK2(Nap_ValidDataType(externalDataType), "m4NAME: Illegal datatype");
    *scale_factor = 1.0;
    *offset = 0.0;
    switch (externalDataType) {
	m4ForAllNcDataType(`m4range(', `)')
	default:		/* error */
	    CHECK2(0, "m4NAME: Illegal datatype for netCDF");
    }
    if (!raw) {
	status = nc_get_att_double(ncid, varid, "scale_factor", scale_factor);
	if (status == NC_NOERR) {
	    status = nc_inq_atttype(ncid, varid, "scale_factor", &type);
	    CHECK2NC(status, "m4NAME: Error calling nc_inq_atttype");
	    *internal_number_type = Max(*internal_number_type, type);
	}
	status = nc_get_att_double(ncid, varid, "add_offset", offset);
	if (status == NC_NOERR) {
	    status = nc_inq_atttype(ncid, varid, "add_offset", &type);
	    CHECK2NC(status, "m4NAME: Error calling nc_inq_atttype");
	    *internal_number_type = Max(*internal_number_type, type);
	}
	status = nc_get_att_double(ncid, varid, "valid_range", valid_range);
	if (status != NC_NOERR) {
	    status = nc_get_att_double(ncid, varid, "valid_min", valid_range);
	    status = nc_get_att_double(ncid, varid, "valid_max", valid_range+1);
	}
	if (valid_range[0] > valid_range[1]) {
	    double old0 = valid_range[0];
	    valid_range[0] = valid_range[1];
	    valid_range[1] = old0;
	}
    }
    return TCL_OK;
}

/*
 * Nap_NetcdfOpenFile --
 *
 *	Open file.  If it does not already exist then create it.
 */

m4define(`m4NAME', `Nap_NetcdfOpenFile')

static int
Nap_NetcdfOpenFile(
    NapClientData       *nap_cd,
    char		*fileName,		/* netCDF file name */
    char		mode,			/* 'r' = read, 'w' = write */
    int			*nc_id)			/* file handle (out) */
{
    char		*nativeFilename;	/* filename for platform */
    int			ncid;			/* netcdf file id */
    int			status;

    assert(fileName);
    assert(nc_id);
    nativeFilename = Nap_GetFileName(nap_cd, fileName);
    CHECK2(nativeFilename, "m4NAME: Illegal fileName");
    switch (mode) {
    case 'r':
	status = nc_open(nativeFilename, NC_NOWRITE, &ncid);
	CHECK3NC(status, "m4NAME: Error calling nc_open to open file %s", fileName);
	*nc_id = ncid;
	break;
    case 'w':
	status = nc_open(nativeFilename, NC_WRITE, &ncid);
	if (status != NC_NOERR) {
	    status = nc_create(nativeFilename, NC_NOCLOBBER, &ncid);
	    CHECK3NC(status, "m4NAME: Error calling nc_create to create file %s",
		    fileName);
	}
	*nc_id = ncid;
	break;
    default:
	CHECK2(FALSE, "m4NAME: Illegal file access mode");
    }
    FREE(nativeFilename);
    return TCL_OK;
}

/*
 * Nap_NetcdfCloseFile --
 */

m4define(`m4NAME', `Nap_NetcdfCloseFile')

static int
Nap_NetcdfCloseFile(
    NapClientData       *nap_cd,
    int			ncid)			/* file handle */
{
    int			status;

    status = nc_close(ncid);
    CHECK2NC(status, "m4NAME: Unable to close file");
    return TCL_OK;
}

/*
 *	Nap_NetcdfOpenVar --
 *
 *	Attempt to open Var.
 *	Set *exists to TRUE/FALSE depending on whether Var exists.
 *	If so set *varid to Var ID.
 */

m4define(`m4NAME', `Nap_NetcdfOpenVar')

static int
Nap_NetcdfOpenVar(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    char		*name_var,		/* Var name */
    int			*exists,		/* Var exists? (out) */
    int			*varid)			/* Var handle (out) */
{
    int			status;

    assert(name_var);
    assert(exists);
    assert(varid);
    status = nc_inq_varid(ncid, name_var, varid);
    *exists = status == NC_NOERR;
    return TCL_OK;
}

/*
 * Nap_NetcdfPutVar --
 */

m4begin

m4define(`m4NAME', `Nap_NetcdfPutVar')

#  m4putVar(dataType)  e.g. m4putVar(f32)
m4define(`m4putVar', `
	case m4DataTypeEnum($1):
	    status = nc_put_vara_`'m4ncName($1)(ncid, varid, start, edge,
		    (m4DataTypeName($1) *) data);
	    CHECK2NC(status, "m4NAME: Error calling nc_put_vara_`'m4ncName($1)");
	    break;')

m4end

static int
Nap_NetcdfPutVar(
    NapClientData       *nap_cd,
    int			ncid,		/* file handle */
    int			varid,		/* Var handle */
    char		*data,
    size_t		*start,
    size_t		*edge)
{
    Nap_dataType	dataType;	/* corresponds to xtype */
    int			i;
    int			rank;
    size_t		shape[NAP_MAX_RANK];
    int			status;
    nc_type		xtype;		/* external type of Var */

    assert(data);
    assert(start);
    assert(edge);
    status = Nap_NetcdfVarGetInfo(nap_cd, ncid, varid, &rank, shape, &xtype, NULL);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
    dataType = Nap_Netcdf2NapDataType(xtype);
    CHECK2(Nap_ValidDataType(dataType), "m4NAME: Illegal datatype");
    for (i = 0; i < rank-1; i++) {
	assert(edge[i] == 1);
    }
    status = nc_enddef(ncid);
    switch (dataType) {
	m4ForAllNcDataType(`m4putVar(', `)')
	default:	    /* error */
	    CHECK2(0, "m4NAME: Illegal datatype for netCDF");
    }
    return TCL_OK;
}


/*
 *	Nap_NetcdfCreateVar --
 *
 *	Use netcdf library to create netcdf variable.
 */

m4begin

m4define(`m4NAME', `Nap_NetcdfCreateVar')

#  m4putFill(dataType)  e.g. m4putFill(f32)
m4define(`m4putFill', `
        case m4DataTypeEnum($1):
	    status = nc_put_att_`'m4ncName($1)(ncid, varid, "_FillValue", xtype, 1,
		    tmp_NAO->data.$1);
	    CHECK2NC(status, "m4NAME: Error calling nc_put_att_`'m4ncName($1)");
            break;')

m4end

static int
Nap_NetcdfCreateVar(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    char		*varname,		/* variable name */
    Nap_dataType	dataType,		/* external data type */
    int			rank,			/* required rank */
    size_t		shape_t[],		/* required shape */
    Nap_NAO		*cv[],			/* coord. vars (may be NULL) */
    char		*dimName[],		/* dim. names (may be NULL) */
    Nap_NAO		*scale_factor_NAO,	/* (may be NULL) */
    Nap_NAO		*add_offset_NAO,	/* (may be NULL) */
    Nap_NAO		*valid_range_NAO,	/* (may be NULL) */
    Nap_NAO		*missingValue_NAO,	/* fill value (may be NULL) */
    char		*format,		/* (may be NULL) */
    char		*label,			/* (may be NULL) */
    char		*unit,			/* (may be NULL) */
    int			isRecord)               /* Want unlimited dim in new var? */
{
    char		dim_name[20];
    int			dimid[NAP_MAX_RANK];
    size_t		edge[1];
    int			i;
    char		*p_dim_name;
    size_t		start[1];
    int			status;
    double		tmp_double;
    Nap_NAO		*tmp_NAO;
    int			varid;
    nc_type		xtype;			/* External netcdf data type */

    for (i = 0; i < rank; i++) {
	if (dimName[i]  &&  Nap_lexSimpleName(dimName[i]) == strlen(dimName[i])) {
	    p_dim_name = dimName[i];
	} else {
	    p_dim_name = dim_name;
	    status = sprintf(p_dim_name, "%0.8s_dim_%d", varname, i);
	}
	status = nc_redef(ncid);
	if (i == 0  &&  isRecord) {
	    status = nc_def_dim(ncid, p_dim_name, NC_UNLIMITED, dimid+i);
	} else {
	    status = nc_def_dim(ncid, p_dim_name, shape_t[i], dimid+i);
	}
	if (status != NC_NOERR) {
	    status = nc_inq_dimid(ncid, p_dim_name, dimid+i);
	    CHECK2NC(status, "m4NAME: Error calling nc_inq_dimid");
	}
	if (cv	&&  cv[i]) {
	    xtype = Nap_Nap2NetcdfDataType(cv[i]->dataType);
	    CHECK2(xtype != NC_NAT, "m4NAME: Error calling Nap_Nap2NetcdfDataType");
	    status = nc_def_var(ncid, p_dim_name, xtype, 1, dimid+i, &varid);
	    if (status != NC_NOERR) {
		status = nc_inq_varid(ncid, p_dim_name, &varid);
		CHECK2NC(status, "m4NAME: Error calling nc_inq_varid");
	    }
	    if (cv[i]->format) {
		status = nc_put_att_text(ncid, varid, "C_format", strlen(cv[i]->format),
			cv[i]->format);
		CHECK2NC(status, "m4NAME: Error calling nc_put_att_text");
	    }
	    if (cv[i]->label) {
		status = nc_put_att_text(ncid, varid, "long_name", strlen(cv[i]->label),
			cv[i]->label);
		CHECK2NC(status, "m4NAME: Error calling nc_put_att_text");
	    }
	    if (cv[i]->unit) {
		status = nc_put_att_text(ncid, varid, "units", strlen(cv[i]->unit),
			cv[i]->unit);
		CHECK2NC(status, "m4NAME: Error calling nc_put_att_text");
	    }
	    start[0] = 0;
	    edge[0] = cv[i]->nels;
	    status = Nap_NetcdfPutVar(nap_cd, ncid, varid, cv[i]->data.c, start, edge);
	    CHECK(status == TCL_OK);
	}
    }
    status = nc_redef(ncid);
    xtype = Nap_Nap2NetcdfDataType(dataType);
    CHECK2(xtype != NC_NAT, "m4NAME: Error calling Nap_Nap2NetcdfDataType");
    status = nc_def_var(ncid, varname, xtype, rank, dimid, &varid);
    CHECK2NC(status, "m4NAME: Error calling nc_def_var");
    if (scale_factor_NAO) {
	status = Nap_F64ScalarValue(nap_cd, scale_factor_NAO, &tmp_double);
	CHECK(status == TCL_OK);
	status = nc_put_att_double (ncid, varid, "scale_factor",
		Nap_Nap2NetcdfDataType(scale_factor_NAO->dataType), 1, &tmp_double);
	CHECK2NC(status, "m4NAME: Error calling nc_put_att_double");
    }
    if (add_offset_NAO) {
	status = Nap_F64ScalarValue(nap_cd, add_offset_NAO, &tmp_double);
	CHECK(status == TCL_OK);
	status = nc_put_att_double (ncid, varid, "add_offset",
		Nap_Nap2NetcdfDataType(add_offset_NAO->dataType), 1, &tmp_double);
	CHECK2NC(status, "m4NAME: Error calling nc_put_att_double");
    }
    if (valid_range_NAO) {
	CHECK2(valid_range_NAO->rank == 1, "m4NAME: valid_range not vector");
	CHECK2(valid_range_NAO->nels == 2, "m4NAME: nels(valid_range) != 2");
	tmp_NAO = Nap_CastNAO(nap_cd, valid_range_NAO, NAP_F64);
	CHECK2(tmp_NAO, "m4NAME: Error calling Nap_CastNAO");
	if (tmp_NAO->data.F64[0] > tmp_NAO->data.F64[1]) {
	    double old0 = tmp_NAO->data.F64[0];
	    tmp_NAO->data.F64[0] = tmp_NAO->data.F64[1];
	    tmp_NAO->data.F64[1] = old0;
	}
	status = nc_put_att_double (ncid, varid, "valid_range", xtype, 2, tmp_NAO->data.F64);
	CHECK2NC(status, "m4NAME: Error calling nc_put_att_double");
	if (tmp_NAO != valid_range_NAO) {
	    Nap_FreeNAO(nap_cd, tmp_NAO);
	}
    }
    if (missingValue_NAO) {
	tmp_NAO = Nap_CastNAO(nap_cd, missingValue_NAO, dataType);
	CHECK2(tmp_NAO, "m4NAME: Error calling Nap_CastNAO");
	switch (dataType) {
	    case NAP_C8:
		status = nc_put_att_text(ncid, varid, "_FillValue", 1, tmp_NAO->data.c);
		CHECK2NC(status, "m4NAME: Error calling nc_put_att_text");
		break;
	    m4ForAllNcNumericDataType(`m4putFill(', `)')
	    default:            /* error */
		assert(FALSE);
	}
	if (tmp_NAO != missingValue_NAO) {
	    Nap_FreeNAO(nap_cd, tmp_NAO);
	}
    }
    if (format) {
	status = nc_put_att_text(ncid, varid, "C_format", strlen(format), format);
	CHECK2NC(status, "m4NAME: Error calling nc_put_att_text");
    }
    if (label) {
	status = nc_put_att_text(ncid, varid, "long_name", strlen(label), label);
	CHECK2NC(status, "m4NAME: Error calling nc_put_att_text");
    }
    if (unit) {
	status = nc_put_att_text(ncid, varid, "units", strlen(unit), unit);
	CHECK2NC(status, "m4NAME: Error calling nc_put_att_text");
    }
    return TCL_OK;
}


/*
 *	Nap_CreateVar --
 *
 *	Create netCDF variable
 */

m4define(`m4NAME', `Nap_CreateVar')

static int
Nap_CreateVar(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    char		*var_name,		/* Var name */
    Nap_dataType	dataType,		/* Netcdf data type */
    int			rank,			/* required rank */
    size_t		shape_t[],		/* required shape */
    Nap_NAO		*cv[],			/* coord. vars (may be NULL) */
    char		*dimName[],		/* dim. names (may be NULL) */
    Nap_NAO		*scale_factor_NAO,	/* (may be NULL) */
    Nap_NAO		*add_offset_NAO,	/* (may be NULL) */
    Nap_NAO		*valid_range_NAO,	/* (may be NULL) */
    Nap_NAO		*missingValue_NAO,	/* fill value */
    char		*format,		/* (may be NULL) */
    char		*label,			/* (may be NULL) */
    char		*unit,			/* (may be NULL) */
    int			isRecord,               /* Want unlimited dim in new var? */
    int			*varid)			/* Var handle (out) */
{
    int			exists;			/* Var exists? */
    int			status;

    assert(var_name);
    assert(varid);
    status = Nap_NetcdfCreateVar(
	    nap_cd,
	    ncid,
	    var_name,
	    dataType,
	    rank,
	    shape_t,
	    cv,
	    dimName,
	    scale_factor_NAO,
	    add_offset_NAO,
	    valid_range_NAO,
	    missingValue_NAO,
	    format,
	    label,
	    unit,
	    isRecord);
    CHECK(status == TCL_OK);
    status = Nap_NetcdfOpenVar(nap_cd, ncid, var_name, &exists, varid);
    CHECK(status == TCL_OK);
    CHECK2(exists, "m4NAME: Var does not exist");
    CHECK(status == TCL_OK);
    return TCL_OK;
}


/*
 * Nap_NetcdfGetVar --
 */

m4begin

m4define(`m4NAME', `Nap_NetcdfGetVar')

#  m4getVar(internal_data_type)
m4define(`m4getVar', `
	case m4DataTypeEnum($1):
	    {
		m4DataTypeName($1) *ptr = (m4DataTypeName($1) *) data;
		m4DataTypeName($1) mv = mv_nao ? mv_nao->data.$1[0] : m4MissingValue($1);
		status = nc_get_vara_`'m4ncName($1)(ncid, varid, start_t, count_t, ptr);
		CHECK2NC(status, "m4NAME: Error calling nc_get_vara_`'m4ncName($1)");
		for (i = 0; i < nels; i++) {
		    ptr[i] = 
#if   Nap_TypeIsF32Value($1)
			    IsNaN32(ptr[i])  ||
#elif Nap_TypeIsF64Value($1)
			    IsNaN64(ptr[i])  ||
#endif
			    ptr[i] < zmin  ||  ptr[i] > zmax
			    ? mv
			    : sf * ptr[i] + off;
		}
	    }
	    break;')

m4end

static int
Nap_NetcdfGetVar(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,			/* Var handle */
    int                 raw,            	/* 1 to request raw data */
    char		*data,
    Nap_NAO		*mv_nao,		/* missing value of destination nao */
    size_t		*start,
    size_t		*edge)
{
    double		sf;			/* scale factor */
    size_t		count_t[NAP_MAX_RANK];
    int			i;
    nc_type		internal_number_type;
    Nap_dataType	internalDataType;
    int			nels;
    double		off;			/* add offset */
    int			rank;
    size_t		start_t[NAP_MAX_RANK];
    int			status;
    double		valid_range[2];		/* min, max */
    double		zmax;			/* from valid_range */
    double		zmin;			/* from valid_range */

    assert(data);
    assert(start);
    assert(edge);
    status = nc_inq_varndims(ncid, varid, &rank);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_varndims");
    nels = 1;
    for (i = 0; i < rank; i++) {
	start_t[i] = start[i];
	count_t[i] = edge[i];
	nels *= edge[i];
    }
    status = Nap_NetcdfGetScalingInfo(nap_cd, ncid, varid, raw, &internal_number_type, &sf,
	    &off, valid_range);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfGetScalingInfo");
    zmin = valid_range[0];
    zmax = valid_range[1];
    internalDataType = Nap_Netcdf2NapDataType(internal_number_type);
    CHECK2(Nap_ValidDataType(internalDataType), "m4NAME: Illegal datatype");
    status = nc_enddef(ncid);
    switch (internalDataType) {
	m4ForAllNcDataType(`m4getVar(', `)')
	default:	    /* error */
	    CHECK2(0, "m4NAME: Illegal datatype for netCDF");
    }
    return TCL_OK;
}

/*
 * Nap_NetcdfScaleBeforePut --
 *
 * Scale data ready for write.	Also set missing values to Var fill value.
 */

m4begin

m4define(`m4NAME', `Nap_NetcdfScaleBeforePut')

# m4scale2(new_data_type, old_data_type)  e.g. m4scale2(f32, u8)
m4define(`m4scale2', `
	    case m4DataTypeEnum($2):
		if (new_NAO->dataType == old_NAO->dataType
			&&  cal == 1.0	&&  off == 0.0) {
		    for (i = 0; i < old_NAO->nels; i++) {
			if (IsMissing(old_NAO, i)) {
			    new_NAO->data.$1[i] = fill_nao->data.$1[0];
			} else {
			    new_NAO->data.$1[i] = old_NAO->data.$2[i];
			}
		    }
		} else {
		    for (i = 0; i < old_NAO->nels; i++) {
			if (IsMissing(old_NAO, i)) {
			    new_NAO->data.$1[i] = fill_nao->data.$1[0];
			} else {
			    z = (old_NAO->data.$2[i] - off) * rcal;
#if Nap_TypeIsIntegerValue($1)
			    z = Nint(z);
			    z = Max(zmin, z);
			    z = Min(zmax, z);
#endif
			    new_NAO->data.$1[i] = z;
			}
		    }
		}
		break;')

#  m4scale(new_data_type)
m4define(`m4scale', `
	case m4DataTypeEnum($1):
	    switch (old_NAO->dataType) {
	    m4ForAllNcDataType(`m4scale2($1, ', `)')
	    default:		/* error */
		CHECK2(0, "m4NAME: Illegal datatype for netCDF");
	    }
	    break;')

m4end

static int
Nap_NetcdfScaleBeforePut(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,			/* Var handle */
    Nap_NAO		*old_NAO,		/* unscaled original NAO */
    Nap_NAO		**new_NAO_Ptr)		/* scaled NAO */
{
    double		cal;
    Nap_dataType	dataType;
    Nap_NAO		*fill_nao;		/* Var fill value */
    size_t		i;
    double		mv;			/* missing value */
    Nap_NAO		*new_NAO;		/* result */
    nc_type		number_type;
    double		off;
    int			rank32;
    double		rcal;			/* 1/cal */
    size_t		shape[NAP_MAX_RANK];
    size_t		shape_t[NAP_MAX_RANK];
    int			status;
    double		valid_range[2];		/* min, max */
    double		z;			/* new data value */
    double		zmax;			/* from valid_range */
    double		zmin;			/* from valid_range */

    status = Nap_NetcdfGetScalingInfo(nap_cd, ncid, varid, 0,
	    &number_type, &cal, &off, valid_range);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfGetScalingInfo");
    rcal = 1.0 / cal;
    zmin = valid_range[0];
    zmax = valid_range[1];
    status = Nap_NetcdfVarGetInfo(nap_cd, ncid, varid, &rank32, shape_t, &number_type, NULL);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
    CHECK2(rank32 >= old_NAO->rank, "m4NAME: Main NAO has rank > that of Var");
    dataType = Nap_Netcdf2NapDataType(number_type);
    CHECK2(Nap_ValidDataType(dataType), "m4NAME: Illegal datatype");
    status = nc_get_att_double(ncid, varid, "_FillValue", &mv);
    if (status == NC_NOERR) {
	fill_nao = Nap_NewScalarNAO(nap_cd, dataType, mv);
	CHECK2(fill_nao, "m4NAME: Error calling Nap_NewScalarNAO");
    } else {
	fill_nao = Nap_StandardMissingValueNAO(nap_cd, dataType);
	CHECK2(fill_nao, "m4NAME: Error calling Nap_StandardMissingValueNAO");
    }
    Nap_IncrRefCount(nap_cd, fill_nao);
    for (i = 0; i < rank32; i++) {
	shape[i] = 1;
    }
    for (i = 0; i < old_NAO->rank; i++) {
	shape[rank32 - old_NAO->rank + i] = old_NAO->shape[i];
    }
    new_NAO = Nap_NewNAO(nap_cd, dataType, rank32, shape);
    CHECK2(new_NAO, "m4NAME: Error calling Nap_NewNAO");
    switch (dataType) {
	m4ForAllNcDataType(`m4scale(', `)')
	default:	    /* error */
	    CHECK2(0, "m4NAME: Illegal datatype for netCDF");
    }
    Nap_DecrRefCount(nap_cd, fill_nao);
    *new_NAO_Ptr = new_NAO;
    return TCL_OK;
}

/*
 * Nap_NetcdfGetAttribute --
 */

m4begin

m4define(`m4NAME', `Nap_NetcdfGetAttribute')

#  m4getAtt(data_type)
m4define(`m4getAtt', `
	case m4DataTypeEnum($1):
	    status = nc_get_att_`'m4ncName($1)(ncid, varid, name_att, main_NAO->data.$1);
	    CHECK2NC(status, "m4NAME: Error calling nc_get_att_`'m4ncName($1)");
	    break;')

m4end

static int
Nap_NetcdfGetAttribute(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    char		*name,			/* Var:ATT */
    Nap_NAO		*main_NAO)		/* attribute NAO */
{
    Nap_dataType	dataType;
    int			exists;			/* Var exists? */
    char		*name_att;		/* name of attribute */
    char		name_var[2*NC_MAX_NAME+2]; /* with space for name_att */
    nc_type		number_type;
    int			varid;
    size_t		shape_t[NAP_MAX_RANK];
    int			status;

    CHECK2(main_NAO, "m4NAME: Pointer to main NAO is NULL");
    if (main_NAO->nels == 0) {
	return TCL_OK;
    }
    CHECK2(main_NAO->rank < 2, "m4NAME: main NAO rank > 1");
    CHECK2(strlen(name) <= 2*NC_MAX_NAME+1,
	    "m4NAME: <Var:ATTRIBUTE> is too long");
    (void) strcpy(name_var, name);
    name_att = strchr(name_var, ':');
    assert(name_att);
    *name_att = '\0';
    ++name_att;
    number_type = Nap_Nap2NetcdfDataType(main_NAO->dataType);
    CHECK2(number_type != NC_NAT, "m4NAME: Error calling Nap_Nap2NetcdfDataType");
    if (strlen(name_var) == 0) {
	varid = NC_GLOBAL;
    } else {
	status = Nap_NetcdfOpenVar(nap_cd, ncid, name_var, &exists, &varid);
	CHECK(status == NC_NOERR);
	CHECK2(exists, "m4NAME: Var does not exist");
    }
    status = nc_inq_att(ncid, varid, name_att, &number_type, shape_t);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_att");
    CHECK2(1 == main_NAO->rank, "m4NAME: Netcdf rank != NAO rank");
    dataType = Nap_Netcdf2NapDataType(number_type);
    CHECK2(Nap_ValidDataType(dataType), "m4NAME: Illegal datatype");
    CHECK2(dataType == main_NAO->dataType, "m4NAME: Netcdf dataType != NAO dataType");
    CHECK2(main_NAO->nels >= shape_t[0], "m4NAME: NAO has too few elements");
    switch (dataType) {
	m4ForAllNcDataType(`m4getAtt(', `)')
	default:	    /* error */
	    CHECK2(0, "m4NAME: Illegal datatype for netCDF");
    }
    return TCL_OK;
}

/*
 * Nap_NetcdfPutAttribute --
 */

m4begin

m4define(`m4NAME', `Nap_NetcdfPutAttribute')

#  m4putAtt(data_type)
m4define(`m4putAtt', `
	case m4DataTypeEnum($1):
	    status = nc_put_att_`'m4ncName($1)(ncid, varid, name_att,
		    xtype, main_NAO->nels, main_NAO->data.$1);
	    CHECK2NC(status, "m4NAME: Error calling nc_put_att_`'m4ncName($1)");
	    break;')

m4end


static int
Nap_NetcdfPutAttribute(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    char		*name,			/* Var:ATT */
    Nap_NAO		*main_NAO)		/* attribute NAO */
{
    int			exists;			/* Var exists? */
    char		*name_att;		/* name of attribute */
    char		name_var[2*NC_MAX_NAME+2]; /* with space for name_att */
    int			varid;
    int			status;
    nc_type		xtype;			/* External netcdf data type */

    CHECK2(main_NAO, "m4NAME: Pointer to main NAO is NULL");
    if (main_NAO->nels == 0) {
	return TCL_OK;
    }
    CHECK2(main_NAO->rank < 2, "m4NAME: main NAO rank > 1");
    CHECK2(strlen(name) <= 2*NC_MAX_NAME+1, "m4NAME: <Var:ATTRIBUTE> is too long");
    (void) strcpy(name_var, name);
    name_att = strchr(name_var, ':');
    assert(name_att);
    *name_att = '\0';
    ++name_att;
    if (strlen(name_var) == 0) {
	varid = NC_GLOBAL;
    } else {
	status = Nap_NetcdfOpenVar(nap_cd, ncid, name_var, &exists, &varid);
	CHECK(status == NC_NOERR);
	CHECK2(exists, "m4NAME: Var does not exist");
    }
    xtype = Nap_Nap2NetcdfDataType(main_NAO->dataType);
    CHECK2(xtype != NC_NAT, "m4NAME: Error calling Nap_Nap2NetcdfDataType");
    status = nc_redef(ncid);
    switch (main_NAO->dataType) {
	case NAP_C8:
	    status = nc_put_att_text(ncid, varid, name_att, main_NAO->nels, main_NAO->data.c);
	    CHECK2NC(status, "m4NAME: Error calling nc_put_att_text");
	    break;
	m4ForAllNcNumericDataType(`m4putAtt(', `)')
	default:	    /* error */
	    assert(FALSE);
    }
    return TCL_OK;
}


/*
 * Nap_NetcdfGetStdAtts --
 *
 *	Get standard attributes "long_name" & "units" from file & put into NAO.
 */

m4define(`m4NAME', `Nap_NetcdfGetStdAtts')

static int
Nap_NetcdfGetStdAtts(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,
    Nap_NAO		*nao)
{
    size_t		count;			/* length of attribute */
    int			status;

    status = nc_inq_attlen(ncid, varid, "C_format", &count);
    if (status == NC_NOERR) {
	nao->format = (char *) MALLOC(count+1);
	assert(nao->format);
	status = nc_get_att_text(ncid, varid, "C_format", nao->format);
	CHECK2NC(status, "m4NAME: Error calling nc_get_att_text");
	nao->format[count] = '\0';
    }
    status = nc_inq_attlen(ncid, varid, "long_name", &count);
    if (status == NC_NOERR) {
	nao->label = (char *) MALLOC(count+1);
	assert(nao->label);
	status = nc_get_att_text(ncid, varid, "long_name", nao->label);
	CHECK2NC(status, "m4NAME: Error calling nc_get_att_text");
	nao->label[count] = '\0';
    }
    status = nc_inq_attlen(ncid, varid, "units", &count);
    if (status == NC_NOERR) {
	nao->unit = (char *) MALLOC(count+1);
	assert(nao->unit);
	status = nc_get_att_text(ncid, varid, "units", nao->unit);
	CHECK2NC(status, "m4NAME: Error calling nc_get_att_text");
	nao->unit[count] = '\0';
    }
    return TCL_OK;
}


/*
 * Nap_NetcdfGetDim --
 *
 *	Get coordinate-variable & dimension-name from file.
 *	If no coordinate-variable then coordinate-variable result is NULL.
 *	If main var is itself coordinate-variable (has same name as dimension) then
 *	coordinate-variable result is NULL.
 *	If cv_nc_NAO or name is NULL then do not define it.
 */

m4define(`m4NAME', `Nap_NetcdfGetDim')

static int
Nap_NetcdfGetDim(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,
    int			dim_index,
    Nap_NAO		**cv_nc_NAO,		/* result (out: malloced here) */
    char		*name)			/* result (out) */
{
    int			cv_varid;
    Nap_dataType	dataType;
    int			dimid[NAP_MAX_RANK];
    size_t		edge[1];
    int			exists;			/* cv exists? */
    char		local_name[NC_MAX_NAME];
    nc_type		number_type;
    int			rank;
    size_t		shape[NAP_MAX_RANK];	/* shape of coord var */
    size_t		start[1];
    int			status;
    char		varname[NC_MAX_NAME];

    status = nc_inq_vardimid(ncid, varid, dimid);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_vardimid");
    name = name ? name : local_name;
    status = nc_inq_dimname(ncid, dimid[dim_index], name);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_dimname");
    if (cv_nc_NAO) {
	status = Nap_NetcdfOpenVar(nap_cd, ncid, name, &exists, &cv_varid);
	CHECK(status == TCL_OK);
	status = nc_inq_varname(ncid, varid, varname);
	CHECK2NC(status, "m4NAME: Error calling nc_inq_varname");
	if (exists  &&  strcmp(varname, name) != 0) {
	    status = Nap_NetcdfVarGetInfo(nap_cd, ncid, cv_varid, &rank, shape, &number_type, NULL);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
	    CHECK2(rank == 1, "m4NAME: rank of coordinate variable is not 1");
	    dataType = Nap_Netcdf2NapDataType(number_type);
	    CHECK2(Nap_ValidDataType(dataType), "m4NAME: Illegal datatype");
	    *cv_nc_NAO = Nap_NewNAO(nap_cd, dataType, 1, shape);
	    CHECK2(*cv_nc_NAO, "m4NAME: Error calling Nap_NewNAO");
	    start[0] = 0;
	    edge[0] = shape[0];
	    status = Nap_NetcdfGetVar(nap_cd, ncid, cv_varid, 0, (*cv_nc_NAO)->data.c,
		    NULL, start, edge);
	    CHECK(status == TCL_OK);
	    status = Nap_NetcdfGetStdAtts(nap_cd, ncid, cv_varid, *cv_nc_NAO);
	    CHECK(status == TCL_OK);
	} else {
	    *cv_nc_NAO = NULL;
	}
    }
    return TCL_OK;
}

/*
 * Nap_NetcdfDefineSubscript --
 *
 *	Use subscript_NAO to define subscript_ptr, start_t, count_t.
 *	If needed malloc buffer (else NULL).
 *	If doing input (mode == 'r') then attach coordinate vars to main_NAO.
 */

m4define(`m4NAME', `Nap_NetcdfDefineSubscript')

static int
Nap_NetcdfDefineSubscript(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,
    Nap_NAO		*main_NAO,		/* main nao (in) */
    char		mode,			/* 'r' = read, 'w' = write */
    Nap_NAO		*subscript_NAO,		/* (boxed) subscript nao (in) */
    int			*subscript_ptr[],	/* ragged matrix (out) */
    size_t		start_t[],		/* define final element (out) */
    size_t		count_t[],	/* all 1 except final element (out) */
    size_t		shape1[NAP_MAX_RANK],	/* shape of main_NAO (with leading 1s) (out) */
    char		**buffer)	/* Malloced by Nap_NetcdfDefineSubscript */
{
    Nap_NAO		*boxed_subscript_NAO;	/* local (boxed) subscript nao */
    Nap_NAO		*cv_nc_NAO;		/* cv from nc file */
    Nap_dataType	dataType;
    Nap_NAO		*el_NAO;		/* element of subscript */
    int			i;
    int			is_contiguous;		/* TRUE if final dim has no gaps */
    int			isRecord;		/* Is dim 0 unlimited? */
    int			j;
    Nap_NAO		*linkNao;		/* used for indirect indexing */
    char		name[NC_MAX_NAME];
    nc_type		number_type;
    int			rank32;
    size_t		shape_t[NAP_MAX_RANK];	/* shape in file */
    size_t		size;			/* sizeof(dataType) */
    int			smax;			/* max. subscript value */
    int			smin;			/* min. subscript value */
    int			status;
    char		*str;
    Nap_NAO		*sub_NAO;		/* subscript */
    Nap_NAO		*tmp_NAO;
    Nap_NAO		*tmp_NAO2;

    assert(subscript_NAO);
    status = Nap_NetcdfVarGetInfo(nap_cd, ncid, varid, &rank32, shape_t, &number_type, &isRecord);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
    if (rank32 > 0) {
	if (subscript_NAO->dataType == NAP_BOXED) {
	    boxed_subscript_NAO = subscript_NAO;
	} else {
	    shape1[0] = 1;
	    boxed_subscript_NAO = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape1);
	    CHECK2(boxed_subscript_NAO, "m4NAME: Error calling Nap_NewNAO");
	    boxed_subscript_NAO->data.Boxed[0] = subscript_NAO->slot;
	    Nap_IncrRefCount(nap_cd, subscript_NAO);
	}
	Nap_IncrRefCount(nap_cd, boxed_subscript_NAO);
	CHECK2(boxed_subscript_NAO->rank <= 1, "m4NAME: Subscript rank > 1");
	CHECK2(boxed_subscript_NAO->nels <= rank32,
		"m4NAME: # elements in subscript > nc rank");
	for (i = 0; i < rank32; i++) {
	    shape1[i] = 1;
	}
	for (i = main_NAO->rank - 1; i >= 0; i--) {
	    shape1[rank32 - main_NAO->rank + i] = main_NAO->shape[i];
	}
	for (i = 0; i < rank32; i++) {
	    cv_nc_NAO = el_NAO = sub_NAO = tmp_NAO = NULL;
	    count_t[i] = 1;
	    status = Nap_NetcdfGetDim(nap_cd, ncid, varid, i, &cv_nc_NAO, name);
	    CHECK(status == TCL_OK);
	    subscript_ptr[i] = (int *) MALLOC(shape1[i] * sizeof(int));
	    CHECK(subscript_ptr[i]);
	    if (i < boxed_subscript_NAO->nels	 &&  boxed_subscript_NAO->data.Boxed[i]) {
		el_NAO = Nap_GetNaoFromSlot(boxed_subscript_NAO->data.Boxed[i]);
		CHECK2(el_NAO->rank <= 1, "m4NAME: Subscript element rank > 1");
		if (!cv_nc_NAO) {
		    cv_nc_NAO = Nap_NewNAO(nap_cd, NAP_I32, 1, shape_t+i);
		    CHECK2(cv_nc_NAO, "m4NAME: Error calling Nap_NewNAO");
		    for (j = 0; j < shape_t[i]; j++) {
			cv_nc_NAO->data.I32[j] = j;
		    }
		}
		linkNao = Nap_GetNaoFromSlot(el_NAO->linkSlot);
		if (linkNao) {
		    if (cv_nc_NAO) {
			CHECK2(linkNao->rank == 0, "m4NAME: Subscript link-nao has rank > 0");
			CHECK2(linkNao->dataType == NAP_I8,
				"m4NAME: Subscript link-nao has data-type other than I8");
			CHECK2(linkNao->data.I8[0] == 2,
				"m4NAME: Subscript link-nao has value other than 2");
			++cv_nc_NAO->count;
			++el_NAO->count;
			str = Nap_Closest(nap_cd, cv_nc_NAO->id, el_NAO->id);
			CHECK2(str, "m4NAME: Error in @@ operation");
			--cv_nc_NAO->count;
			--el_NAO->count;
			tmp_NAO = Nap_GetNumericNaoFromId(nap_cd, str);
			CHECK2(tmp_NAO,
			    "m4NAME: Error calling Nap_GetNumericNaoFromId");
			sub_NAO = Nap_CastNAO(nap_cd, tmp_NAO, NAP_I32);
			CHECK2(sub_NAO, "m4NAME: Error calling Nap_CastNAO");
			if (sub_NAO != tmp_NAO) {
			    Nap_FreeNAO(nap_cd, tmp_NAO);
			    tmp_NAO = NULL;
			}
		    } else {
			sub_NAO = Nap_NewNAO(nap_cd, NAP_I32, 1, shape1+i);
			CHECK2(sub_NAO, "m4NAME: Error calling Nap_NewNAO");
			for (j = 0; j < shape1[i]; j++) {
			    sub_NAO->data.I32[j] = j;
			}
		    }
		} else {
		    sub_NAO = Nap_CastNAO(nap_cd, el_NAO, NAP_I32);
		    CHECK2(sub_NAO, "m4NAME: Error calling Nap_CastNAO");
		}
	    } else {
		sub_NAO = Nap_NewNAO(nap_cd, NAP_I32, 1, shape1+i);
		CHECK2(sub_NAO, "m4NAME: Error calling Nap_NewNAO");
		for (j = 0; j < shape1[i]; j++) {
		    sub_NAO->data.I32[j] = j;
		}
	    }
	    assert(sub_NAO);
	    for (j = 0; j < shape1[i]; j++) {
		if (i == 0  &&  isRecord  &&  sub_NAO->data.I32[j] >= 0) {
		    subscript_ptr[i][j] = sub_NAO->data.I32[j];
		} else {
		    subscript_ptr[i][j] = Nap_mod(sub_NAO->data.I32[j], shape_t[i]);
		}
	    }
	    if (mode == 'r') {
		if (cv_nc_NAO) {
		    ++cv_nc_NAO->count;
		    ++sub_NAO->count;
		    str = Nap_Func(nap_cd, cv_nc_NAO->id , sub_NAO->id);
		    CHECK2(str,
			    "m4NAME: Error defining new coordinate variable");
		    --cv_nc_NAO->count;
		    --sub_NAO->count;
		    tmp_NAO = Nap_GetNumericNaoFromId(nap_cd, str);
		    CHECK2(tmp_NAO,
			    "m4NAME: Error calling Nap_GetNumericNaoFromId");
		    if (tmp_NAO->rank == 0) {
			tmp_NAO2 = tmp_NAO;
			j = shape1[0];
			shape1[0] = 1;
			tmp_NAO = Nap_ReshapeNAO(nap_cd, tmp_NAO2, tmp_NAO2->dataType, 1, shape1);
			CHECK2(tmp_NAO, "m4NAME: Error calling Nap_ReshapeNAO");
			Nap_FreeNAO(nap_cd, tmp_NAO2);
			shape1[0] = j;
		    }
		    tmp_NAO->unit = Nap_StrDup(cv_nc_NAO->unit);
		    status = Nap_AttachCoordVar(nap_cd, main_NAO, tmp_NAO, name, i);
		    CHECK(status == TCL_OK);
		    Nap_FreeNAO(nap_cd, tmp_NAO);
		} else {
		    status = Nap_AttachCoordVar(nap_cd, main_NAO, NULL, name, i);
		    CHECK(status == TCL_OK);
		}
	    }
	    Nap_FreeNAO(nap_cd, cv_nc_NAO);
	    Nap_FreeNAO(nap_cd, el_NAO);
	    if (sub_NAO != el_NAO) {
		Nap_FreeNAO(nap_cd, sub_NAO);
	    }
	}
	i = rank32-1;
	if (subscript_ptr[i]) {
	    smin = smax = subscript_ptr[i][0];
	    for (j = 1; j < shape1[i]; j++) {
		smin = Min(smin, subscript_ptr[i][j]);
		smax = Max(smax, subscript_ptr[i][j]);
	    }
	    start_t[i] = smin;
	    count_t[i] = 1 + smax - smin;
	    is_contiguous = TRUE;
	    for (j = 1; j < shape1[i]; j++) {
		is_contiguous = is_contiguous && subscript_ptr[i][j] == smin+j;
	    }
	    if (is_contiguous) {
		*buffer = NULL;
	    } else {
		if (mode == 'r') {
		    size = Nap_SizeOf(main_NAO->dataType);
		} else {
		    dataType = Nap_Netcdf2NapDataType(number_type);
		    CHECK2(Nap_ValidDataType(dataType), "m4NAME: Illegal datatype");
		    size = Nap_SizeOf(dataType);
		}
		*buffer = (char *) MALLOC(count_t[i] * size);
		CHECK(*buffer);
	    }
	} else {
	    start_t[i] = 0;
	    count_t[i] = shape1[i];
	    *buffer = NULL;
	}
	Nap_DecrRefCount(nap_cd, boxed_subscript_NAO);
    } else {
	*buffer = NULL;
    }
    return TCL_OK;
}

/*
 * Nap_NetcdfPutSubscripting --
 *
 *	Called by Nap_NetcdfPut to do recursive subscripting.
 */

m4begin

m4define(`m4NAME', `Nap_NetcdfPutSubscripting')

#  m4readVar(internal_data_type)
m4define(`m4readVar', `
	case m4DataTypeEnum($1):
	    {
		m4DataTypeName($1) *ptr = (m4DataTypeName($1) *) buffer;
		status = nc_get_vara_`'m4ncName($1)(ncid, varid, start_t, count_t, ptr);
		CHECK2NC(status, "m4NAME: Error calling nc_get_vara_`'m4ncName($1)");
	    }
	    break;')

m4end

static int
Nap_NetcdfPutSubscripting(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,			/* netCDF var ID */
    int			dim_num,		/* current dimension number */
    Nap_NAO		*main_NAO,
    size_t		start_t[],		/* netCDF subscript */
    size_t		count_t[],	     /* netCDF edge (all 1 except final) */
    size_t		shape1[NAP_MAX_RANK],	/* shape of main_NAO (with leading 1s) */
    int			*subscript_ptr[],      /* specified subscript vectors */
    char		**data_ptr,		/* points to next NAO element */
    char		*buffer)		/* For actual write */
{
    size_t		i;
    size_t		j;
    Nap_dataType	dataType;
    nc_type		number_type;
    int			rank32;			/* main_NAO & nc rank */
    size_t              shape_t[NAP_MAX_RANK];  /* shape in file */
    size_t		size;			/* sizeof(dataType) */
    int			status;

    assert(dim_num >= 0);
    status = Nap_NetcdfVarGetInfo(nap_cd, ncid, varid, &rank32, shape_t, &number_type, NULL);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
    assert(rank32 == 0	||  dim_num < rank32);
    dataType = Nap_Netcdf2NapDataType(number_type);
    CHECK2(Nap_ValidDataType(dataType), "m4NAME: Illegal datatype");
    size = Nap_SizeOf(dataType);
    if (rank32 == 0  ||	 dim_num == rank32-1) {
	if (buffer) {
	    switch (dataType) {
		m4ForAllNcDataType(`m4readVar(', `)')
		default:	    /* error */
		    CHECK2(0, "m4NAME: Illegal datatype for netCDF");
	    }
	    for (i = 0; i < shape1[dim_num]; i++) {
		j = size * (subscript_ptr[dim_num][i] - start_t[dim_num]);
		memcpy(buffer+j, *data_ptr, size);
		*data_ptr += size;
	    }
	    status = Nap_NetcdfPutVar(nap_cd, ncid, varid, buffer, start_t, count_t);
	    CHECK(status == TCL_OK);
	} else {
	    status = Nap_NetcdfPutVar(nap_cd, ncid, varid, *data_ptr, start_t, count_t);
	    CHECK(status == TCL_OK);
	    if (rank32 > 0) {
		*data_ptr += count_t[rank32-1] * size;
	    }
	}
    } else {
	assert(count_t[dim_num] == 1);
	assert(subscript_ptr[dim_num]);
	for (i = 0; i < shape1[dim_num]; i++) {
	    start_t[dim_num] = subscript_ptr[dim_num][i];
	    status = Nap_NetcdfPutSubscripting(nap_cd, ncid, varid, dim_num+1,
		    main_NAO, start_t, count_t, shape1, subscript_ptr, data_ptr, buffer);
	    CHECK(status == TCL_OK);
	}
    }
    return TCL_OK;
}

/*
 * Nap_NetcdfPutSubscriptingRagged --
 *
 *	Called by Nap_NetcdfPut to do recursive subscripting.
 */

m4define(`m4NAME', `Nap_NetcdfPutSubscriptingRagged')

static int
Nap_NetcdfPutSubscriptingRagged(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,			/* netCDF var ID */
    int			dim_num,		/* current dimension number */
    Nap_NAO		*main_NAO,		/* pointer to main nao */
    size_t		start_t[],		/* netCDF subscript */
    size_t		count_t[],	     /* netCDF edge (all 1 except final) */
    int			*subscript_ptr[],      /* specified subscript vectors */
    size_t		*row,		/* next row (NULL on 1st call) */
    char		*buffer)		/* For actual write */
{
    size_t		i;
    size_t		local_row = 0;
    nc_type		number_type;
    int			rank32;			/* main_NAO & nc rank */
    Nap_NAO		*scaled_NAO;
    size_t		*shape;			/* shape of main_NAO */
    size_t		shape_t[NAP_MAX_RANK];
    Nap_NAO		*startNao;		/* for ragged matrix */
    int			status;
    Nap_NAO		*tmp_NAO;

    assert(dim_num >= 0);
    if (dim_num == 0) {
	row = &local_row;
    }
    shape = main_NAO->shape;
    status = Nap_NetcdfVarGetInfo(nap_cd, ncid, varid, &rank32, shape_t, &number_type, NULL);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
    assert(rank32 >= 2);
    assert(dim_num < rank32);
    if (dim_num == rank32-1) {
	if (buffer) {
	    assert(0);		/* TO DO */
	} else {
	    startNao = Nap_GetNaoFromSlot(main_NAO->raggedStartSlot);
	    CHECK2(startNao, "m4NAME: Error calling Nap_GetNaoFromSlot");
	    tmp_NAO = Nap_GetNaoFromSlot(main_NAO->data.Ragged[*row]);
	    if (tmp_NAO) {
		count_t[dim_num] = tmp_NAO->nels;
		if (count_t[dim_num] > 0) {
		    assert(tmp_NAO->rank == 1);
		    status = Nap_NetcdfScaleBeforePut(nap_cd, ncid, varid,tmp_NAO,&scaled_NAO);
		    CHECK(status == TCL_OK);
		    start_t[dim_num] += startNao->data.I32[*row];
		    status = Nap_NetcdfPutVar(nap_cd, ncid, varid, scaled_NAO->data.c,
			    start_t, count_t);
		    CHECK(status == TCL_OK);
		    start_t[dim_num] -= startNao->data.I32[*row];
		    if (scaled_NAO != tmp_NAO) {
			Nap_FreeNAO(nap_cd, scaled_NAO);
		    }
		}
	    }
	}
	++*row;
    } else {
	assert(count_t[dim_num] == 1);
	assert(subscript_ptr[dim_num]);
	for (i = 0; i < shape[dim_num]; i++) {
	    start_t[dim_num] = subscript_ptr[dim_num][i];
	    status = Nap_NetcdfPutSubscriptingRagged(nap_cd, ncid, varid, dim_num+1,
		    main_NAO, start_t, count_t, subscript_ptr, row, buffer);
	    CHECK(status == TCL_OK);
	}
    }
    return TCL_OK;
}

/*
 * Nap_NetcdfPut --
 *	Write NAO to whole or part of var in nc file.
 *	Allow chunking by defining coordinate variables larger than current NAO.
 *
 *	If file does not exist then create it.
 *
 *	If var_name contains ':' then treat part after ':' as attribute name.
 *	If var does not exist then create it with dimensions & coordinate
 *	variables defined by cv_nc[0], cv_nc[1], ... cv_nc[rank].
 *	If cv_nc or cv_nc[i] is NULL then use main_NAO->shape[i] &
 *	(if defined) main_NAO->coordVarSlot[i].
 *
 *	If external_dataType is undefined then use type corresponding to that of
 *	main_NAO.
 *
 *	Use main_NAO->coordVarSlot[i] to define start, etc.
 */

m4define(`m4NAME', `Nap_NetcdfPut')

static int
Nap_NetcdfPut(
    NapClientData       *nap_cd,
    int			ncid,			/* File handle */
    char		*var_name,		/* netCDF var (var) name */
    Nap_dataType	externalDataType,	/* netCDF data type for new Var */
    Nap_NAO		*scale_factor_NAO,	/* for new Var */
    Nap_NAO		*add_offset_NAO,	/* for new Var */
    Nap_NAO		*valid_range_NAO,	/* for new Var */
    Nap_NAO		*main_NAO,		/* pointer to main nao */
    Nap_NAO		*boxed_cv_nc,		/* pointers to CV NAOs */
    Nap_NAO		*subscript_NAO,		/* pointer to subscript nao */
    int			isRecord)               /* Want unlimited dim in new var? */
{
    Nap_NAO		*add_offset_NAO2;	/* type = internalDataType */
    size_t		altShape[] = {1};	/* in case scalar */
    char		*buffer;		/* For actual write */
    Nap_NAO		*cv_nc_local[NAP_MAX_RANK];	/* local cv_nc */
    char		*data_ptr;		/* points to next NAO element */
    int			exists;			/* Var exists? */
    size_t		count_t[NAP_MAX_RANK];
    char		*dimName[NAP_MAX_RANK];	/* external dimension names */
    int			i;
    int			id;
    Nap_dataType	internalDataType;
    nc_type		number_type;
    Nap_NAO		*missingValue_NAO;	/* for fill value */
    int			rank;			/* external rank */
    int			rank32;			/* external rank */
    Nap_NAO		*scale_factor_NAO2;	/* type = internalDataType */
    Nap_NAO		*scaled_NAO;
    size_t		shape[NAP_MAX_RANK];	/* shape of subscript_NAO */
    size_t		shape_t[NAP_MAX_RANK];	/* shape of Var */
    size_t		shape1[NAP_MAX_RANK];	/* shape of main_NAO (with leading 1s) */
    int			slot;
    int			status;
    size_t		start_t[NAP_MAX_RANK];
    char		*str;
    int			*subscript_ptr[NAP_MAX_RANK];
    Nap_NAO		*tmp_NAO;
    int			varid;

    CHECK2(var_name, "m4NAME: Pointer to Var name is NULL");
    CHECK2(main_NAO, "m4NAME: Pointer to main NAO is NULL");
    if (strchr(var_name, ':')) {
	status = Nap_NetcdfPutAttribute(nap_cd, ncid, var_name, main_NAO);
	CHECK(status == TCL_OK);
    } else {
	rank = main_NAO->rank;
	status = Nap_NetcdfOpenVar(nap_cd, ncid, var_name, &exists, &varid);
	CHECK(status == TCL_OK);
	if (exists) {
	    boxed_cv_nc = NULL;
	} else {
	    if (boxed_cv_nc) {
		if (boxed_cv_nc->dataType != NAP_BOXED) {
		    tmp_NAO = boxed_cv_nc;
		    boxed_cv_nc = Nap_NewNAO(nap_cd, NAP_BOXED, 1, altShape);
		    CHECK2(boxed_cv_nc, "m4NAME: Error calling Nap_NewNAO");
		    boxed_cv_nc->data.Boxed[0] = tmp_NAO->slot;
		    Nap_IncrRefCount(nap_cd, tmp_NAO);
		}
		assert(boxed_cv_nc->dataType == NAP_BOXED);
		CHECK2(boxed_cv_nc->rank == 1,
			"m4NAME: Illegal Coordinate variable boxed NAO");
		Nap_IncrRefCount(nap_cd, boxed_cv_nc);
		rank = boxed_cv_nc->nels;
	    }
	    for (i = 0; i < rank; i++) {
		if (boxed_cv_nc	 &&  (id = boxed_cv_nc->data.Boxed[i])) {
		    tmp_NAO = Nap_GetNaoFromSlot(id);
		    assert(tmp_NAO);
		    CHECK3(tmp_NAO->rank == 1,
			"m4NAME: Coordinate variable %s has rank other than 1",
			    tmp_NAO->id);
		    shape_t[i] = tmp_NAO->nels;
		    if (tmp_NAO->dimName[0]) {
			dimName[i] = tmp_NAO->dimName[0];
		    } else if (main_NAO->rank == rank) {
			dimName[i] = main_NAO->dimName[i];
		    } else {
			dimName[i] = NULL;
		    }
		} else {
		    shape_t[i] = main_NAO->shape[i];
		    dimName[i] = main_NAO->dimName[i];
		    tmp_NAO = Nap_GetCoordVar(nap_cd, main_NAO, i);
		}
		cv_nc_local[i] = Nap_Promote(nap_cd, tmp_NAO, NAP_I32, 1,altShape);
		Nap_IncrRefCount(nap_cd, cv_nc_local[i]);
	    }
	    tmp_NAO = Nap_UnboxedElement1(nap_cd, main_NAO);
	    if (!tmp_NAO) {
		return TCL_OK;
	    }
	    internalDataType = tmp_NAO->dataType;
	    if (externalDataType == NAP_NULL_TYPE) {
		externalDataType = internalDataType;
	    }
	    if (main_NAO->missingValueSlot > 0) {
		missingValue_NAO = Nap_GetMissingValueNAO(nap_cd, main_NAO);
		if (missingValue_NAO->dataType != externalDataType) {
		    missingValue_NAO = Nap_StandardMissingValueNAO(nap_cd, externalDataType);
		}
		Nap_IncrRefCount(nap_cd, missingValue_NAO);
	    } else {
		missingValue_NAO = NULL;
	    }
	    scale_factor_NAO2 = Nap_CastNAO(nap_cd, scale_factor_NAO, internalDataType);
	    Nap_IncrRefCount(nap_cd, scale_factor_NAO2);
	    add_offset_NAO2   = Nap_CastNAO(nap_cd, add_offset_NAO,   internalDataType);
	    Nap_IncrRefCount(nap_cd, add_offset_NAO2);
	    status = Nap_CreateVar(
		    nap_cd,
		    ncid,
		    var_name,
		    externalDataType,
		    rank,
		    shape_t,
		    cv_nc_local,
		    dimName,
		    scale_factor_NAO2,
		    add_offset_NAO2,
		    valid_range_NAO,
		    missingValue_NAO,
		    main_NAO->format,
		    main_NAO->label,
		    main_NAO->unit,
		    isRecord,
		    &varid);
	    CHECK(status == TCL_OK);
	    Nap_DecrRefCount(nap_cd, scale_factor_NAO2);
	    Nap_DecrRefCount(nap_cd, add_offset_NAO2);
	    Nap_DecrRefCount(nap_cd, missingValue_NAO);
	    for (i = 0; i < rank; i++) {
		Nap_DecrRefCount(nap_cd, cv_nc_local[i]);
	    }
	}
	if (main_NAO->nels > 0) {
	    status = Nap_NetcdfVarGetInfo(nap_cd, ncid, varid, &rank32, shape_t,
		    &number_type, NULL);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
	    if (subscript_NAO) {
		Nap_IncrRefCount(nap_cd, subscript_NAO);
	    } else {
		shape[0] = rank;
		subscript_NAO = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
		CHECK2(subscript_NAO, "m4NAME: Error calling Nap_NewNAO");
		Nap_IncrRefCount(nap_cd, subscript_NAO);
		for (i = 0; i < rank; i++) {
		    tmp_NAO = Nap_GetCoordVar(nap_cd, main_NAO, i);
		    if (tmp_NAO) {
			str = Nap_Indirect(nap_cd, 2, tmp_NAO->id);
			CHECK2(str, "m4NAME: error in '@@' operation");
			tmp_NAO = Nap_GetNaoFromId(nap_cd, str);
			CHECK2(tmp_NAO, "m4NAME: error in '@@' operation");
			Nap_IncrRefCount(nap_cd, tmp_NAO);
			slot = tmp_NAO->slot;
		    } else {
			slot = 0;
		    }
		    subscript_NAO->data.Boxed[i] = slot;
		}
	    }
	    status = Nap_NetcdfDefineSubscript(nap_cd, ncid, varid, main_NAO, 'w',
		    subscript_NAO, subscript_ptr, start_t, count_t, shape1, &buffer);
	    CHECK(status == TCL_OK);
	    if (main_NAO->dataType == NAP_RAGGED) {
		status = Nap_NetcdfPutSubscriptingRagged(nap_cd, ncid, varid, 0,
			main_NAO, start_t, count_t, subscript_ptr, NULL, buffer);
		CHECK(status == TCL_OK);
	    } else {
		status = Nap_NetcdfScaleBeforePut(nap_cd, ncid, varid, main_NAO, &scaled_NAO);
		CHECK(status == TCL_OK);
		Nap_IncrRefCount(nap_cd, scaled_NAO);
		data_ptr = scaled_NAO->data.c;
		status = Nap_NetcdfPutSubscripting(nap_cd, ncid, varid, 0,
			main_NAO, start_t, count_t, shape1, subscript_ptr,
			&data_ptr, buffer);
		FREE(buffer);
		CHECK(status == TCL_OK);
		Nap_DecrRefCount(nap_cd, scaled_NAO);
	    }
	    for (i = 0; i < rank32; i++) {
		FREE(subscript_ptr[i]);
	    }
	    Nap_DecrRefCount(nap_cd, subscript_NAO);
	    Nap_DecrRefCount(nap_cd, boxed_cv_nc);
	}
    }
    return TCL_OK;
}

/*
 * Nap_NetcdfGetSubscripting --
 *
 *	Called by Nap_NetcdfGet to do recursive subscripting.
 */

m4define(`m4NAME', `Nap_NetcdfGetSubscripting')

static int
Nap_NetcdfGetSubscripting(
    NapClientData       *nap_cd,
    int			ncid,			/* file handle */
    int			varid,			/* netCDF var ID */
    int                 raw,            	/* 1 to request raw data */
    Nap_NAO		*main_NAO,		/* pointer to main nao */
    int			dim_num,		/* current dimension number */
    size_t		start_t[],		/* netCDF subscript */
    size_t		count_t[],		/* netCDF edge (all 1 except final) */
    int			*subscript_ptr[],	/* specified subscript vectors */
    char		**data_ptr,		/* points to next NAO element */
    char		*buffer)		/* For actual read */
{
    size_t		i;
    size_t		j;
    nc_type		number_type;
    int			rank32;			/* main_NAO & nc rank */
    size_t		shape_t[NAP_MAX_RANK];
    size_t		size = Nap_SizeOf(main_NAO->dataType);
    int			status;

    assert(dim_num >= 0);
    status = Nap_NetcdfVarGetInfo(nap_cd, ncid, varid, &rank32, shape_t, &number_type, NULL);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
    assert(rank32 == 0	||  dim_num < rank32);
    if (rank32 == 0  ||	 dim_num == rank32-1) {
	if (buffer) {
	    status = Nap_NetcdfGetVar(nap_cd, ncid, varid, raw, buffer, main_NAO->missingValuePtr,
		start_t, count_t);
	    CHECK(status == TCL_OK);
	    for (i = 0; i < main_NAO->shape[dim_num]; i++) {
		j = size * (subscript_ptr[dim_num][i] - start_t[dim_num]);
		memcpy(*data_ptr, buffer+j, size);
		*data_ptr += size;
	    }
	} else {
	    status = Nap_NetcdfGetVar(nap_cd, ncid, varid, raw, *data_ptr,
		    main_NAO->missingValuePtr, start_t, count_t);
	    CHECK(status == TCL_OK);
	    if (rank32 > 0) {
		*data_ptr += count_t[rank32-1] * size;
	    }
	}
    } else {
	for (i = 0; i < main_NAO->shape[dim_num]; i++) {
	    start_t[dim_num] = subscript_ptr[dim_num][i];
	    status = Nap_NetcdfGetSubscripting(nap_cd, ncid, varid, raw, main_NAO, dim_num+1,
		    start_t, count_t, subscript_ptr, data_ptr, buffer);
	    CHECK(status == TCL_OK);
	}
    }
    return TCL_OK;
}

/*
 * Nap_NetcdfGet --
 *
 *	Read data from nc file into existing NAO.
 *	If var_name contains ':' then treat part after ':' as attribute name.
 *	Also any dim. names & coord. vars.
 */

m4begin

#  m4getMV(dataType)  e.g. m4getMV(f32)
m4define(`m4getMV', `
	case m4DataTypeEnum($1):
	    status = nc_get_att_`'m4ncName($1)(ncid, varid, "_FillValue", mv->data.$1);
	    break;')

m4define(`m4NAME', `Nap_NetcdfGet')

m4end

EXTERN int
Nap_NetcdfGet(
    NapClientData       *nap_cd,
    char		*fileName,	/* netCDF file name */
    char		*var_name,	/* netCDF var (var) name */
    Nap_NAO		*subscript_NAO, /* pointer to subscript nao */
    int                 raw,            /* 1 to request raw data */
    Nap_NAO		*main_NAO)	/* pointer to main nao (out) */
{
    char		*buffer;		/* For actual read */
    double		cal;			/* scale factor */
    Nap_NAO		*cv_nc_NAO;		/* cv from nc file */
    char		*data_ptr;		/* points to next NAO element */
    size_t		count_t[NAP_MAX_RANK];
    int			exists;			/* Var exists? */
    Nap_dataType	externalDataType;	/* netcdf type */
    int			i;
    Nap_dataType	internalDataType;	/* NAO type */
    Nap_NAO		*mv;			/* missing value from netcdf file */
    char		name[NC_MAX_NAME];
    nc_type		number_type;
    double		off;			/* offset */
    int			rank32;
    int			ncid;
    int			varid;
    size_t		shape_t[NAP_MAX_RANK];	/* shape of nc var */
    size_t		shape1[NAP_MAX_RANK];	/* shape of main_NAO (with leading 1s) */
    int			status;
    size_t		start_t[NAP_MAX_RANK];
    int			*subscript_ptr[NAP_MAX_RANK];
    double		valid_range[2];		/* min, max */

    CHECK2(fileName, "m4NAME: Pointer to file name is NULL");
    CHECK2(var_name, "m4NAME: Pointer to Var name is NULL");
    CHECK2(main_NAO, "m4NAME: Pointer to main NAO is NULL");
    if (main_NAO->nels == 0) {
	return TCL_OK;
    }
    status = Nap_NetcdfOpenFile(nap_cd, fileName, 'r', &ncid);
    CHECK(status == TCL_OK);
    if (strchr(var_name, ':')) {
	status = Nap_NetcdfGetAttribute(nap_cd, ncid, var_name, main_NAO);
	CHECK(status == TCL_OK);
    } else {
	status = Nap_NetcdfOpenVar(nap_cd, ncid, var_name, &exists, &varid);
	CHECK3(exists, "m4NAME: Var %s not found", var_name);
	status = Nap_NetcdfVarGetInfo(nap_cd, ncid, varid, &rank32, shape_t, &number_type, NULL);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
	CHECK2(rank32 == main_NAO->rank, "m4NAME: netCDF rank != NAO rank");
	externalDataType = Nap_Netcdf2NapDataType(number_type);
	assert(Nap_ValidDataType(externalDataType));
	status = Nap_NetcdfGetScalingInfo(nap_cd, ncid, varid, raw, &number_type, &cal,
		&off, valid_range);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfGetScalingInfo");
	internalDataType = Nap_Netcdf2NapDataType(number_type);
	assert(Nap_ValidDataType(internalDataType));
	CHECK2(internalDataType == main_NAO->dataType, "m4NAME: netCDF dataType != NAO dataType");
	if (internalDataType == externalDataType  &&  cal == 1.0  &&  off == 0.0  &&  !raw) {
	    mv = Nap_NewNAO(nap_cd, internalDataType, 0, main_NAO->shape);
	    CHECK2(mv, "m4NAME: Error calling Nap_NewNAO");
	    switch (internalDataType) {
		m4ForAllNcDataType(`m4getMV(', `)')
		default:	    /* error */
		    CHECK2(0, "m4NAME: Illegal datatype for netCDF");
	    }
	    if (status == TCL_OK) {
		status = Nap_SetMissing(nap_cd, main_NAO, mv->slot);
		CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	    }
	    Nap_FreeNAO(nap_cd, mv);
	}
	status = Nap_NetcdfGetStdAtts(nap_cd, ncid, varid, main_NAO);
	CHECK(status == TCL_OK);
	if (subscript_NAO) {
	    status = Nap_NetcdfDefineSubscript(nap_cd, ncid, varid, main_NAO, 'r',
			subscript_NAO, subscript_ptr, start_t, count_t, shape1, &buffer);
	    CHECK(status == TCL_OK);
	    data_ptr = main_NAO->data.c;
	    status = Nap_NetcdfGetSubscripting(nap_cd, ncid, varid, raw, main_NAO, 0,
		    start_t, count_t, subscript_ptr, &data_ptr, buffer);
	    FREE(buffer);
	    CHECK(status == TCL_OK);
	    for (i = 0; i < rank32; i++) {
		FREE(subscript_ptr[i]);
	    }
	} else {
	    for (i = 0; i < rank32; i++) {
		start_t[i] = 0;
		count_t[i]  = shape_t[i];
	    }
	    status = Nap_NetcdfGetVar(nap_cd, ncid, varid, raw, main_NAO->data.c,
		    main_NAO->missingValuePtr, start_t, count_t);
	    CHECK(status == TCL_OK);
	    for (i = 0; i < rank32; i++) {
		status = Nap_NetcdfGetDim(nap_cd, ncid, varid, i, &cv_nc_NAO, name);
		CHECK(status == TCL_OK);
		status = Nap_AttachCoordVar(nap_cd, main_NAO, cv_nc_NAO, name, i);
		CHECK(status == TCL_OK);
	    }
	}
    }
    status = Nap_NetcdfCloseFile(nap_cd, ncid);
    CHECK(status == TCL_OK);
    return TCL_OK;
}

/*
 * Nap_NetcdfInfo --
 *
 *	Get shape & datatype corresponding to var in nc file.
 *	If data is scaled (i.e. calibrated) then this datatype is that of
 *	uncalibrated (internal) data, not var (external) data.
 *	If var_name contains ':' then treat part after ':' as attribute name.
 */

m4define(`m4NAME', `Nap_NetcdfInfo')

EXTERN int
Nap_NetcdfInfo(
    NapClientData       *nap_cd,
    char		*fileName,		/* netCDF file name */
    char		*var_name,		/* netCDF var (var) name */
    int                 raw,            	/* 1 to request raw data */
    int			*rank,			/* rank of var (out) */
    size_t		shape[NAP_MAX_RANK],	/* shape of var (out) */
    Nap_dataType	*externalDataType,	/* datatype of var (out) */
    Nap_dataType	*internalDataType)	/* datatype of NAO (out) */
{
    double		cal;
    int			exists;			/* Var exists? */
    int			i;
    char		*name_att;		/* name of attribute */
    char		name_var[2*NC_MAX_NAME+2]; /* with space for name_att */
    nc_type		number_type;
    double		off;
    int			rank32;
    int			ncid;
    int			varid;
    size_t		shape_t[NAP_MAX_RANK];
    int			status;
    double		valid_range[2];		/* min, max */

    CHECK2(fileName, "m4NAME: Pointer to file name is NULL");
    CHECK2(var_name, "m4NAME: Pointer to Var name is NULL");
    CHECK2(strlen(var_name) <= 2*NC_MAX_NAME+1, "m4NAME: var_name is too long");
    (void) strcpy(name_var, var_name);
    name_att = strchr(name_var, ':');
    if (name_att) {
	*name_att = '\0';
	++name_att;
    } else {
	name_att = "";
    }
    status = Nap_NetcdfOpenFile(nap_cd, fileName, 'r', &ncid);
    CHECK(status == TCL_OK);
    if (strlen(name_var) > 0) {
	status = Nap_NetcdfOpenVar(nap_cd, ncid, name_var, &exists, &varid);
	CHECK3(exists, "m4NAME: Var %s not found", name_var);
    } else {
	varid = NC_GLOBAL;
    }
    if (strlen(name_att) > 0) {
	status = nc_inq_att(ncid, varid, name_att, &number_type, shape_t);
	CHECK2NC(status, "m4NAME: Error calling nc_inq_att");
	*internalDataType = *externalDataType = Nap_Netcdf2NapDataType(number_type);
	rank32 = 1;
    } else {
	status = Nap_NetcdfVarGetInfo(nap_cd, ncid, varid, &rank32, shape_t, &number_type, NULL);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
	*externalDataType = Nap_Netcdf2NapDataType(number_type);
	status = Nap_NetcdfGetScalingInfo(nap_cd, ncid, varid, raw, &number_type, &cal,
		&off, valid_range);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfGetScalingInfo");
	*internalDataType = Nap_Netcdf2NapDataType(number_type);
    }
    CHECK2(Nap_ValidDataType(*externalDataType), "m4NAME: Illegal datatype");
    CHECK2(Nap_ValidDataType(*internalDataType), "m4NAME: Illegal datatype");
    assert(rank32 <= NAP_MAX_RANK);
    *rank = rank32;
    for (i = 0; i < rank32; i++) {
	shape[i] = shape_t[i];
    }
    status = Nap_NetcdfCloseFile(nap_cd, ncid);
    CHECK(status == TCL_OK);
    return TCL_OK;
}


/*
 * Nap_NetcdfList --
 *
 *	Define tcl result as list of names of Vars & attributes in nc file.
 *	Use regular expression to filter these.
 */

m4define(`m4NAME', `Nap_NetcdfList')

EXTERN int
Nap_NetcdfList(
    NapClientData       *nap_cd,
    char		*fileName,		/* netCDF file name */
    char		*reg_exp)		/* regular expression */
{
    Tcl_RegExp		cre;		/* compiled regular expression */
    int			i_att;			/* index of attribute */
    size_t		len;
    int			n_var;			/* number Vars in file */
    char		name[2*NC_MAX_NAME];	/* Var:ATT */
    Tcl_Obj		*nameObj;		/* name as tcl object */
    int			natts;			/* number attributes */
    Tcl_Obj		*reObj;			/* regular expression object */
    int			ncid;
    int			status;
    int			varid;

    CHECK2(fileName, "m4NAME: Pointer to file name is NULL");
    CHECK2(reg_exp, "m4NAME: Pointer to regular expression is NULL");
    status = Nap_NetcdfOpenFile(nap_cd, fileName, 'r', &ncid);
    CHECK(status == TCL_OK);
    status = nc_inq_nvars(ncid, &n_var);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_nvars");
    status = nc_inq_natts(ncid, &natts);
    CHECK2NC(status, "m4NAME: Error calling nc_inq_natts");
    reObj = Tcl_NewStringObj(reg_exp, -1);
    CHECK(reObj);
    Tcl_IncrRefCount(reObj);
    cre = Tcl_GetRegExpFromObj(nap_cd->interp, reObj, TCL_REG_ADVANCED | TCL_REG_NOSUB);
    CHECK(cre);
    name[0] = ':';
    for (i_att = 0; i_att < natts; i_att++) {
	status = nc_inq_attname(ncid, NC_GLOBAL, i_att, name+1);
	CHECK2NC(status, "m4NAME: Error calling nc_inq_attname");
	nameObj = Tcl_NewStringObj(name, -1);
	CHECK(nameObj);
	Tcl_IncrRefCount(nameObj);
	status = Tcl_RegExpExecObj(nap_cd->interp, cre, nameObj, 0, 0, 0);
	Tcl_DecrRefCount(nameObj);
	CHECK2(status == 0  ||	status == 1, "m4NAME: Error calling Tcl_RegExpExecObj");
	if (status == 1) {
	    status = Nap_AppendLines(nap_cd, name);
	    CHECK(status == TCL_OK);
	}
    }
    for (varid = 0; varid < n_var; varid++) {
	status = nc_inq_varname(ncid, varid, name);
	CHECK2NC(status, "m4NAME: Error calling nc_inq_varname");
	status = nc_inq_varnatts(ncid, varid, &natts);
	CHECK2NC(status, "m4NAME: Error calling nc_inq_varnatts");
	nameObj = Tcl_NewStringObj(name, -1);
	CHECK(nameObj);
	Tcl_IncrRefCount(nameObj);
	status = Tcl_RegExpExecObj(nap_cd->interp, cre, nameObj, 0, 0, 0);
	Tcl_DecrRefCount(nameObj);
	CHECK2(status == 0  ||	status == 1, "m4NAME: Error calling Tcl_RegExpExecObj");
	if (status == 1) {
	    status = Nap_AppendLines(nap_cd, name);
	    CHECK(status == TCL_OK);
	}
	len = strlen(name);
	name[len] = ':';
	for (i_att = 0; i_att < natts; i_att++) {
	    status = nc_inq_attname(ncid, varid, i_att, name+len+1);
	    CHECK2NC(status, "m4NAME: Error calling nc_inq_attname");
	    nameObj = Tcl_NewStringObj(name, -1);
	    CHECK(nameObj);
	    Tcl_IncrRefCount(nameObj);
	    status = Tcl_RegExpExecObj(nap_cd->interp, cre, nameObj, 0, 0, 0);
	    Tcl_DecrRefCount(nameObj);
	    CHECK2(status == 0	||  status == 1, "m4NAME: Error calling Tcl_RegExpExecObj");
	    if (status == 1) {
		status = Nap_AppendLines(nap_cd, name);
		CHECK(status == TCL_OK);
	    }
	}
    }
    status = Nap_NetcdfCloseFile(nap_cd, ncid);
    CHECK(status == TCL_OK);
    Tcl_DecrRefCount(reObj);
    return TCL_OK;
}


/*
 * Nap_NetcdfDimNames --
 *
 *	Define tcl result as list of dimension names of specified variable in specified file.
 */

m4define(`m4NAME', `Nap_NetcdfDimNames')

EXTERN int
Nap_NetcdfDimNames(
    NapClientData       *nap_cd,
    char		*fileName,		/* netCDF file name */
    char		*name_var)		/* netCDF variable name */
{
    int			dim_index;
    char		dim_name[NC_MAX_NAME];
    int			exists;			/* var exists? */
    int			rank;
    int			nc_id;			/* file handle */
    int			var_id;
    size_t		shape[NAP_MAX_RANK];
    int			status;
    nc_type		xtype;

    assert(fileName);
    assert(name_var);
    assert(dim_name);
    status = Nap_NetcdfOpenFile(nap_cd, fileName, 'r', &nc_id);
    CHECK(status == TCL_OK);
    status = Nap_NetcdfOpenVar(nap_cd, nc_id, name_var, &exists, &var_id);
    CHECK(status == TCL_OK);
    CHECK2(exists, "m4NAME: variable does not exist");
    status = Nap_NetcdfVarGetInfo(nap_cd, nc_id, var_id, &rank, shape, &xtype, NULL);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
    for (dim_index = 0; dim_index < rank; dim_index++) {
	status = Nap_NetcdfGetDim(nap_cd, nc_id, var_id, dim_index, NULL, dim_name);
	CHECK(status == TCL_OK);
	status = Nap_AppendWords(nap_cd, dim_name);
	CHECK(status == 0);
    }
    status = Nap_NetcdfCloseFile(nap_cd, nc_id);
    CHECK(status == TCL_OK);
    return TCL_OK;
}


/*
 * Nap_NetcdfCoordVar --
 *
 *	Define tcl result as ID of new NAO containing coordinate-variable of specified dimension
 *	of specified varible in specified file.  Dimension is specified by string which can contain
 *	either dimension-name or dimension-number (0 ... (rank-1)).  If dimension has no
 *	coordinate-variable, then the result is blank.
 */

m4define(`m4NAME', `Nap_NetcdfCoordVar')

EXTERN int
Nap_NetcdfCoordVar(
    NapClientData       *nap_cd,
    char		*fileName,		/* netCDF file name */
    char		*name_var,		/* netCDF variable name */
    char		*dim_str)		/* dimension name or number */
{
    Nap_NAO		*cv_nao;		/* cv from hdf file */
    int			dim_index;
    char		dim_name[NC_MAX_NAME];
    int			exists;			/* var exists? */
    int			rank;
    int			nc_id;			/* file handle */
    int			var_id;
    size_t		shape[NAP_MAX_RANK];
    int			status;
    nc_type		xtype;

    assert(fileName);
    assert(name_var);
    assert(dim_str);
    assert(dim_name);
    status = Nap_NetcdfOpenFile(nap_cd, fileName, 'r', &nc_id);
    CHECK(status == TCL_OK);
    status = Nap_NetcdfOpenVar(nap_cd, nc_id, name_var, &exists, &var_id);
    CHECK(status == TCL_OK);
    CHECK2(exists, "m4NAME: variable does not exist");
    status = Nap_NetcdfVarGetInfo(nap_cd, nc_id, var_id, &rank, shape, &xtype, NULL);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_NetcdfVarGetInfo");
    CHECK2(rank > 0, "m4NAME: variable is scalar");
    status = Tcl_GetInt(nap_cd->interp, dim_str, &dim_index);
    if (status == TCL_OK) {
	dim_index = Nap_mod(dim_index, rank);
    } else {
	status = 1;
	for (dim_index = 0; dim_index < rank  &&  status != 0; dim_index++) {
	    status = Nap_NetcdfGetDim(nap_cd, nc_id, var_id, dim_index, NULL, dim_name);
	    CHECK(status == TCL_OK);
	    status = strcmp(dim_str, dim_name);
	}
	--dim_index;
	CHECK3(dim_index < rank, "m4NAME: Unable to find dimension named '%s'", dim_str);
    }
    status = Nap_NetcdfGetDim(nap_cd, nc_id, var_id, dim_index, &cv_nao, NULL);
    CHECK(status == TCL_OK);
    status = Nap_NetcdfCloseFile(nap_cd, nc_id);
    CHECK(status == TCL_OK);
    Tcl_ResetResult(nap_cd->interp);
    if (cv_nao) {
	status = Nap_AppendLines(nap_cd, cv_nao->id);
    } else {
	status = Nap_AppendLines(nap_cd, "");
    }
    CHECK(status == 0);
    return TCL_OK;
}


/*
 * Nap_OOC_netcdf --
 *
 * Object-oriented sub-command 'netcdf'.
 *
 *	<ID> netcdf ?<SWITCHES>? <FILE> <VAR>
 *	    Write to netCDF variable named <VAR> within netCDF file named <FILE>.
 *	    <SWITCHES> can be:
 *		-coordinateVariable <EXPR>: boxed NAO which specifies coordinate
 *			variables. (Default: coordinate variables of main NAO)
 *		-datatype <TYPE>: netCDF datatype: character, i16, i32, u8, f32 or f64.
 *		-range <FLOAT>: netCDF valid_range
 *		-scale <FLOAT>: netCDF scale_factor
 *		-offset <FLOAT>: netCDF add_offset
 *		-index <EXPR>: position in netCDF variable. (Default: Use CVs of main
 *			NAO if these exist, otherwise start of netCDF variable)
 *
 *	?<SWITCHES>? can be anywhere e.g. following are equivalent:
 *	nao.9-9 netcdf -d i16 a.nc x
 *	nao.9-9 netcdf -d i16 a.nc x
 *	nao.9-9 netcdf a.nc -d i16 x
 */

m4define(`m4NAME', `Nap_OOC_netcdf')

EXTERN int
Nap_OOC_netcdf(
    NapClientData       *nap_cd,
    int			objc,
    Tcl_Obj *CONST	objv[],
    Nap_NAO		*naoPtr)
{
    Nap_NAO		*add_offset_NAO = NULL;		/* For new netcdf var */
    Nap_NAO		*boxed_cv_netcdf = NULL;		/* pointers to CVs */
    Nap_dataType	dataType = NAP_NULL_TYPE;
    char		*file_name = NULL;
    int			i;
    int			index;
    int			isRecord = 0;			/* Want unlimited dim in new var? */
    int			ncid;				/* File handle */
    Nap_NAO		*scale_factor_NAO = NULL;	/* For new netcdf var */
    char		*var_name = NULL;
    int			status;
    int			status_close;			/* Indicates whether file closed OK */
    int			status_open;			/* Indicates whether file opened OK */
    char		*str;
    Nap_NAO		*subscript_NAO = NULL;	/* pointers to subscripts */
    Nap_NAO		*valid_range_NAO = NULL;	/* For new netcdf var */

    CONST char		*switches[] = {
				"-coordinateVariable",
				"-datatype",
				"-index",
				"-offset",
				"-range",
				"-scale",
				"-subscript",
				"-unlimited",
				(char *) NULL};

    CHECK2(objc >= 4  ||  objc <= 6, "m4NAME: wrong # arguments");
    for (i = 2; i < objc; i++) {
	status = Tcl_GetIndexFromObj(nap_cd->interp, objv[i], switches,
				"switch", 0, &index);
	if (status == TCL_OK) {
	    switch (index) {
		case 0:			/* -coordinateVariable */
		    boxed_cv_netcdf = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, boxed_cv_netcdf);
		    break;
		case 1:			/* -datatype */
		    str = Tcl_GetStringFromObj(objv[++i], NULL);
		    dataType = Nap_TextToDataType(str);
		    break;
		case 2:			/* -index */
		    subscript_NAO = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, subscript_NAO);
		    break;
		case 3:			/* -offset */
		    add_offset_NAO = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, add_offset_NAO);
		    break;
		case 4:			/* -range */
		    valid_range_NAO = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, valid_range_NAO);
		    break;
		case 5:			/* -scale */
		    scale_factor_NAO = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, scale_factor_NAO);
		    break;
		case 6:			/* -subscript (old name for -index) */
		    subscript_NAO = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, subscript_NAO);
		    break;
		case 7:                 /* -unlimited */
		    isRecord = 1;
		    break;
		default:
		    assert(FALSE);
	    }
	} else if (!file_name) {
	    file_name = Tcl_GetStringFromObj(objv[i], NULL);
	} else if (!var_name) {
	    var_name  = Tcl_GetStringFromObj(objv[i], NULL);
	} else {
		str = (char *) Tcl_GetStringResult(nap_cd->interp);
		CHECK3(FALSE, "m4NAME: %s", str);
	}
    }
    CHECK2(file_name, "m4NAME: Filename not specified");
    CHECK2(var_name, "m4NAME: var_name not specified");
    Tcl_ResetResult(nap_cd->interp);
    status_open = Nap_NetcdfOpenFile(nap_cd, file_name, 'w', &ncid);
    if (status_open == TCL_OK) {
	status = Nap_NetcdfPut(nap_cd, ncid, var_name, dataType, scale_factor_NAO,
		add_offset_NAO, valid_range_NAO, naoPtr, boxed_cv_netcdf,
		subscript_NAO, isRecord);
	status_close = Nap_NetcdfCloseFile(nap_cd, ncid);
    }
    Nap_DecrRefCount(nap_cd, scale_factor_NAO);
    Nap_DecrRefCount(nap_cd, add_offset_NAO);
    Nap_DecrRefCount(nap_cd, valid_range_NAO);
    Nap_DecrRefCount(nap_cd, boxed_cv_netcdf);
    Nap_DecrRefCount(nap_cd, subscript_NAO);
    CHECK3(status_open  == TCL_OK, "m4NAME: Unable to open file %s", file_name);
    CHECK3(status_close == TCL_OK, "m4NAME: Unable to close file %s", file_name);
    CHECK3(status       == TCL_OK, "m4NAME: Error writing file %s", file_name);
    return TCL_OK;
}
