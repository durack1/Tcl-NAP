m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (nap_ooc.c). It was produced from source file nap_ooc.c,m4 */

/* 
 *	nap_ooc.c,m4 --
 *
 *	Object-oriented commands
 *
 *	Copyright 2001, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Atmospheric Research
 */

#ifndef lint
static char *rcsid="@(#) $Id: nap_ooc.c,m4,v 1.65 2006/11/30 03:09:05 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_hdf.h"
#include "nap_netcdf.h"
#include "napPolygon.h"

/*
 *  Nap_F64ToText --
 *      Define text representing double value.
 *	Allow any of following format characters: "dioxXucfEegG".
 *      If exponent has form 0[0-9][0-9] then remove leading 0.
 */

m4define(`m4NAME', `Nap_F64ToText')

static int
Nap_F64ToText(
    NapClientData       *nap_cd,
    double              value,
    char                *format,
    int			minWidth,
    char                *text)          /* result */
{
    int                 i;
    int                 len;
    int                 nspaces;
    int                 status;
    char		*str;

    if (IsNaN64(value)) {
	str = strcpy(text, "NaN");
	CHECK2(str, "m4NAME: Error calling strcpy");
    } else if (value == napF64Inf) {
	str = strcpy(text, "Inf");
	CHECK2(str, "m4NAME: Error calling strcpy");
    } else if (value == -napF64Inf) {
	str = strcpy(text, "-Inf");
	CHECK2(str, "m4NAME: Error calling strcpy");
    } else {
	if (value == 0.0) {		/* in case -0.0 */
	    value = 0.0;
	}
	assert(format);
	str = strchr(format, '%');
	CHECK2(str, "m4NAME: No '%' in format");
	str = strpbrk(str, "dioxXucfEegG");
	CHECK2(str, "m4NAME: Illegal format");
	switch (tolower(*str)) {
	case 'e':
	case 'f':
	case 'g':
	    status = sprintf(text, format, value);
	    CHECK2(status >= 0, "m4NAME: Error calling sprintf");
	    str = strpbrk(text, "Ee");
	    if (str  &&  (str[1] == '+'  ||  str[1] == '-') &&  str[2] == '0'  &&
		    isdigit(str[3])  &&  isdigit(str[4])  &&  str[5] == '\0') {
		str[2] = str[3];
		str[3] = str[4];
		str[4] = '\0';
	    }
	    break;
	default:
	    status = sprintf(text, format, (int) Nint(value));
	    CHECK2(status >= 0, "m4NAME: Error calling sprintf");
	}
    }
    len = strlen(text);
    nspaces = minWidth - len;
    if (nspaces > 0) {
	text[len+nspaces] = '\0';
	for (i = len-1; i >= 0; i--) {
	    text[i+nspaces] = text[i];
	}
	for (i = 0; i < nspaces; i++) {
	    text[i] = ' ';
	}
    }
    return TCL_OK;
}


/*
 *  Nap_AppendNAOHeader --
 *	Append header info to tcl result.
 */

m4define(`m4NAME', `Nap_AppendNAOHeader')

static int 
Nap_AppendNAOHeader(
    NapClientData       *nap_cd,
    Nap_NAO		*naoPtr,
    char                *s)
{
    char                *cv_id;
    Nap_NAO		*cv_nao;
    char                *dataTypeText;		/* dataType as string */
    char                *dimName;
    int			j;
    char		null_str[20];
    int                 status;			/* # bytes to write from text */
    char		*str;

    dataTypeText = Nap_DataTypeToText(nap_cd, naoPtr->dataType);
    CHECK2(dataTypeText, "m4NAME: error calling Nap_DataTypeToText");
    if (naoPtr->missingValueSlot) {
	status = Nap_F64ToText(nap_cd, Nap_GetF64MissingValue(nap_cd, naoPtr->slot),
		"%0.10g", 0, null_str);
	CHECK(status == TCL_OK);
    } else {
	strcpy(null_str, "(NULL)");
    }
    status = sprintf(s,
	    "%s  %s  MissingValue: %s  References: %d", 
	    naoPtr->id,
	    dataTypeText,
	    null_str,
	    naoPtr->count - 1);
    CHECK2(status > 0, "m4NAME: error calling sprintf");
    NAP_FREE(nap_cd, dataTypeText);
    if (naoPtr->unit) {
	status = sprintf(s + strlen(s), "  Unit: %s", naoPtr->unit);
	CHECK2(status > 0, "m4NAME: error calling sprintf");
    }
    if (naoPtr->format) {
	status = sprintf(s + strlen(s), "  Format: \"%s\"", naoPtr->format);
	CHECK2(status > 0, "m4NAME: error calling sprintf");
    }
    status = Nap_AppendLines(nap_cd, s);
    CHECK(status == 0);
    status = Nap_AppendLines(nap_cd, naoPtr->label);
    CHECK(status == 0);
    if (naoPtr->linkSlot) {
	status = sprintf(s, "Link: %s", Nap_GetNaoFromSlot(naoPtr->linkSlot)->id);
	CHECK2(status > 0, "m4NAME: error calling sprintf");
	status = Nap_AppendLines(nap_cd, s);
	CHECK(status == 0);
    }
    for (j = 0; j < naoPtr->rank; j++) {
	dimName = naoPtr->dimName[j] ? naoPtr->dimName[j] : "(NULL)";
	cv_nao = Nap_GetCoordVar(nap_cd, naoPtr, j);
	cv_id = cv_nao ? cv_nao->id :  "(NULL)";
	status = sprintf(s, "Dimension %-2d  Size: %-5d  Name: %-8s"
		"  Coordinate-variable: %s",
		j, (int) naoPtr->shape[j], dimName, cv_id);
	CHECK2(status > 0, "m4NAME: Error calling sprintf");
	status = Nap_AppendLines(nap_cd, s);
	CHECK(status == 0);
    }
    return TCL_OK;
}

/*
 *  Nap_AppendNAOValue --
 *	Append (text) value of NAO to tcl result.
 */

m4define(`m4NAME', `Nap_AppendNAOValue')

#define WMAX 99					/* Maximum field-width (w) */

static int 
Nap_AppendNAOValue(
    NapClientData       *nap_cd,
    Nap_NAO		*naoPtr,
    int                 objc,
    Tcl_Obj *CONST      objv[],
    long		maxLines,		/* default max. # lines (-1: no limit) */
    long		maxColumns,		/* default max. # columns (-1: no limit) */
    int			*keep)			/* -keep specified? (out) */
{
    int			d;			/* # decimal places */
    Nap_NAO		*dblNao;		/* NAO cast to double */
    Tcl_DString		ds;			/* dynamic string */
    char		fg;			/* format char: 'f' or 'g' */
    char                *format;
    char		format1[16];		/* Use if rank > 1 */
    char                *formatPtr = NULL;	/* format or format1 */
    int			i;			/* Subscript */
    int			isList = 0;		/* 1 for tcl list (braces) */
    int                 index;
    int			j;			/* Subscript */
    int			k;			/* Subscript */
    int			line;			/* Subscript */
    long		nColumns;		/* # columns to use */
    int			nLines;			/* # lines to produce */
    size_t		pprod[NAP_MAX_RANK]; 	/* Partial products of shape */
    size_t		shape_final;		/* final element of shape */
    Nap_NAO		*startNao;		/* ragged start NAO */
    int                 status;			/* # bytes to write from text */
    char		*str;			/* temp. string */
    char		text[WMAX+1];		/* field to print */
    char		textMissing[WMAX+1];	/* field to print if missing */
    char		*missingValueText= "_";	/* print this if missing */
    Nap_NAO		*tmp_NAO;
    int			w = 1;			/* field width */
    double		value;			/* Value to print */

    CONST char         *switches[] = {
			    "-list",
			    "-columns",
			    "-format",
			    "-lines",
			    "-missing",
			    "-keep",
			    (char *) NULL};

    Tcl_DStringInit(&ds);
    if (naoPtr) {
	assert(Nap_IsNAO(nap_cd, naoPtr));
	if (naoPtr->format) {
	    format = naoPtr->format;
	} else if (Nap_TypeIsC8(naoPtr->dataType)) {
	    format = "%c";
	} else if (Nap_TypeIsReal(naoPtr->dataType)) {
	    format = "%g";
	} else {
	    format = "%0.0f";
	}
	for (i = 0; i < objc; ++i) {
	    status = Tcl_GetIndexFromObj(nap_cd->interp, objv[i], switches, "switch", 0,
		    &index);
	    if (status != TCL_OK) {
		CHECK(FALSE);
	    }
	    switch (index) {
		case 0:			/* list */
		    isList = 1;
		    break;
		case 1:			/* columns */
		    ++i;
		    CHECK2(i < objc, "m4NAME: -columns without value");
		    status = Tcl_GetIntFromObj(nap_cd->interp, objv[i], &j);
		    CHECK(status == TCL_OK);
		    maxColumns = j;
		    break;
		case 2:			/* format */
		    ++i;
		    CHECK2(i < objc, "m4NAME: -format without value");
		    formatPtr = Tcl_GetStringFromObj(objv[i], NULL);
		    CHECK2(formatPtr, "m4NAME: Error calling Tcl_GetStringFromObj");
		    if (formatPtr[0]) {
			Tcl_UtfToExternalDString(NULL, formatPtr, -1, &ds);
			format = formatPtr = Tcl_DStringValue(&ds);
		    } else {
			formatPtr = NULL;
		    }
		    break;
		case 3:			/* lines */
		    ++i;
		    CHECK2(i < objc, "m4NAME: -lines without value");
		    status = Tcl_GetIntFromObj(nap_cd->interp, objv[i], &j);
		    CHECK(status == TCL_OK);
		    maxLines = j;
		    break;
		case 4:			/* missing */
		    ++i;
		    CHECK2(i < objc, "m4NAME: -missing without value");
		    missingValueText = Tcl_GetStringFromObj(objv[i], NULL);
		    CHECK2(missingValueText, "m4NAME: Error calling Tcl_GetStringFromObj");
		    break;
		case 5:			/* keep */
		    *keep = 1;
		    break;
		default:
		    assert(FALSE);
	    }
	}
	switch (naoPtr->dataType) {
	case NAP_RAGGED:
	    startNao = Nap_GetNaoFromSlot(naoPtr->raggedStartSlot);
	    CHECK2(startNao, "m4NAME: Error calling Nap_GetNaoFromSlot");
	    CHECK2(startNao->dataType == NAP_I32,
		    "m4NAME: Ragged start NAO has wrong data type");
	    for (j = 0; j < naoPtr->nels; j++) {
		status = sprintf(text, "%d   start-index: %d  ",
			j, startNao->data.I32[j]);
		CHECK2(status >= 0, "m4NAME: Error calling sprintf");
		Nap_AppendLines(nap_cd, text);
		tmp_NAO = Nap_GetNaoFromSlot(naoPtr->data.Boxed[j]);
		if (tmp_NAO) {
		    Nap_AppendWords(nap_cd, tmp_NAO->id);
		}
	    }
	    break;
	default:
	    dblNao = Nap_CastNAO(nap_cd, naoPtr, NAP_F64);
	    CHECK2(dblNao, "m4NAME: Error calling Nap_CastNAO");
	    if (dblNao->rank == 0) {
		nLines = nColumns = shape_final = 1;
	    } else {
		shape_final = Max(1, dblNao->shape[dblNao->rank - 1]);
		nColumns = Min(maxColumns, shape_final);
		nLines = Min(maxLines, dblNao->nels / shape_final);
	    }
	    if (naoPtr->dataType == NAP_C8  ||  dblNao->rank < 2) {
		formatPtr = format;
	    } else {
		formatPtr = formatPtr ? formatPtr : format1;
		fg = 'f';
		for (line = 0; line < nLines  &&  fg == 'f'; line++) {
		    for (j = 0; j < nColumns  &&  fg == 'f'; j++) {
			k = shape_final * line + j;
			if (!IsMissing(naoPtr, k)) {
			    value = dblNao->data.F64[k];
			    status = Nap_F64ToText(nap_cd, value, format, 0, text);
			    CHECK(status == TCL_OK);
			    if (strchr(text, 'e')) {
				fg = 'g';
			    }
			}
		    }
		}
		d = 0;
		for (line = 0; line < nLines; line++) {
		    for (j = 0; j < nColumns; j++) {
			k = shape_final * line + j;
			if (!IsMissing(naoPtr, k)) {
			    value = dblNao->data.F64[k];
			    status = Nap_F64ToText(nap_cd, value, format, 0, text);
			    CHECK(status == TCL_OK);
			    str = strchr(text, '.');
			    if (str) {
				for (i = 0; isdigit(str[i+1]); i++) {
				}
				d = Max(d, i);
			    }
			}
		    }
		}
		d += fg == 'g';
		status = sprintf(format1, "%%0.%d%c", d, fg);
		CHECK2(status >= 0, "m4NAME: Error calling sprintf");
		for (line = 0; line < nLines; line++) {
		    for (j = 0; j < nColumns; j++) {
			k = shape_final * line + j;
			if (!IsMissing(naoPtr, k)) {
			    value = dblNao->data.F64[k];
			    status = Nap_F64ToText(nap_cd, value, format1, 0, text);
			    CHECK(status == TCL_OK);
			    w = Max(w, strlen(text));
			}
		    }
		}
		status = sprintf(format1, "%%%d.%d%c", w, d, fg);
		CHECK2(status >= 0, "m4NAME: Error calling sprintf");
	    }
	    if (dblNao->rank > 0) {
		i = dblNao->rank - 1;
		pprod[i] = dblNao->shape[i];
		while (--i >= 0) {
		    pprod[i] = pprod[i+1] * dblNao->shape[i];
		}
	    }
	    w = Min(w, WMAX);
	    status = sprintf(textMissing, "%*s", w, missingValueText);
	    CHECK2(status >= 0, "m4NAME: Error calling sprintf");
	    if (isList) {
		for (i = 0; i < dblNao->rank; i++) {
		    Nap_AppendLines(nap_cd, "{");
		}
	    }
	    for (line = 0; line < nLines; line++) {
		for (j = 0; j < nColumns; j++) {
		    k = shape_final * line + j;
		    if (IsMissing(naoPtr, k)) {
			Nap_AppendWords(nap_cd, textMissing);
		    } else {
			value = dblNao->data.F64[k];
			status = Nap_F64ToText(nap_cd, value, formatPtr, w, text);
			CHECK(status == TCL_OK);
			if (strcmp(formatPtr, "%c") == 0) {
			    if (value) {
				Nap_AppendStr(nap_cd, text);
			    } else {
				break;	/* Treat NULL character as end of row */
			    }
			} else {
			    Nap_AppendWords(nap_cd, text);
			}
		    }
		}
		if (nColumns < shape_final) {
		    Nap_AppendWords(nap_cd, "..");
		}
		if (isList  &&  dblNao->rank > 0) {
		    Nap_AppendWords(nap_cd, "}");
		}
		if (line < nLines-1) {
		    k = 0;
		    for (i = 1; i < dblNao->rank; i++) {
			k += (shape_final*(line+1)) % pprod[i] == 0;
		    }
		    if (isList) {
			for (i = 1; i < k; i++) {
			    Nap_AppendLines(nap_cd, "}");
			}
			for (i = 0; i < k; i++) {
			    Nap_AppendLines(nap_cd, "{");
			}
		    } else {
			for (i = 0; i < k; i++) {
			    Nap_AppendLines(nap_cd, "");
			}
		    }
		}
	    }
	    if (nLines < dblNao->nels / shape_final) {
		Nap_AppendLines(nap_cd, "..");
	    }
	    if (isList) {
		for (i = 1; i < dblNao->rank; i++) {
		    Nap_AppendLines(nap_cd, "}");
		}
	    }
	    if (dblNao != naoPtr) {
		Nap_FreeNAO(nap_cd, dblNao);
	    }
	}
    } else {
	Nap_AppendWords(nap_cd, "(NULL)");
    }
    Tcl_DStringFree(&ds);
    return TCL_OK;
}


/*
 * Nap_Poly --
 *
 * Draw polyline or fill polygon.
 * This sets relevant part of data to specified value.
 */

m4define(`m4NAME', `Nap_Poly')

static int 
Nap_Poly(
    NapClientData       *nap_cd,
    Nap_NAO		*naoPtr,
    int			objc, 
    Tcl_Obj *CONST      objv[])
{
    Nap_dataType        dataType;
    size_t		i;		/* subscript */
    size_t		n;		/* number of polygon points */
    int 		*px;
    Nap_NAO		*pxNAO = NULL;
    Nap_NAO		*pxyNAO;
    int 		*py;
    size_t		shape[1];
    int                 status;
    char		*str;
    Nap_NAO		*tmpNAO;
    float		value;		/* fill value for polyline/polyfill */
    Nap_NAO		*valueNAO;	/* NAO defining value */

    naoPtr->step = NAP_STEP_UNKNOWN;
    dataType = naoPtr->dataType;
    CHECK2(objc >= 3  &&  objc <= 4, "m4NAME: wrong # arguments");
    CHECK2(naoPtr->rank == 2, "m4NAME: Array has rank other than 2");
    CHECK2(dataType == NAP_F32,
	    "m4NAME: Array has data-type other than float");
    tmpNAO = Nap_GetNaoFromObj(nap_cd, objv[2]);
    CHECK2(tmpNAO, "m4NAME: Error in <XY>");
    CHECK2(tmpNAO->rank <= 2, "m4NAME: <XY> has rank > 2");
    pxyNAO = Nap_CastNAO(nap_cd, tmpNAO, NAP_I32);
    CHECK2(pxyNAO, "m4NAME: error calling Nap_CastNAO");
    if (pxyNAO != tmpNAO) {
	Nap_FreeNAO(nap_cd, tmpNAO);
    }
    if (pxyNAO->rank == 2) {
	CHECK2(pxyNAO->shape[0] == 2, "m4NAME: # rows in <XY> is not 2");
	px = pxyNAO->data.I32;
	n = pxyNAO->shape[1];
	py = pxyNAO->data.I32 + n;
    } else {
	py = pxyNAO->data.I32;
	n = pxyNAO->nels;
	tmpNAO = Nap_GetCoordVar(nap_cd, pxyNAO, 0);
	if (tmpNAO) {
	    pxNAO = Nap_CastNAO(nap_cd, tmpNAO, NAP_I32);
	    CHECK2(pxNAO, "m4NAME: error calling Nap_CastNAO");
	    if (pxNAO != tmpNAO) {
		Nap_FreeNAO(nap_cd, tmpNAO);
	    }
	} else {
	    shape[0] = pxyNAO->nels;
	    pxNAO = Nap_NewNAO(nap_cd, NAP_I32, 1, shape);
	    for (i = 0; i < pxNAO->nels; i++) {
		pxNAO->data.I32[i] = i;
	    }
	}
	px = pxNAO->data.I32;
    }
    if (objc < 4) {
	value = Nap_GetF64MissingValue(nap_cd, naoPtr->slot);
    } else {
	tmpNAO = Nap_GetNaoFromObj(nap_cd, objv[3]);
	CHECK2(tmpNAO, "m4NAME: Error in fill-value argument");
	CHECK2(tmpNAO->nels == 1, "m4NAME: fill-value has nels > 1");
	valueNAO = Nap_CastNAO(nap_cd, tmpNAO, NAP_F32);
	CHECK2(valueNAO, "m4NAME: error calling Nap_CastNAO");
	if (valueNAO != tmpNAO) {
	    Nap_FreeNAO(nap_cd, tmpNAO);
	}
	value = valueNAO->data.F32[0];
	Nap_FreeNAO(nap_cd, valueNAO);
    }
    str = Tcl_GetStringFromObj(objv[1], NULL);
    if (Tcl_StringMatch(str, "f*")) {		/* fill polygon */
	status = Nap_Polyfill(
		nap_cd,
		px,
		py,
		n,
		naoPtr->data.F32,
		value,
		naoPtr->shape[1],
		naoPtr->shape[0]);
	CHECK(status == TCL_OK);
    } else if (Tcl_StringMatch(str, "dr*")) {	/* draw polyline */
	status = Nap_Polyline(
		nap_cd,
		px,
		py,
		n,
		naoPtr->data.F32,
		value,
		naoPtr->shape[1],
		naoPtr->shape[0],
		0);
	CHECK(status == TCL_OK);
    } else {
	CHECK2(FALSE, "m4NAME: method not fill or draw");
    }
    Nap_FreeNAO(nap_cd, pxNAO);
    Nap_FreeNAO(nap_cd, pxyNAO);
    return TCL_OK;
}

/*
 *  Nap_SetValueCopy --
 *	Copy elements defined by cross-product of subscripts.
 *	Called by Nap_SetValue, then recursively by Nap_SetValueCopy.
 *	*m is incremented to point to next undefined element of source.
 *
 *	Based on Nap_SubscriptCopy in napDyadLib.c,m4.
 */

m4define(`m4NAME', `Nap_SetValueCopy')

static int
Nap_SetValueCopy(
    NapClientData       *nap_cd,
    int			n,		/* # remaining dimensions */
    size_t              prodShape[],	/* # bytes in slab at each level */
    int			naoBoxed[],	/* remaining subscripts */
    char                *src,		/* source */
    char                *dst,		/* destination */
    size_t		nels,		/* # elements in src */
    size_t		*m)		/* subscript of src (in/out) */
{
    long		j;		/* scalar value of subscript */
    size_t		k;		/* subscript of high-order subscript */
    size_t		s;		/* prodShape[1] */
    long		shape0;		/* divisor for subscripts */
    int			status;
    Nap_NAO		*subscriptNAO;	/* high-order subscript */
    Nap_NAO		*tmpNAO;

    s = prodShape[n > 0];
    if (prodShape[0] > 0) {
	shape0 = prodShape[0] / s;
	if (n > 0  &&  naoBoxed[0]) {
	    tmpNAO = Nap_GetNaoFromSlot(naoBoxed[0]);
	    Nap_IncrRefCount(nap_cd, tmpNAO);
	    subscriptNAO = Nap_CastNAO(nap_cd, tmpNAO, NAP_I32);
	    CHECK2(subscriptNAO, "m4NAME: error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, subscriptNAO);
	    Nap_DecrRefCount(nap_cd, tmpNAO);
	    if (n == 1) {
		for (k = 0; k < subscriptNAO->nels; k++) {
		    j = Nap_lmod(subscriptNAO->data.I32[k], shape0);
		    memcpy(dst + s * j, src + s * *m, s);
		    *m = Nap_lmod(1 + *m, nels);
		}
	    } else if (n > 1) {
		for (k = 0; k < subscriptNAO->nels; k++) {
		    j = Nap_lmod(subscriptNAO->data.I32[k], shape0);
		    status = Nap_SetValueCopy(nap_cd, n-1, prodShape+1, naoBoxed+1, 
			    src, dst + s * j, nels, m);
		    CHECK2(status == TCL_OK, "m4NAME: Error calling m4NAME");
		}
	    }
	    Nap_DecrRefCount(nap_cd, subscriptNAO);
	} else {
	    if (n <= 1) {
		for (k = 0; k < shape0; k++) {
		    memcpy(dst + s * k, src + s * *m, s);
		    *m = Nap_lmod(1 + *m, nels);
		}
	    } else {
		for (k = 0; k < shape0; k++) {
		    status = Nap_SetValueCopy(nap_cd, n-1, prodShape+1, naoBoxed+1, 
			    src, dst + s * k, nels, m);
		    CHECK2(status == TCL_OK, "m4NAME: Error calling m4NAME");
		}
	    }
	}
    }
    return TCL_OK;
}

/*
 * Nap_SetValue --
 *
 * Set specified part of data to new values.
 *	<ID> set value ?<VALUE>? ?<SUBSCRIPT>?
 */

m4define(`m4NAME', `Nap_SetValue')

static int 
Nap_SetValue(
    NapClientData       *nap_cd,
    Nap_NAO		*naoPtr,
    int			objc, 
    Tcl_Obj *CONST      objv[])
{
    Nap_NAO		*cv;		/* coord. var. */
    Nap_dataType        dataType;
    int                 i;              /* subscript */
    size_t		m;		/* subscript of valueNAO */
    int			n;              /* # elements in subscript */
    Nap_NAO		*newSubscriptNAO = NULL;
    size_t              prodShape[NAP_MAX_RANK+1]; /* # bytes in each slab */
    size_t              shape[1];
    int                 status;
    char		*str;
    Nap_NAO		*subscriptNAO = NULL;
    Nap_NAO		*tmpNAO;
    Nap_NAO		*valueNAO;	/* NAO defining value */

    dataType = naoPtr->dataType;
    CHECK2(objc >= 3  &&  objc <= 5, "m4NAME: wrong # arguments");
    naoPtr->step = NAP_STEP_UNKNOWN;
    if (objc > 4) {
	if (Tcl_GetCharLength(objv[4]) > 0) {
	    str = Nap_expression(nap_cd, objv[4], naoPtr->boxedCV);
	    subscriptNAO = Nap_GetNumericNaoFromId(nap_cd, str);
	    CHECK2(subscriptNAO, "m4NAME: Illegal index");
	    Nap_IncrRefCount(nap_cd, subscriptNAO);
	}
    }
    shape[0] = naoPtr->rank;
    newSubscriptNAO = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
    CHECK2(newSubscriptNAO, "m4NAME: Error calling Nap_NewNAO");
    Nap_IncrRefCount(nap_cd, newSubscriptNAO);
    if (subscriptNAO) {
	if (subscriptNAO->dataType == NAP_BOXED) {
	    CHECK2(subscriptNAO->nels == naoPtr->rank, "m4NAME: nels(index) != rank(array)");
	    for (i = 0; i < subscriptNAO->nels; i++) {
		newSubscriptNAO->data.Boxed[i] = subscriptNAO->data.Boxed[i];
		tmpNAO =  Nap_GetNaoFromSlot(subscriptNAO->data.Boxed[i]);
		if (tmpNAO) {
		    CHECK2(tmpNAO->rank <= 1, "m4NAME: subscript has rank > 1");
		    Nap_IncrRefCount(nap_cd, tmpNAO);
		}
	    }
	} else {
	    CHECK2(naoPtr->rank == 1  &&  subscriptNAO->rank <= 1,
		    "m4NAME: Full subscripts not supported");
	    newSubscriptNAO->data.Boxed[0] = subscriptNAO->slot;
	    Nap_IncrRefCount(nap_cd, subscriptNAO);
	}
    } else {
	for (i = 0; i < newSubscriptNAO->nels; i++) {
	    newSubscriptNAO->data.Boxed[i] = 0;
	}
    }
    if (objc < 4  ||  Nap_GetStringLengthFromObj(objv[3]) == 0) {
	tmpNAO = Nap_GetMissingValueNAO(nap_cd, naoPtr);
	CHECK2(tmpNAO, "m4NAME: error calling Nap_GetMissingValueNAO");
    } else {
	tmpNAO = Nap_GetNaoFromObj(nap_cd, objv[3]);
	CHECK2(tmpNAO, "m4NAME: Error in fill-value argument");
    }
    Nap_IncrRefCount(nap_cd, tmpNAO);
    valueNAO = Nap_CastNAO(nap_cd, tmpNAO, dataType);
    CHECK2(valueNAO, "m4NAME: error calling Nap_CastNAO");
    Nap_IncrRefCount(nap_cd, valueNAO);
    Nap_DecrRefCount(nap_cd, tmpNAO);
    n = i = naoPtr->rank;
    prodShape[i] = Nap_SizeOf(naoPtr->dataType);
    while (--i >= 0) {
	prodShape[i] = naoPtr->shape[i] * prodShape[i+1];
    }
    m = 0;
    status = Nap_SetValueCopy(nap_cd, n, prodShape, newSubscriptNAO->data.Boxed,
	    valueNAO->data.c, naoPtr->data.c,
	    valueNAO->nels, &m);
    CHECK(status == TCL_OK);
    Nap_DecrRefCount(nap_cd, newSubscriptNAO);
    Nap_DecrRefCount(nap_cd, valueNAO);
    Nap_DecrRefCount(nap_cd, subscriptNAO);
    return TCL_OK;
}


/*
 * Nap_OOC_coord --
 *
 * Object-oriented sub-command 'coordinate'.
 */

m4define(`m4NAME', `Nap_OOC_coord')

static int 
Nap_OOC_coord(
    NapClientData       *nap_cd,
    int                 objc,
    Tcl_Obj *CONST      objv[],
    Nap_NAO		*naoPtr)
{
    Nap_NAO		*coordVar;
    int			i;
    int			j;
    int			status;
    char		*str;

    status = Nap_AppendLines(nap_cd, "");
    if (objc > 2) {
	for (i = 2; i < objc; i++) {
	    str = Tcl_GetStringFromObj(objv[i], NULL);
	    assert(str);
	    if (str[0] == '-'  ||  isdigit(str[0])) {
		status = Tcl_GetIntFromObj(nap_cd->interp, objv[i], &j);
		CHECK2(status == TCL_OK, "Illegal integer constant");
		j = Nap_mod(j, naoPtr->rank);
	    } else {
		j = 0;
		while (j < naoPtr->rank 
			&& (naoPtr->dimName[j] == NULL
			|| strcmp(str, naoPtr->dimName[j]) != 0)) {
		    j++;
		}
	    }
	    CHECK2(j >= 0 && j < naoPtr->rank, "Illegal dimension index");
	    coordVar = Nap_GetCoordVar(nap_cd, naoPtr, j);
	    str = coordVar ? coordVar->id : "(NULL)";
	    status = Nap_AppendWords(nap_cd, str);
	    CHECK(status == 0);
	}
    } else {
	for (j = 0; j < naoPtr->rank; j++) {
	    coordVar = Nap_GetCoordVar(nap_cd, naoPtr, j);
	    str = coordVar ? coordVar->id : "(NULL)";
	    status = Nap_AppendWords(nap_cd, str);
	    CHECK(status == 0);
	}
    }
    return TCL_OK;
}


/*
 * Nap_OOC_set --
 *
 * Object-oriented sub-command 'set'.
 */

m4define(`m4NAME', `Nap_OOC_set')

static int 
Nap_OOC_set(
    NapClientData       *nap_cd,
    int                 objc,
    Tcl_Obj *CONST      objv[],
    Nap_NAO		*naoPtr)
{
    Nap_NAO		*coordVar;
    Nap_dataType        dataType;
    char                *dimName;
    int			index;
    int			j;
    Nap_NAO		*mv_NAO;		/* missing value NAO */
    int			n;
    int			nbytes0;		/* original no. data bytes in NAO */
    Tcl_Obj             *objArgs;
    int			rank;			/* new rank */
    size_t              shape[NAP_MAX_RANK];	/* new shape */
    Nap_NAO		*shape_NAO;		/* new shape */
    int			status;
    char		*str;
    Nap_NAO		*tmpNao;

    CONST char		*switches[] = {
				    "coordinate",
				    "count",
				    "datatype",
				    "dimension",
				    "format",
				    "label",
				    "link",
				    "missing",
				    "shape",
				    "unit",
				    "value",
				    (char *) NULL};

    status = Tcl_GetIndexFromObj(nap_cd->interp, objv[2], switches, "option", 0, &index);
    if (status != TCL_OK) {
	CHECK(FALSE);
    }
    switch (index) {
    case 0:		/* coord. vars */
	for (j = 0; j < naoPtr->rank; j++) {
	    str = j+3 < objc ? Tcl_GetStringFromObj(objv[j+3], NULL) : "";
	    if (*str  &&  strcmp(str, "(NULL)") != 0) {
		coordVar = Nap_GetNaoFromId(nap_cd, str);
		CHECK3(coordVar, "m4NAME: Unable to evaluate NAP expression \"%s\"", str);
		dimName = naoPtr->dimName[j] == NULL  &&  Nap_lexSimpleName(str) == strlen(str)
			? str
			: NULL;
		status = Nap_AttachCoordVar(nap_cd, naoPtr, coordVar, dimName, j);
		CHECK(status == TCL_OK);
	    } else {
		status = Nap_AttachCV(nap_cd, naoPtr, NULL, j);
		CHECK(status == TCL_OK);
	    }
	}
	break;
    case 1:	/* ref. count */
	CHECK2(objc <= 5, "m4NAME: Too many arguments");
	if (objc == 3) {
	    ++naoPtr->count;
	} else {
	    status = Tcl_GetIntFromObj(nap_cd->interp, objv[3], &j);
	    CHECK(status == TCL_OK);
	    str = Tcl_GetStringFromObj(objv[3], NULL);
	    if (Tcl_StringMatch(str, "[-+]*")) {
		naoPtr->count += j;
	    } else {
		naoPtr->count = j+1;	/* add 1 to compensate for decrement at end */
	    }
	}
	break;
    case 2:	/* datatype */
	CHECK2(objc <= 4, "m4NAME: Too many arguments");
	if (objc == 3) {
	    dataType = naoPtr->dataType0;
	} else {
	    str = Tcl_GetStringFromObj(objv[3], NULL);
	    dataType = Nap_TextToDataType(str);
	}
	if (Nap_SizeOf(dataType) != Nap_SizeOf(naoPtr->dataType)) {
	    naoPtr->rank = 1;
	    naoPtr->nels = naoPtr->nels0 * Nap_SizeOf(naoPtr->dataType0) / Nap_SizeOf(dataType);
		/* Define new dim. block containing shape & pointers to dim. names */
	    NAP_FREE(nap_cd, naoPtr->shape);
	    naoPtr->shape = (size_t *) NAP_ALLOC(nap_cd, sizeof(size_t) + sizeof(char *));
	    assert(naoPtr->shape);
	    naoPtr->dimName = (char **) (naoPtr->shape + 1);
	    naoPtr->shape[0] = naoPtr->nels;
	    naoPtr->dimName[0] = NULL;
	    Nap_DecrRefCount(nap_cd, naoPtr->boxedCV);
	    naoPtr->boxedCV = NULL;
	}
	naoPtr->dataType = dataType;
	status = Nap_SetMissing(nap_cd, naoPtr, 0);
	CHECK(status == TCL_OK);
	break;
    case 3:	/* dimension names */
	for (j = 0; j < naoPtr->rank; j++) {
	    dimName = j+3 < objc ? Tcl_GetStringFromObj(objv[j+3], NULL) : "";
	    if (*dimName  &&  strcmp(dimName, "(NULL)") != 0) {
		status = Nap_AttachCoordVar(nap_cd, naoPtr, NULL, dimName, j);
		CHECK(status == TCL_OK);
	    } else {
		status = Nap_SetDimName(nap_cd, naoPtr, NULL, j);
		CHECK(status == TCL_OK);
	    }
	}
	break;
    case 4:  		/* format */
	CHECK2(objc >= 3, "m4NAME: wrong # arguments");
	NAP_FREE(nap_cd, naoPtr->format);
	if (objc == 3) {
	    naoPtr->format = NULL;
	} else {
	    str = Tcl_GetStringFromObj(objv[3], NULL);
	    naoPtr->format = Nap_StrDup(nap_cd, str);
	    CHECK2(naoPtr->format, "m4NAME: Error calling Nap_StrDup");
	}
	break;
    case 5:  		/* label */
	CHECK2(objc >= 3, "m4NAME: wrong # arguments");
	NAP_FREE(nap_cd, naoPtr->label);
	if (objc == 3) {
	    naoPtr->label = NULL;
	} else {
	    str = Tcl_GetStringFromObj(objv[3], NULL);
	    naoPtr->label = Nap_StrDup(nap_cd, str);
	    CHECK2(naoPtr->label, "m4NAME: Error calling Nap_StrDup");
	}
	break;
    case 6:  		/* link */
	CHECK2(objc >= 3, "m4NAME: wrong # arguments");
	tmpNao = NULL;
	if (objc > 3) {
	    objArgs = Tcl_ConcatObj(objc-3, objv+3);
	    assert(objArgs);
	    Tcl_IncrRefCount(objArgs);
	    if (Tcl_GetCharLength(objArgs) > 0) {
		tmpNao = Nap_GetNaoFromObj(nap_cd, objArgs);
		CHECK(tmpNao);
	    }
	    Tcl_DecrRefCount(objArgs);
	}
	status = Nap_AttachLink(nap_cd, naoPtr, tmpNao);
	CHECK(status == TCL_OK);
	break;
    case 7:	/* missing value */
	CHECK2(objc >= 3, "m4NAME: wrong # arguments");
	mv_NAO = NULL;
	j = 0;
	if (objc > 3) {
	    dataType = naoPtr->dataType;
	    if (dataType == NAP_RAGGED) {
		tmpNao = Nap_UnboxedElement1(nap_cd, naoPtr);
		dataType = tmpNao ? tmpNao->dataType : NAP_I32;
	    }
	    objArgs = Tcl_ConcatObj(objc-3, objv+3);
	    assert(objArgs);
	    Tcl_IncrRefCount(objArgs);
	    if (Tcl_GetCharLength(objArgs) > 0) {
		tmpNao = Nap_GetNaoFromObj(nap_cd, objArgs);
		CHECK(tmpNao);
		Nap_IncrRefCount(nap_cd, tmpNao);
		mv_NAO = Nap_CastNAO(nap_cd, tmpNao, dataType);
		CHECK2(mv_NAO, "m4NAME: Error calling Nap_CastNAO");
		Nap_IncrRefCount(nap_cd, mv_NAO);
		Nap_DecrRefCount(nap_cd, tmpNao);
		j = mv_NAO->slot;
	    }
	    Tcl_DecrRefCount(objArgs);
	}
	status = Nap_SetMissing(nap_cd, naoPtr, j);
	CHECK(status == TCL_OK);
	Nap_DecrRefCount(nap_cd, mv_NAO);
	break;
    case 8:	/* shape */
	CHECK2(objc >= 3, "m4NAME: wrong # arguments");
	nbytes0 = naoPtr->nels0 * Nap_SizeOf(naoPtr->dataType0);
	if (objc == 3) {
	    rank = 1;
	    shape[0] = nbytes0 / Nap_SizeOf(naoPtr->dataType);
	} else {
	    objArgs = Tcl_ConcatObj(objc-3, objv+3);
	    assert(objArgs);
	    Tcl_IncrRefCount(objArgs);
	    CHECK2(Tcl_GetCharLength(objArgs) > 0, "m4NAME: No specified shape");
	    tmpNao = Nap_GetNaoFromObj(nap_cd, objArgs);
	    CHECK(tmpNao);
	    Nap_IncrRefCount(nap_cd, tmpNao);
	    rank = tmpNao->nels;
	    CHECK2(tmpNao->rank < 2  &&  rank <= NAP_MAX_RANK, "m4NAME: Invalid specified shape");
	    shape_NAO = Nap_CastNAO(nap_cd, tmpNao, NAP_I32);
	    CHECK2(shape_NAO, "m4NAME: Error calling Nap_CastNAO");
	    Nap_IncrRefCount(nap_cd, shape_NAO);
	    Nap_DecrRefCount(nap_cd, tmpNao);
	    Tcl_DecrRefCount(objArgs);
	    for (j = 0; j < rank; j++) {
		shape[j] = shape_NAO->data.I32[j];
	    }
	    Nap_DecrRefCount(nap_cd, shape_NAO);
	}
	for (j = 0; j < naoPtr->rank; j++) {
	    NAP_FREE(nap_cd, naoPtr->dimName[j]);
	}
	Nap_DecrRefCount(nap_cd, naoPtr->boxedCV);
	naoPtr->boxedCV = NULL;
	n = 1;
	for (j = 0; j < rank; j++) {
	    n *= shape[j];
	}
	CHECK2(n  <=  nbytes0 / Nap_SizeOf(naoPtr->dataType), "m4NAME: Invalid specified shape");
	NAP_FREE(nap_cd, naoPtr->shape);
	naoPtr->nels = n;
	    /* Define new dim. block containing shape & pointers to dim. names */
	if (rank > 0) {
	    naoPtr->shape = (size_t *) NAP_ALLOC(nap_cd, rank * (sizeof(size_t) + sizeof(char *)));
	    assert(naoPtr->shape);
	    naoPtr->dimName = (char **) (naoPtr->shape + rank);
	} else {
	    naoPtr->shape = NULL;
	    naoPtr->dimName = NULL;
	}
	naoPtr->rank = rank;
	for (j = 0; j < rank; j++) {
            naoPtr->shape[j] = shape[j];
            naoPtr->dimName[j] = NULL;
	}
	naoPtr->step = NAP_STEP_UNKNOWN;
	break;
    case 9:	/* unit */
	CHECK2(objc >= 3, "m4NAME: wrong # arguments");
	NAP_FREE(nap_cd, naoPtr->unit);
	naoPtr->unit = NULL;
	if (objc > 3) {
	    str = Tcl_GetStringFromObj(objv[3], NULL);
	    CHECK2(str, "m4NAME: Error calling Tcl_GetStringFromObj");
	    if (strcmp(str, "(NULL)") != 0) {
		naoPtr->unit = Nap_StrDup(nap_cd, str);
		CHECK2(naoPtr->unit, "m4NAME: Error calling Nap_StrDup");
	    }
	}
	break;
    case 10:  		/* value */
	status = Nap_SetValue(nap_cd, naoPtr, objc, objv); 
	CHECK(status == TCL_OK);
	break;
    default:
	CHECK2(FALSE, "m4NAME: Illegal set option");
    }
    return TCL_OK;
}

/*
 * Nap_PutRaw --
 *
 * Write raw (binary) data to specified tcl I/O channel.
 */

m4define(`m4NAME', `Nap_PutRaw')

static int 
Nap_PutRaw(
    NapClientData       *nap_cd,
    int			swap_bytes,	/* TRUE to request byte swapping */
    Nap_NAO		*naoPtr,
    char                *channelName)   /* Treat NULL as "stdout" */
{
    char		*buffer;
    Tcl_Channel         channel;        /* tcl I/O channel */
    int                 mode = TCL_WRITABLE;
    int                 nbytes;		/* number of bytes to write */
    int			size;		/* number of bytes per word */
    int                 status;

    assert(naoPtr);
    channelName = channelName ? channelName : "stdout";
    channel = Tcl_GetChannel(nap_cd->interp, channelName, &mode);
    CHECK2(channel, "m4NAME: error calling Tcl_GetChannel");
    status = Tcl_SetChannelOption(nap_cd->interp, channel, "-translation", "binary");
    CHECK(status == TCL_OK);
    size = Nap_SizeOf(naoPtr->dataType);
    nbytes = naoPtr->nels * size;
    if (swap_bytes) {
	buffer = NAP_ALLOC(nap_cd, nbytes);
	(void) memcpy(buffer, naoPtr->data.c, nbytes);
	status = Nap_swap_bytes(nap_cd, buffer, naoPtr->nels, size);
	CHECK2(status == TCL_OK, "m4NAME: error calling Nap_swap_bytes");
	status = Tcl_Write(channel, buffer, nbytes);
	CHECK2(status == nbytes, "m4NAME: error calling Tcl_Write");
	NAP_FREE(nap_cd, buffer);
    } else {
	buffer = naoPtr->data.c;
	status = Tcl_Write(channel, buffer, nbytes);
	CHECK2(status == nbytes, "m4NAME: error calling Tcl_Write");
    }
    return TCL_OK;
}

m4begin
m4define(`m4datatype', `
        case m4DataTypeEnum($1):
            Nap_AppendLines(nap_cd, "m4LowerCase($1)");
            break;')
m4end

/*
 * Nap_ObjectCommand --
 *
 *  Execute NAO as Object-Oriented Command (OOC)
 *
 *  Usage can be any of following
 *	<ID> -format <FORMAT> -columns <INT> -lines <INT> -missing <TEXT> -keep
 *	    Display value of NAO.
 *	    The following switches are allowed:
 *		-format <FORMAT>: C format (default: "" meaning automatic)
 *			e.g. "[nap 15] all -f $%.2f" gives "$15.00"
 *	    	-columns <INT>: maximum # columns i.e. elements in least
 *			significant dimension (default:  6) (-1: no limit)
 *	    	-lines <INT>: maximum # lines (default: 20) (-1: no limit)
 *	    	-list: print in tcl list form (using braces) e.g. "{1 9 2}"
 *	    	-missing <TEXT>: text printed for missing value (default: "_")
 *	    	-keep: Do not delete NAO (with count = 0)
 *	<ID> all -format <FORMAT> -columns <INT> -lines <INT> -missing <TEXT> -keep
 *	    "All" information about NAO.
 *	    The following switches are allowed:
 *		-format <FORMAT>: C format (default: "" meaning automatic)
 *	    	-columns <INT>: maximum # columns (default:  6) (-1: no limit)
 *	    	-lines <INT>:   maximum # lines   (default: 20) (-1: no limit)
 *	    	-list: print in tcl list form (using braces) e.g. "{1 9 2}"
 *	    	-missing <TEXT>: text printed for missing value (default: "_")
 *	    	-keep: Do not delete NAO (with count = 0)
 *	    The "all" sub-command provides same information as two commands:
 *		<ID> header
 *		<ID> value -format <F> -columns <I> -lines <I> -missing <T>
 *	<ID> binary ?<TCL_CHANNEL>?
 *	    Write raw (binary) data (same as 'write').
 *	    <TCL_CHANNEL> defaults to stdout.
 *	<ID> coordinate ?<DIM_NAME>|<DIM_NUMBER>? ?<DIM_NAME>|<DIM_NUMBER>? ...
 *	    Coordinate variable ID
 *	    "<ID> coo" is equivalent to: "<ID> coo 0 1 2 ... rank-1"
 *	<ID> count -keep
 *	    Reference count
 *	<ID> datatype
 *	    Datatype
 *	<ID> dimension ?<DIM_NUMBER>? ?<DIM_NUMBER>? ...
 *	    Dimension names
 *	    "<ID> di" is equivalent to: "<ID> di 0 1 2 ... rank-1"
 *	<ID> draw <XY> ?<VALUE>?
 *	    Draw polyline.
 *	    Set data elements on polyline defined by NAO <XY> to value of
 *	    scalar NAO <VALUE> (default: missing value).
 *	    NAO <XY> can be:
 *		matrix with 2 rows, row 0 is x values, row 1 is y values
 *		vector of y values with coordinate variable (CV) of x values
 *		vector of y values without CV (x defaults to 0 1 2 3 ...)
 *	    Polyline is not closed, so to draw a polygon the 1st point should
 *	    be duplicated at the end.
 *	    Currently <ID> must be float.
 *	<ID> fill <XY> ?<VALUE>?
 *	    Fill polygon.
 *	    Set data elements within polyline defined by NAO <XY> to value of
 *	    scalar NAO <VALUE> (default: missing value).
 *	    NAO <XY> can be:
 *		matrix with 2 rows, row 0 is x values, row 1 is y values
 *		vector of y values with coordinate variable (CV) of x values
 *		vector of y values without CV (x defaults to 0 1 2 3 ...)
 *	    Polygon is closed (unlike draw subcommand).
 *	    Currently <ID> must be float.
 *	<ID> hdf ?<SWITCHES>? <FILE> <SDS>
 *	    HDF: Write to sds named <SDS> within HDF file named <FILE>.
 *	    <SWITCHES> can be:
 *		-unlimited: Create sds with unlimited dimension 0
 *		-coordinateVariable <EXPR>: boxed NAO which specifies coordinate
 *			variables. (Default: coordinate variables of main NAO)
 *		-datatype <TYPE>: HDF datatype: character, i8, i16, i32, u8, u16, u32, f32 or f64.
 *		-range <FLOAT>: HDF valid_range
 *		-scale <FLOAT>: HDF scale_factor
 *		-offset <FLOAT>: HDF add_offset
 *		-index <EXPR>: position in sds. (Default: Use CVs of main
 *			NAO if these exist, otherwise start of sds)
 *	<ID> header -keep
 *	    Similar information to following (but using different format):
 *		<ID> id
 *		<ID> datatype
 *		<ID> missing
 *		<ID> count
 *		<ID> unit
 *		<ID> format
 *		<ID> shape
 *		<ID> dimension
 *		<ID> coordinate
 *	    	-keep: Do not delete NAO (with count = 0)
 *	<ID> id -keep
 *	    ID of NAO  e.g. "nao.42-9"
 *	    	-keep: Do not delete NAO (with count = 0)
 *	<ID> label
 *	    Label of NAO
 *	<ID> link
 *	     ID of link NAO.
 *	<ID> missing
 *	    Missing value of NAO
 *	<ID> netcdf ?<SWITCHES>? <FILE> <VAR>
 *	    Write to netCDF variable named <VAR> within netCDF file named <FILE>.
 *	    <SWITCHES> can be:
 *		-unlimited: Create variable with unlimited dimension 0
 *		-coordinateVariable <EXPR>: boxed NAO which specifies coordinate
 *			variables. (Default: coordinate variables of main NAO)
 *		-datatype <TYPE>: netCDF datatype: character, i16, i32, u8, f32 or f64.
 *		-range <FLOAT>: netCDF valid_range
 *		-scale <FLOAT>: netCDF scale_factor
 *		-offset <FLOAT>: netCDF add_offset
 *		-index <EXPR>: position in netCDF variable. (Default: Use CVs of main
 *			NAO if these exist, otherwise start of netCDF variable)
 *	<ID> ooc -keep
 *	    ID of NAO  e.g. "nao.42-9"
 *	    	-keep: Do not delete NAO (with count = 0)
 *	<ID> rank
 *	    Rank of NAO
 *	<ID> sequence -keep
 *	    Sequence number of NAO.  e.g. 42 for "nao.42-9"
 *	    	-keep: Do not delete NAO (with count = 0)
 *	<ID> set coordinate <COORD_VAR> <COORD_VAR> <COORD_VAR> ...
 *	    Set coordinate variables.
 *	    <COORD_VAR> can be name, NAO_ID or "". If <COORD_VAR> is valid name
 *	    then this is also used as dimension name if this is undefined. If
 *	    <COORD_VAR> is "" then any existing coordinate variable is removed.
 *	    If the number of <COORD_VAR>s < rank then trailing values default
 *	    to "".  Thus command "<ID> se coo" removes all coordinate
 *	    variables.
 *	<ID> set count ?<INT>? ?-keep?
 *	    Set/increment reference count.
 *	    	-keep: Do not delete NAO (with new count = 0)
 *	    If <INT> is signed then add it to reference count.
 *	    If <INT> is unsigned then set reference count to <INT>.
 *	    If <INT> not specified then add 1 to reference count (i.e. treat as "+1")
 *	<ID> set dimension <DIM_NAME> <DIM_NAME> <DIM_NAME> ...
 *	    Set dimension names. If <DIM_NAME> is tcl name pointing to nao then
 *	    this also defines coordinate variable if this is undefined. If
 *	    <DIM_NAME> is "" then any existing dimension name is removed.
 *	    If the number of <DIM_NAME>s < rank then trailing values default
 *	    to "".  Thus command "<ID> se d" removes all dimension names.
 *	<ID> set format ?<STRING>?
 *	    Set format (title) (default: NULL i.e. no format).
 *	<ID> set label ?<STRING>?
 *	    Set label (title) (default: NULL i.e. no label).
 *	<ID> set link ?<NAO>?
 *	    Set link slot number to point to a NAO (default: NULL i.e. no link).
 *	<ID> set missing ?<VALUE>?
 *	    Set missing value (default: NULL i.e. no missing value).
 *	<ID> set unit ?<UNIT>?
 *	    Set unit of measure (default: NULL i.e. no unit).
 *	<ID> set value ?<VALUE>? ?<SUBSCRIPT>?
 *	    Set value.
 *	    Set data elements selected by NAO <SUBSCRIPT> (default: "" i.e.
 *	    whole array) to new values copied from successive elements of NAO
 *	    <VALUE> (default: "" meaning null value)  Elements of <VALUE> are
 *	    recycled if necessary.
 *	<ID> shape
 *	    Shape
 *	<ID> slot -keep
 *	    Slot number of NAO.  e.g. 9 for "nao.42-9"
 *	    	-keep: Do not delete NAO (with count = 0)
 *	<ID> step
 *	    Indicates whether sizes of steps are equal, & if not their sign.
 *	    Thus indicates whether vector is monotonically ascending/descending,
 *	    & if so whether it is arithmetic progression (AP).
 *	    Result is one of following strings:
 *		"+-": at least one positive step & one negative step
 *		">= 0": all steps >= 0
 *		"<= 0": all steps <= 0
 *		"AP": equal steps (except final one which may be shorter)
 *	<ID> swap ?<TCL_CHANNEL>?
 *	    Write raw (binary) data with swapped bytes.
 *	    <TCL_CHANNEL> defaults to stdout.
 *	<ID> unit
 *	    Unit of measure.
 *	<ID> value -format <FORMAT> -columns <INT> -lines <INT> -missing <TEXT> -keep
 *	    The following switches are allowed:
 *		-format <FORMAT>: C format (default: "" meaning automatic)
 *	    	-columns <INT>: maximum # columns (default: -1 i.e. no limit)
 *	    	-lines   <INT>: maximum # lines   (default: -1 i.e. no limit)
 *	    	-list: print in tcl list form (using braces) e.g. "{1 9 2}"
 *	    	-missing <TEXT>: text printed for missing value (default: "_")
 *	    	-keep: Do not delete NAO (with count = 0)
 *	<ID> write ?<TCL_CHANNEL>?
 *	    Write raw (binary) data (same as 'binary').
 *	    <TCL_CHANNEL> defaults to stdout.
 */

m4define(`m4NAME', `Nap_ObjectCommand')

EXTERN int 
Nap_ObjectCommand(
    ClientData		clientData, 
    Tcl_Interp		*interp,
    int                 objc,
    Tcl_Obj *CONST      objv[])
{
    int			i;
    int			index;
    int			j;
    int			keep = 0;		/* -keep specified? */
    long		maxColumns;		/* default max. # columns */
    long		maxLines;		/* default max. # lines */
    Nap_NAO		*naoPtr;
    NapClientData	*nap_cd;
    char                s[999];
    int			status;
    char		*str;
    Nap_NAO		*tmpNao;

    CONST char		*switches[] = {
				"all",
				"binary",
				"blt_vector",
				"coordinate",
				"count",
				"datatype",
				"dimension",
				"draw",
				"fill",
				"format",
				"hdf",
				"header",
				"id",
				"label",
				"link",
				"missing",
				"nels",
				"netcdf",
				"ooc",
				"rank",
				"sequence",
				"set",
				"shape",
				"slot",
				"step",
				"swap",
				"unit",
				"value",
				"write",
				(char *) NULL};

    assert(objc > 0);
    naoPtr = (Nap_NAO *) clientData;
    assert(naoPtr);
    nap_cd = naoPtr->nap_cd;
    assert(Nap_IsNAO(nap_cd, naoPtr));
    Nap_IncrRefCount(nap_cd, naoPtr);
    Nap_InitTclResult(nap_cd);
    maxLines = 20;
    maxColumns = naoPtr->dataType == NAP_C8 ? 80 : 6;
    if (objc > 1) {
	str = Tcl_GetStringFromObj(objv[1], NULL);
    }
    if (objc < 2  ||  str[0] == '-') {
	Nap_AppendLines(nap_cd, "");
	status = Nap_AppendNAOValue(nap_cd, naoPtr, objc-1, objv+1, maxLines, maxColumns,
		&keep);
    } else {
	status = Tcl_GetIndexFromObj(interp, objv[1], switches, "method", 0,
		&index);
	if (status != TCL_OK) {
	    index = -1;
	}
	switch (index) {
	case 0:	/* all info */
	    status = Nap_AppendNAOHeader(nap_cd, naoPtr, s);
	    CHECK(status == TCL_OK);
	    status = Nap_AppendLines(nap_cd, "Value:");
	    CHECK(status == 0);
	    Nap_AppendLines(nap_cd, "");
	    status = Nap_AppendNAOValue(nap_cd, naoPtr, objc-2, objv+2, maxLines, maxColumns,
		    &keep);
	    if (status != TCL_OK) {
		nap_cd->errorCode = 0;
		status = Nap_AppendNAOValue(nap_cd, naoPtr, objc-2, objv+2, maxLines, maxColumns,
			&keep);
		CHECK(FALSE);
	    }
	    break;
	case 1:		/* binary (same as write) */
	    str = Tcl_GetStringFromObj(objv[2], NULL);
	    status = Nap_PutRaw(nap_cd, FALSE, naoPtr, str);
	    break;
	case 2:	/* blt_vector */
	    CHECK2(FALSE, "m4NAME: Method 'blt_vector' is no longer available");
	    break;
	case 3:	/* coord. vars */
	    status = Nap_OOC_coord(nap_cd, objc, objv, naoPtr);
	    break;
	case 4:	/* count */
	    keep = objc > 2;
	    status = sprintf(s, "%d", naoPtr->count - 1);
	    CHECK2(status > 0, "m4NAME: error calling sprintf");
	    status = Nap_AppendLines(nap_cd, s);
	    break;
	case 5:	/* datatype */
	    str = Nap_DataTypeToText(nap_cd, naoPtr->dataType);
	    CHECK2(str, "m4NAME: error calling Nap_DataTypeToText");
	    status = Nap_AppendLines(nap_cd, str);
	    NAP_FREE(nap_cd, str);
	    break;
	case 6:	/* dimension names */
	    status = Nap_AppendLines(nap_cd, "");
	    if (objc > 2) {
		for (i = 2; i < objc; i++) {
		    status = Tcl_GetIntFromObj(nap_cd->interp, objv[i], &j);
		    CHECK(status == TCL_OK);
		    j = Nap_mod(j, naoPtr->rank);
		    if (naoPtr->dimName[j]) {
			status = Nap_AppendListElement(nap_cd, naoPtr->dimName[j]);
		    } else {
			status = Nap_AppendListElement(nap_cd, "(NULL)");
		    }
		    CHECK(status == 0);
		}
	    } else {
		for (j = 0; j < naoPtr->rank; j++) {
		    if (naoPtr->dimName[j]) {
			status = Nap_AppendListElement(nap_cd, naoPtr->dimName[j]);
		    } else {
			status = Nap_AppendListElement(nap_cd, "(NULL)");
		    }
		    CHECK(status == 0);
		}
	    }
	    break;
	case 7:  		/* draw */
	    status = Nap_Poly(nap_cd, naoPtr, objc, objv); 
	    CHECK(status == TCL_OK);
	    break;
	case 8:  		/* fill */
	    status = Nap_Poly(nap_cd, naoPtr, objc, objv); 
	    CHECK(status == TCL_OK);
	    break;
	case 9:			/* format */
	    CHECK2(objc == 2, "m4NAME: wrong # arguments");
	    status = Nap_AppendLines(nap_cd, naoPtr->format);
	    break;
	case 10:		/* hdf */
	    status = Nap_OOC_hdf(nap_cd, objc, objv, naoPtr);
	    break;
	case 11:		/* header */
	    keep = objc > 2;
	    status = Nap_AppendNAOHeader(nap_cd, naoPtr, s);
	    CHECK(status == TCL_OK);
	    break;
	case 12:		/* id */
	    keep = objc > 2;
	    status = Nap_AppendLines(nap_cd, naoPtr->id);
	    break;
	case 13:		/* label */
	    CHECK2(objc == 2, "m4NAME: wrong # arguments");
	    status = Nap_AppendLines(nap_cd, naoPtr->label);
	    break;
	case 14:		/* link */
	    CHECK2(objc == 2, "m4NAME: wrong # arguments");
	    if (naoPtr->linkSlot > 0) {
		tmpNao = Nap_GetNaoFromSlot(naoPtr->linkSlot);
		status = Nap_AppendLines(nap_cd, tmpNao->id);
		Nap_FreeNAO(nap_cd, tmpNao);
	    } else {
		status = Nap_AppendLines(nap_cd, "(NULL)");
	    }
	    break;
	case 15:		/* missing value */
	    if (naoPtr->missingValueSlot) {
		status = Nap_F64ToText(nap_cd, Nap_GetF64MissingValue(nap_cd, naoPtr->slot),
			"%0.10g", 0, s);
		CHECK(status == TCL_OK);
		status = Nap_AppendLines(nap_cd, s);
	    } else {
		status = Nap_AppendLines(nap_cd, "(NULL)");
	    }
	    break;
	case 16:		/* nels */
	    status = sprintf(s, "%d", (int) naoPtr->nels);
	    CHECK2(status > 0, "m4NAME: Error calling sprintf");
	    status = Nap_AppendLines(nap_cd, s);
	    break;
	case 17:		/* netcdf */
	    status = Nap_OOC_netcdf(nap_cd, objc, objv, naoPtr);
	    break;
	case 18:		/* ooc */
	    keep = objc > 2;
	    status = Nap_AppendLines(nap_cd, naoPtr->id);
	    break;
	case 19:		/* rank */
	    status = sprintf(s, "%d", naoPtr->rank);
	    CHECK2(status > 0, "m4NAME: Error calling sprintf");
	    status = Nap_AppendLines(nap_cd, s);
	    break;
	case 20:		/* sequence */
	    keep = objc > 2;
	    status = sprintf(s, "%d", (int) naoPtr->seqNum);
	    CHECK2(status > 0, "m4NAME: Error calling sprintf");
	    status = Nap_AppendLines(nap_cd, s);
	    break;
	case 21:		/* set */
	    keep = objc > 4;
	    CHECK2(objc > 2, "m4NAME: wrong # arguments");
	    status = Nap_OOC_set(nap_cd, objc, objv, naoPtr);
	    break;
	case 22:		/* shape */
	    CHECK2(objc == 2, "m4NAME: wrong # arguments");
	    status = Nap_AppendLines(nap_cd, "");
	    CHECK(status == 0);
	    for (j = 0; j < naoPtr->rank; j++) {
		status = sprintf(s, "%d", (int) naoPtr->shape[j]);
		CHECK2(status > 0, "m4NAME: Error calling sprintf");
		status = Nap_AppendWords(nap_cd, s);
		CHECK(status == 0);
	    }
	    break;
	case 23:		/* slot */
	    keep = objc > 2;
	    status = sprintf(s, "%d", (int) naoPtr->slot);
	    CHECK2(status > 0, "m4NAME: Error calling sprintf");
	    status = Nap_AppendLines(nap_cd, s);
	    break;
	case 24:		/* step */
	    CHECK2(objc == 2, "m4NAME: wrong # arguments");
	    status = Nap_OilNao(naoPtr);
	    CHECK(status == TCL_OK);
	    switch (naoPtr->step) {
	        case NAP_STEP_NULL: 		status = Nap_AppendLines(nap_cd, "NULL"); break;
	        case NAP_STEP_BOTH: 		status = Nap_AppendLines(nap_cd, "+-"); break;
	        case NAP_STEP_NON_NEGATIVE: 	status = Nap_AppendLines(nap_cd, ">= 0"); break;
	        case NAP_STEP_NON_POSITIVE: 	status = Nap_AppendLines(nap_cd, "<= 0"); break;
	        case NAP_STEP_EQUAL: 	status = Nap_AppendLines(nap_cd, "AP"); break;
	        default:		assert(0);
	    }
	    break;
	case 25:		/* swap */
	    str = Tcl_GetStringFromObj(objv[2], NULL);
	    status = Nap_PutRaw(nap_cd, TRUE, naoPtr, str);
	    break;
	case 26:		/* unit */
	    CHECK2(objc == 2, "m4NAME: wrong # arguments");
	    status = Nap_AppendLines(nap_cd, naoPtr->unit ? naoPtr->unit : "(NULL)");
	    break;
	case 27:		/* value */
	    Nap_AppendLines(nap_cd, "");
	    status = Nap_AppendNAOValue(nap_cd, naoPtr, objc-2, objv+2, -1, -1,
		    &keep);
	    CHECK(status == TCL_OK);
	    break;
	case 28:		/* write */
	    str = Tcl_GetStringFromObj(objv[2], NULL);
	    status = Nap_PutRaw(nap_cd, FALSE, naoPtr, str);
	    break;
	}
    }
    if (keep) {
	--naoPtr->count;
    } else {
	Nap_DecrRefCount(nap_cd, naoPtr);
    }
    CHECK(status == 0);
    Nap_SetTclResult(nap_cd);
    return TCL_OK;
}
