m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (napChoice.c) */
/* It was produced from source file napChoice.c,m4 */

/* 
 *	numeric array processor (nap)
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: napChoice.c,m4,v 1.37 2005/06/23 08:24:52 dav480 Exp $";
#endif /* not lint */

#include "nap.h"
#include "nap_check.h"

m4begin

M4Choice2(main_type, cond_type)  e.g. M4Choice2(F32, I16)
m4define(`M4Choice2', `
	    case m4DataTypeEnum($2):
		if (test) {
		    for (i = 0; i < nels; i++) {
			if (IsMissing(naoPtr1, i)) {
			    new->data.$1[i] = m4MissingValue($1);
			} else {
			    new->data.$1[i] = naoPtr1->data.$2[i % naoPtr1->nels] ?
				    nao2->data.$1[i % naoPtr2->nels] :
				    nao3->data.$1[i % naoPtr3->nels];
			}
		    }
		} else {
		    for (i = 0; i < nels; i++) {
			if (IsMissing(naoPtr1, i)) {
			    new->data.$1[i] = m4MissingValue($1);
			} else if (naoPtr1->data.$2[i % naoPtr1->nels]) {
			    new->data.$1[i] = IsMissing(nao2, i % naoPtr2->nels) ?
				    m4MissingValue($1) : nao2->data.$1[i % naoPtr2->nels];
			} else {
			    new->data.$1[i] = IsMissing(nao3, i % naoPtr3->nels) ?
				    m4MissingValue($1) : nao3->data.$1[i % naoPtr3->nels];
			}
		    }
		}
		break;')

M4Choice1(main_type)  e.g. M4Choice1(F32)
m4define(`M4Choice1', `
	case m4DataTypeEnum($1):
	    switch (naoPtr1->dataType) {
	    m4ForAllNumericDataType(`M4Choice2(`$1', ', `)')
	    default:                /* error */
		return NULL;
	    }
	    break;')

M4Choice0(main_type)  e.g. M4Choice0(F32)
m4define(`M4Choice0', `
	case m4DataTypeEnum($1):
	    test = naoPtr1->data.$1[0];
	    break;')

m4end

m4define(`m4NAME', `Nap_Choice')

EXTERN char *
Nap_Choice(
    NapClientData	*nap_cd,
    char		*str1,			/* id of test nao */
    char		*str2)			/* id of boxed nao */
{
    Nap_NAO             *coordNaoPtr;           /* coordinate variable */
    Nap_dataType        dataType;
    char                *dimName;               /* dimension name */
    int			i;
    int			j;
    int			k;
    int			nels;
    Nap_NAO		*new;			/* result */
    int                 rank;
    size_t              *shape;
    int                 status;
    Nap_NAO		*nao2;			/* promoted "if true" nao arg */
    Nap_NAO		*nao3;			/* promoted "if false" nao arg */
    Nap_NAO		*naoPtr1;		/* test nao arg */
    Nap_NAO		*naoPtr2;		/* "if true" nao arg */
    Nap_NAO		*naoPtr3;		/* "if false" nao arg */
    Nap_NAO		*naoPtrBoxed;		/* boxed nao arg */
    int                 test;			/* temp. boolean */

    naoPtr1 = Nap_GetNumericNaoFromId(nap_cd, str1);
    CHECK2NULL(naoPtr1, "m4NAME: Undefined left-hand operand of '?'");
    naoPtrBoxed = Nap_GetNaoFromId(nap_cd, str2);
    CHECK2NULL(naoPtrBoxed, "m4NAME: Undefined right-hand operand of '?'");
    CHECK2NULL(naoPtrBoxed->dataType == NAP_BOXED,
	    "m4NAME: Right-hand operand of '?' is not boxed");
    Nap_IncrRefCount(nap_cd, naoPtrBoxed);
    naoPtr2 = Nap_GetNaoFromSlot(naoPtrBoxed->data.Boxed[0]);
    naoPtr3 = Nap_GetNaoFromSlot(naoPtrBoxed->data.Boxed[1]);
    CHECK2NULL(naoPtr2, "m4NAME: Undefined middle operand. x?NULL:z");
    CHECK2NULL(naoPtr3, "m4NAME: Undefined right-hand operand. x?y:NULL");
    Nap_IncrRefCount(nap_cd, naoPtr1);
    Nap_IncrRefCount(nap_cd, naoPtr2);
    Nap_IncrRefCount(nap_cd, naoPtr3);
    Nap_DecrRefCount(nap_cd, naoPtrBoxed);
    if (naoPtr1->rank == 0) {
	if (IsMissing(naoPtr1, 0)) {
	    new = Nap_NewNAO(nap_cd, NAP_I8, 0, NULL);
	    new->data.I8[0] = m4MissingValue(I8);
	} else {
	    switch (naoPtr1->dataType) {
		m4ForAllNumericDataType(`M4Choice0(', `)')
		default:            /* error */
		    return NULL;
	    }
	    new = test ? naoPtr2 : naoPtr3;
	}
    } else {
	rank = Max(naoPtr1->rank, Max(naoPtr2->rank, naoPtr3->rank));
	if (rank == naoPtr1->rank) {
	    shape = naoPtr1->shape;
	} else if (rank == naoPtr2->rank) {
	    shape = naoPtr2->shape;
	} else {
	    shape = naoPtr3->shape;
	}
	dataType = Nap_DataType2(naoPtr2->dataType, naoPtr3->dataType);
	new = Nap_NewNAO(nap_cd, dataType, rank, shape);
	CHECK2NULL(new, "m4NAME: Error calling Nap_NewNAO");
	nao2 = Nap_CastNAO(nap_cd, naoPtr2, dataType);
	nao3 = Nap_CastNAO(nap_cd, naoPtr3, dataType);
	Nap_IncrRefCount(nap_cd, nao2);
	Nap_IncrRefCount(nap_cd, nao3);
        for (i = 0; i < rank; i++) {
	    j = naoPtr1->rank - i - 1;
	    k = new->rank - i - 1;
	    CHECK3NULL(j < 0  ||  naoPtr1->shape[j] == new->shape[k], "m4NAME: "
		    "Left operand has different sized dimension %d from that of other operands",
		    j);
	    j = naoPtr2->rank - i - 1;
	    CHECK3NULL(j < 0  ||  naoPtr2->shape[j] == new->shape[k], "m4NAME: "
		    "Middle operand has different sized dimension %d from that of other operands",
		    j);
	    j = naoPtr3->rank - i - 1;
	    CHECK3NULL(j < 0  ||  naoPtr3->shape[j] == new->shape[k], "m4NAME: "
		    "Right operand has different sized dimension %d from that of other operands",
		    j);
	    coordNaoPtr = Nap_GetCoordVar(nap_cd, naoPtr1, i);
	    if (!coordNaoPtr) {
		coordNaoPtr = Nap_GetCoordVar(nap_cd, naoPtr2, i);
	    }
	    if (!coordNaoPtr) {
		coordNaoPtr = Nap_GetCoordVar(nap_cd, naoPtr3, i);
	    }
	    dimName = NULL;
	    if (i < naoPtr1->rank) {
		dimName = naoPtr1->dimName[i];
	    }
	    if (!dimName  &&  i < naoPtr2->rank) {
		dimName = naoPtr2->dimName[i];
	    }
	    if (!dimName  &&  i < naoPtr3->rank) {
		dimName = naoPtr3->dimName[i];
	    }
	    status = Nap_AttachCoordVar(nap_cd, new, coordNaoPtr, dimName, i);
	    CHECK1NULL(status == TCL_OK);
	}
	nels = new->nels;
	test =  nao2->isMissing == new->isMissing  &&
		nao3->isMissing == new->isMissing  &&
		nao2->missingValueSlot == new->missingValueSlot  &&
		nao3->missingValueSlot == new->missingValueSlot;
	switch (dataType) {
	    m4ForAllNumericDataType(`M4Choice1(', `)')
	    default:            /* error */
		return NULL;
	}
	Nap_DecrRefCount(nap_cd, nao2);
	Nap_DecrRefCount(nap_cd, nao3);
    }
    Nap_IncrRefCount(nap_cd, new);		/* In case new == naoPtr2 or naoPtr3 */
    Nap_DecrRefCount(nap_cd, naoPtr1);
    Nap_DecrRefCount(nap_cd, naoPtr2);
    Nap_DecrRefCount(nap_cd, naoPtr3);
    -- new->count;
    return new->id;
}
