m4dnl	This is m4 source.
m4dnl	Process using m4 to produce 'C' language file.
m4dnl
m4dnl	If you see this line, you can ignore the next one.
/* Do not edit this file (nap_hdf.c). */
/* It was produced from source file nap_hdf.c,m4 */

/*
 *	nap_hdf.c,m4 --
 *
 *	HDF I/O
 *
 *	Copyright 1997, CSIRO Australia
 *	Author: Harvey Davies, CSIRO Mathematical and Information Sciences
 */

#ifndef lint
static char *rcsid="@(#) $Id: nap_hdf.c,m4,v 1.157 2006/10/12 05:33:47 dav480 Exp $";
#endif /* not lint */

#define CHECK_PRE Nap_HdfCheck(nap_cd);   /* CHECK_PRE is macro used in nap_check.h */

#include "nap_hdf.h"

#undef DEBUG	/* So D(printf("stuff");) does nothing */
#define DEBUG	/* So D(printf("stuff");) prints */
#ifdef DEBUG
#  define D(x) x
#else
#  define D(x)
#endif

/*
 * Work-around missing entry-point error_top in Windows hdf libraries.
 * See hdf/use/include/herr.h for more about error_top
 */

#ifdef WIN32
int32		error_top = 0;
#endif

/*
 * Nap_HdfCheck --
 *
 *	Append HDF error messages to message.
 */

m4define(`m4NAME', `Nap_HdfCheck')

static void
Nap_HdfCheck(
    NapClientData       *nap_cd)
{
    int32		e;
    int32		i;
    char		msg[201];
    const char		*str;

    for (i = 1; (e = HEvalue(i)) != DFE_NONE; i++) {
	str = HEstring((hdf_err_code_t) e);
	(void) sprintf(msg, "HDF error code %d.	 %0.99s", e, str);
	Nap_CheckAppendLine(nap_cd, msg);
    }
    HEclear();		/* clear the HDF error stack */
    return;
}

/*
 * Nap_HdfSdsGetInfo --
 *
 *	Get rank, shape & HDF (external) number_type
 *	Determine whether dimension 0 is unlimited. (If rank is 0 then false.)
 */

m4define(`m4NAME', `Nap_HdfSdsGetInfo')

static int
Nap_HdfSdsGetInfo(
    NapClientData       *nap_cd,
    int32		sds_id,			/* SDS handle */
    int32		*rank,
    int32		*shape,
    int			*is_unlimited,		/* Is dimension 0 unlimited? */
    int32		*number_type)		/* external HDF data type */
{
    int32		count;
    int32		dim_id;
    char		name[MAX_NC_NAME];
    int32		natts;
    int			status;
    int32		tmp;

    assert(rank);
    assert(shape);
    assert(number_type);
    status = SDgetinfo(sds_id, name, rank, shape, number_type, &natts);
    CHECK2(status == SUCCEED, "m4NAME: Error calling SDgetinfo");
    if (is_unlimited) { 
	if (*rank > 0) { 
	    dim_id = SDgetdimid(sds_id, 0);
	    CHECK2(dim_id >= 0, "m4NAME: Error calling SDgetdimid");
	    status = SDdiminfo(dim_id, NULL, &count, &tmp, &natts);
	    CHECK2(status == SUCCEED, "m4NAME: Error calling SDdiminfo");
	    *is_unlimited = count == 0;
	} else {
	    *is_unlimited = 0;
	}
    }
    return TCL_OK;
}


/*
 * Nap_HdfGetScalingInfo --
 *
 *	Get (uncalibrated) internal_number_type, scale_factor, offset & valid_range.
 *	If unscaled, then set:
 *	    internal_number_type = external_number_type,
 *	    off = 0, cal = 1,
 *	    valid_range to (min, max) for internal data type.
 */

m4begin

m4define(`m4NAME', `Nap_HdfGetScalingInfo')

#  m4range(internal_data_type)
m4define(`m4range', `
	case m4DataTypeEnum($1):
	    valid_range[0] = m4DataTypeEnum($1)_MIN;
	    valid_range[1] = m4DataTypeEnum($1)_MAX;
	    break;')

m4end

static int
Nap_HdfGetScalingInfo(
    NapClientData       *nap_cd,
    int32		sds_id,			/* SDS handle */
    int			raw,			/* 1 to request raw data */
    int32		*internal_number_type,	/* uncalibrated type */
    float64		*cal,			/* scale factor */
    float64		*off,			/* offset */
    float64		valid_range[2])
{
    float64		cal_err;
    int32		external_number_type;
    Nap_dataType	externalDataType;
    Nap_NAO		*max_nao;
    Nap_NAO		*min_nao;
    float64		off_err;
    int32		rank;
    int32		shape[NAP_MAX_RANK];
    int			status;
    Nap_NAO		*tmp_nao;

    assert(internal_number_type);
    assert(cal);
    assert(off);

    /*
     * HDF User's Guide 4.0r2 p79 claims SDgetcal returns TRUE/FALSE
     * However it actually returns SUCCEED/FAIL
     */

    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank, shape, NULL, &external_number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    status = SDgetcal(sds_id, cal, &cal_err, off, &off_err, internal_number_type);
    if (status != SUCCEED  ||  raw) {
	*internal_number_type = external_number_type;
	*off = 0.0;
	*cal = 1.0;
    }
    externalDataType = Nap_Hdf2NapDataType(external_number_type);
    CHECK2(Nap_ValidDataType(externalDataType), "m4NAME: Illegal datatype");
    switch (externalDataType) {
	m4ForAllUnboxedDataType(`m4range(', `)')
	default:		/* error */
	    assert(FALSE);
    }
    if (!raw) {
	min_nao = Nap_NewNAO(nap_cd, externalDataType, 0, NULL);
	max_nao = Nap_NewNAO(nap_cd, externalDataType, 0, NULL);
	status = SDgetrange(sds_id,
		(void *) max_nao->data.c,
		(void *) min_nao->data.c);
	if (status == SUCCEED) {
	    tmp_nao = Nap_CastNAO(nap_cd, min_nao, NAP_F64);
	    valid_range[0] = tmp_nao->data.F64[0];
	    if (tmp_nao != min_nao) {
		Nap_FreeNAO(nap_cd, tmp_nao);
	    }
	    tmp_nao = Nap_CastNAO(nap_cd, max_nao, NAP_F64);
	    valid_range[1] = tmp_nao->data.F64[0];
	    if (tmp_nao != max_nao) {
		Nap_FreeNAO(nap_cd, tmp_nao);
	    }
	    if (valid_range[0] > valid_range[1]) {
		double old0 = valid_range[0];
		valid_range[0] = valid_range[1];
		valid_range[1] = old0;
	    }
	}
	Nap_FreeNAO(nap_cd, min_nao);
	Nap_FreeNAO(nap_cd, max_nao);
    }
    return TCL_OK;
}

/*
 * Nap_HdfOpenFile --
 *
 *	Open file.  If it does not already exist then create it.
 */

m4define(`m4NAME', `Nap_HdfOpenFile')

EXTERN int
Nap_HdfOpenFile(
    NapClientData       *nap_cd,
    char		*fileName,		/* HDF file name */
    char		mode,			/* 'r' = read, 'w' = write */
    int32		*sd_id)			/* file handle (out) */
{
    char		*nativeFilename;	/* filename for platform */

    CHECK2(fileName, "m4NAME: Pointer to file name is NULL");
    CHECK2(sd_id, "m4NAME: Pointer to sd_id is NULL");
    nativeFilename = Nap_GetFileName(nap_cd, fileName);
    CHECK2(nativeFilename, "m4NAME: Illegal fileName");
    switch (mode) {
    case 'r':
	*sd_id = SDstart(nativeFilename, DFACC_RDONLY);
	CHECK3(*sd_id >= 0, "m4NAME: Unable to open input file %s", fileName);
	break;
    case 'w':
	*sd_id = SDstart(nativeFilename, DFACC_WRITE);
	if (*sd_id < 0) {
	    *sd_id = SDstart(nativeFilename, DFACC_CREATE);
	    CHECK3(*sd_id >= 0, "m4NAME: Unable to open output file %s",
		    fileName);
	}
	break;
    default:
	CHECK2(FALSE, "m4NAME: Illegal file access mode");
    }
    NAP_FREE(nap_cd, nativeFilename);
    return TCL_OK;
}

/*
 * Nap_HdfCloseFile --
 */

m4define(`m4NAME', `Nap_HdfCloseFile')

EXTERN int
Nap_HdfCloseFile(
    NapClientData       *nap_cd,
    int32		sd_id)			/* file handle */
{
    int			status;

    status = SDend(sd_id);
    CHECK2(status == SUCCEED, "m4NAME: Unable to close file");
    return TCL_OK;
}

/*
 * Nap_HdfCloseSDS --
 */

m4define(`m4NAME', `Nap_HdfCloseSDS')

EXTERN int
Nap_HdfCloseSDS(
    NapClientData       *nap_cd,
    int32		sds_id)			/* SDS handle */
{
    int			status;

    status = SDendaccess(sds_id);
    CHECK2(status == SUCCEED, "m4NAME: Unable to close SDS");
    return TCL_OK;
}

/*
 * Nap_HdfOpenSDS --
 */

m4define(`m4NAME', `Nap_HdfOpenSDS')

EXTERN int
Nap_HdfOpenSDS(
    NapClientData       *nap_cd,
    int32		sd_id,			/* file handle */
    char		*name_sds,		/* SDS name */
    int			*exists,		/* SDS exists? (out) */
    int32		*sds_id)		/* SDS handle (out) */
{
    int32		sds_index;

    CHECK2(name_sds, "m4NAME: Pointer to SDS name is NULL");
    sds_index = SDnametoindex(sd_id, name_sds);
    *exists = sds_index >= 0;
    if (sds_index >= 0) {
	*sds_id = SDselect(sd_id, sds_index);
	CHECK2(*sds_id >= 0, "m4NAME: Error calling SDselect");
    }
    return TCL_OK;
}

/*
 * Nap_HdfPutSDS --
 */

m4define(`m4NAME', `Nap_HdfPutSDS')

static int
Nap_HdfPutSDS(
    NapClientData       *nap_cd,
    int32		sds_id,		/* SDS handle */
    char		*data,
    int32		*start,
    int32		*edge)
{
    int			i;
    int32		number_type;	/* of SDS */
    int32		rank;
    int32		shape[NAP_MAX_RANK];
    int			status;

    assert(data);
    assert(start);
    assert(edge);
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank, shape, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    for (i = 0; i < rank-1; i++) {
	assert(edge[i] == 1);
    }
    status = SDwritedata(sds_id, start, NULL, edge, data);
    CHECK2(status == SUCCEED, "m4NAME: Error calling SDwritedata");
    return TCL_OK;
}


/*
 * Nap_HdfCreateSDS --
 */

m4begin

m4define(`m4NAME', `Nap_HdfCreateSDS')

#  m4put_range(externalDataType)
m4define(`m4put_range', `
        case m4DataTypeEnum($1):
	    {
		m4DataTypeName($1) zmin = Min(tmp_NAO->data.$1[0], tmp_NAO->data.$1[1]);
		m4DataTypeName($1) zmax = Max(tmp_NAO->data.$1[0], tmp_NAO->data.$1[1]);
		status = SDsetrange(*sds_id, (void *) &zmax, (void *) &zmin);
		CHECK2(status == SUCCEED, "m4NAME: error calling SDsetrange");
	    }
            break;')

m4end

static int
Nap_HdfCreateSDS(
    NapClientData       *nap_cd,
    int32		sd_id,			/* file handle */
    char		*name_sds,		/* SDS name */
    Nap_dataType	dataType,		/* HDF data type */
    int32		rank32,			/* external rank */
    int32		shape32[],		/* external shape */
    Nap_NAO		*cv[],			/* coord. vars (may be NULL) */
    char		*dimName[],		/* dim. names (may be NULL) */
    Nap_dataType	internalDataType,	/* data type of main nao */
    Nap_NAO		*scale_factor_NAO,	/* (may be NULL) */
    Nap_NAO		*add_offset_NAO,	/* (may be NULL) */
    Nap_NAO		*valid_range_NAO,	/* (may be NULL) */
    Nap_NAO		*main_NAO,		/* main nao (in) */
    int			isRecord,		/* Want unlimited dim in new sds? */
    int32		*sds_id)		/* SDS handle (out) */
{
    double		add_offset = 0.0;
    size_t		altShape[] = {1};	/* in case scalar */
    int32		count;
    int32		dim_id;
    int32		edge32[NAP_MAX_RANK];
    int			i;
    Nap_NAO		*missingValue_NAO;	/* fill value (may be NULL) */
    char		name[MAX_NC_NAME];
    int32		natts;
    int32		nels;
    int32		number_type;
    int32		number_type_cv;
    double		scale_factor = 1.0;
    int32		sds_index;
    int32		shape0;
    int32		start32[NAP_MAX_RANK];
    int			status;
    Nap_NAO		*tmp_NAO;

    CHECK2(name_sds, "m4NAME: Pointer to SDS name is NULL");
    number_type = Nap_Nap2HdfDataType(dataType);
    CHECK2(number_type >= 0, "m4NAME: Illegal datatype");
    shape0 = shape32[0];
    if (!isRecord  &&  rank32 > 0  &&  dimName[0]) {
	sds_index = SDnametoindex (sd_id, dimName[0]);
	if (sds_index != FAIL) {
	    isRecord = SDisrecord(SDselect(sd_id, sds_index));
	}
    }
    if (isRecord) {
	shape32[0] = SD_UNLIMITED;
    }
    *sds_id = SDcreate(sd_id, name_sds, number_type, rank32, shape32);
    CHECK2(*sds_id >= 0, "m4NAME: error calling SDcreate");
    shape32[0] = shape0;
    for (i = 0; i < rank32; i++) {
	dim_id = SDgetdimid(*sds_id, i);
	CHECK2(dim_id >= 0, "m4NAME: error calling SDgetdimid");
	status = SDdiminfo(dim_id, name, &count, &number_type_cv, &natts);
	CHECK2(status == SUCCEED, "m4NAME: Error calling SDdiminfo");
	if (dimName  &&	 dimName[i]  &&  strcmp(dimName[i], name)) {
	    status = SDsetdimname(dim_id, dimName[i]);
	    CHECK5(status == SUCCEED,
		    "m4NAME: error calling SDsetdimname i=%d name=%s sds=%s",
		    i, dimName[i], name_sds);
	}
	if (cv	&&  cv[i]  &&  number_type_cv == 0) {
	    CHECK3(cv[i]->rank == 1,
		    "m4NAME: Coordinate variable %s has rank > 1",
		    cv[i]->id);
	    tmp_NAO = Nap_Promote(nap_cd, cv[i], NAP_I32, 1, altShape);
	    number_type = Nap_Nap2HdfDataType(tmp_NAO->dataType);
	    CHECK2(number_type >= 0, "m4NAME: Illegal datatype");
	    status = SDsetdimscale(dim_id, shape32[i], number_type, (VOIDP) tmp_NAO->data.c);
	    CHECK2(status == SUCCEED, "m4NAME: error calling SDsetdimscale");
	    if (tmp_NAO != cv[i]) {
		Nap_FreeNAO(nap_cd, tmp_NAO);
	    }
	    if (cv[i]->format) {
		status = SDsetattr(dim_id, "C_format", DFNT_CHAR, strlen(cv[i]->format),
			(VOIDP) cv[i]->format);
		CHECK2(status == SUCCEED, "m4NAME: error calling SDsetattr");
	    }
	    if (cv[i]->unit) {
		status = SDsetattr(dim_id, "units", DFNT_CHAR, strlen(cv[i]->unit),
			(VOIDP) cv[i]->unit);
		CHECK2(status == SUCCEED, "m4NAME: error calling SDsetattr");
	    }
	}
    }
    if (main_NAO->format) {
	status = SDsetattr(*sds_id, "C_format", DFNT_CHAR, strlen(main_NAO->format),
		(VOIDP) main_NAO->format);
	CHECK2(status == SUCCEED, "m4NAME: error calling SDsetattr");
    }
    status = SDsetdatastrs(*sds_id, main_NAO->label, main_NAO->unit, NULL, NULL);
    CHECK2(status == SUCCEED, "m4NAME: error calling SDsetdatastrs");
    if (scale_factor_NAO) {
	CHECK2(scale_factor_NAO->rank == 0, "m4NAME: scale_factor not scalar");
	tmp_NAO = Nap_CastNAO(nap_cd, scale_factor_NAO, NAP_F64);
	scale_factor = tmp_NAO->data.F64[0];
	if (tmp_NAO != scale_factor_NAO) {
	    Nap_FreeNAO(nap_cd, tmp_NAO);
	}
    }
    if (add_offset_NAO) {
	CHECK2(add_offset_NAO->rank == 0, "m4NAME: scale_factor not scalar");
	tmp_NAO = Nap_CastNAO(nap_cd, add_offset_NAO, NAP_F64);
	add_offset = tmp_NAO->data.F64[0];
	if (tmp_NAO != add_offset_NAO) {
	    Nap_FreeNAO(nap_cd, tmp_NAO);
	}
    }
    if (scale_factor_NAO || add_offset_NAO) {
	number_type= Nap_Nap2HdfDataType(internalDataType);
	CHECK2(number_type >= 0, "m4NAME: Illegal datatype");
	status = SDsetcal(*sds_id, scale_factor, 0.0, add_offset, 0.0, number_type);
	CHECK2(status == SUCCEED, "m4NAME: error calling SDsetcal");
	missingValue_NAO = Nap_StandardMissingValueNAO(nap_cd, dataType);
    } else {
	missingValue_NAO = Nap_GetNaoFromSlot(main_NAO->missingValueSlot);
	if (missingValue_NAO) {
	    if (main_NAO->dataType == NAP_RAGGED) {
		missingValue_NAO = Nap_CastNAO(nap_cd, missingValue_NAO, dataType);
	    } else if (missingValue_NAO->dataType != dataType) {
		missingValue_NAO = Nap_StandardMissingValueNAO(nap_cd, dataType);
	    }
	}
    }
    Nap_IncrRefCount(nap_cd, missingValue_NAO);
    if (valid_range_NAO) {
	CHECK2(valid_range_NAO->rank == 1, "m4NAME: valid_range not vector");
	CHECK2(valid_range_NAO->nels == 2, "m4NAME: nels(valid_range) != 2");
	tmp_NAO = Nap_CastNAO(nap_cd, valid_range_NAO, dataType);
	switch (dataType) {
	    m4ForAllUnboxedDataType(`m4put_range(', `)')
	    default:		/* error */
		assert(FALSE);
	}
	if (tmp_NAO != valid_range_NAO) {
	    Nap_FreeNAO(nap_cd, tmp_NAO);
	}
    }
    if (missingValue_NAO) {
	status = SDsetfillvalue(*sds_id, (VOIDP) missingValue_NAO->data.c);
	CHECK2(status == SUCCEED, "m4NAME: error calling SDsetfillvalue");
    }
    nels = 1;
    for (i = 0; i < rank32; i++) {
	nels *= shape32[i];
	start32[i] = shape32[i] - 1;
	edge32[i] = 1;
    }
    if (nels > 0) {
	if (missingValue_NAO) { /* Force writing of fill values */
	    status = SDwritedata(*sds_id, start32, NULL, edge32,
		    (void *) missingValue_NAO->data.c);
	    CHECK2(status == SUCCEED, "m4NAME: error calling SDwritedata");
	} else if (isRecord) { /* Force expansion of unlimited dim. */
	    tmp_NAO = Nap_NewScalarNAO(nap_cd, dataType, 0.0);
	    CHECK2(tmp_NAO, "m4NAME: error calling Nap_NewScalarNAO");
	    status = SDwritedata(*sds_id, start32, NULL, edge32, (void *) tmp_NAO->data.c);
	    CHECK2(status == SUCCEED, "m4NAME: error calling SDwritedata");
	    Nap_FreeNAO(nap_cd, tmp_NAO);
	}
    }
    Nap_DecrRefCount(nap_cd, missingValue_NAO);
    return TCL_OK;
}

/*
 * Nap_HdfGetSDS --
 */

m4begin

m4define(`m4NAME', `Nap_HdfGetSDS')

# m4scale2(internal_data_type, external_data_type)  e.g. m4scale2(F32, U8)
m4define(`m4scale2', `
		case m4DataTypeEnum($2):
		    if (cal == 1.0  &&	off == 0.0) {
			for (i = 0; i < tmp_nao->nels; i++) {
			    if (IsMissing(tmp_nao, i)
				    ||  tmp_nao->data.$2[i] < valid_range[0]
				    ||  tmp_nao->data.$2[i] > valid_range[1]) {
				ptr$1[i] = mv_nao->data.$1[0];
			    } else {
				ptr$1[i] = tmp_nao->data.$2[i];
			    }
			}
		    } else {
			for (i = 0; i < tmp_nao->nels; i++) {
			    if (IsMissing(tmp_nao, i)
				    ||  tmp_nao->data.$2[i] < valid_range[0]
				    ||  tmp_nao->data.$2[i] > valid_range[1]) {
				ptr$1[i] = mv_nao->data.$1[0];
			    } else {
				ptr$1[i] = cal * (tmp_nao->data.$2[i] - off);
			    }
			}
		    }
		    break;')

#  m4scale(internal_data_type)
m4define(`m4scale', `
	case m4DataTypeEnum($1):
	    switch (externalDataType) {
	    m4ForAllUnboxedDataType(`m4scale2($1, ', `)')
	    default:		/* error */
		assert(FALSE);
	    }
	    break;')

#  m4declare(internal_data_type)
m4define(`m4declare',
`    m4DataTypeName($1) *ptr$1 = (m4DataTypeName($1) *) data;')

m4end

static int
Nap_HdfGetSDS(
    NapClientData       *nap_cd,
    int32		sds_id,			/* SDS handle */
    int			raw,			/* 1 to request raw data */
    char		*data,			/* pointer to destination data area */
    Nap_NAO		*mv_nao,		/* missing value of destination nao */
    int32		*start,
    int32		*edge)
{
    float64		cal;
    int32		external_number_type;	/* HDF type */
    Nap_dataType	externalDataType;
    Nap_NAO		*fill_nao;		/* SDS fill value */
    int			i;
    int32		internal_number_type;
    Nap_dataType	internalDataType;
    Nap_NAO		*tmp_nao;
    float64		off;
    int32		rank;
    size_t		shape[NAP_MAX_RANK];
    int32		shape32[NAP_MAX_RANK];
    int			status;
    float64		valid_range[2];		/* min, max */
    m4ForAllUnboxedDataType(`m4declare(', `)')

    assert(data);
    assert(start);
    assert(edge);
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank, shape32, NULL, &external_number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    for (i = 0; i < rank; i++) {
	if (edge[i] <= 0) {
	    return TCL_OK;
	}
	shape[i] = edge[i];
    }
    status = Nap_HdfGetScalingInfo(nap_cd, sds_id, raw,
	    &internal_number_type, &cal, &off, valid_range);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfGetScalingInfo");
    internalDataType = Nap_Hdf2NapDataType(internal_number_type);
    CHECK2(Nap_ValidDataType(internalDataType), "m4NAME: Illegal datatype");
    externalDataType = Nap_Hdf2NapDataType(external_number_type);
    CHECK2(Nap_ValidDataType(externalDataType), "m4NAME: Illegal datatype");
    tmp_nao = Nap_NewNAO(nap_cd, externalDataType, rank, shape);
    CHECK2(tmp_nao, "m4NAME: Error calling Nap_NewNAO");
    fill_nao = Nap_NewNAO(nap_cd, externalDataType, 0, shape);
    CHECK2(fill_nao, "m4NAME: Error calling Nap_NewNAO");
    status = SDgetfillvalue(sds_id, (void *) fill_nao->data.c);
    i = status == SUCCEED ? fill_nao->slot : 0;
    status = Nap_SetMissing(nap_cd, tmp_nao, i);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
    status = SDreaddata(sds_id, start, NULL, edge, (VOIDP) tmp_nao->data.c);
    CHECK2(status == SUCCEED, "m4NAME: Error calling SDreaddata");
    switch (internalDataType) {
	m4ForAllUnboxedDataType(`m4scale(', `)')
	default:	    /* error */
	    assert(FALSE);
    }
    Nap_FreeNAO(nap_cd, fill_nao);
    Nap_FreeNAO(nap_cd, tmp_nao);
    return TCL_OK;
}

/*
 * Nap_HdfScaleBeforePut --
 *
 * Scale data ready for write.	Also set missing values to SDS fill value.
 */

m4begin

m4define(`m4NAME', `Nap_HdfScaleBeforePut')

# m4scale2(new_data_type, old_data_type)  e.g. m4scale2(F32, U8)
m4define(`m4scale2', `
	    case m4DataTypeEnum($2):
		if (new_NAO->dataType == old_NAO->dataType
			&&  cal == 1.0	&&  off == 0.0) {
		    for (i = 0; i < old_NAO->nels; i++) {
			if (IsMissing(old_NAO, i)) {
			    new_NAO->data.$1[i] = fill_nao->data.$1[0];
			} else {
			    new_NAO->data.$1[i] = old_NAO->data.$2[i];
			}
		    }
		} else {
		    for (i = 0; i < old_NAO->nels; i++) {
			if (IsMissing(old_NAO, i)) {
			    new_NAO->data.$1[i] = fill_nao->data.$1[0];
			} else {
			    z = off + old_NAO->data.$2[i] * rcal;
#if Nap_TypeIsIntegerValue($1)
			    z = Nint(z);
			    z = Max(zmin, z);
			    z = Min(zmax, z);
#endif
			    new_NAO->data.$1[i] = z;
			}
		    }
		}
		break;')

#  m4scale(new_data_type)
m4define(`m4scale', `
	case m4DataTypeEnum($1):
	    switch (old_NAO->dataType) {
	    m4ForAllUnboxedDataType(`m4scale2($1, ', `)')
	    default:		/* error */
		CHECK2(FALSE, "m4NAME: Illegal data-type");
	    }
	    break;')

m4end

static int
Nap_HdfScaleBeforePut(
    NapClientData       *nap_cd,
    int32		sds_id,			/* SDS handle */
    Nap_NAO		*old_NAO,		/* unscaled original NAO */
    Nap_NAO		**new_NAO_Ptr)		/* scaled NAO */
{
    float64		cal;
    Nap_dataType	dataType;
    Nap_NAO		*fill_nao;		/* SDS fill value */
    size_t		i;
    Nap_NAO		*new_NAO;		/* result */
    int32		number_type;
    float64		off;
    int32		rank32;
    float64		rcal;			/* 1/cal */
    size_t		shape[NAP_MAX_RANK];
    int32		shape32[NAP_MAX_RANK];
    int			status;
    float64		valid_range[2];		/* min, max */
    float64		z;			/* new data value */
    float64		zmax;			/* from valid_range */
    float64		zmin;			/* from valid_range */

    status = Nap_HdfGetScalingInfo(nap_cd, sds_id, 0, &number_type, &cal, &off, valid_range);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfGetScalingInfo");
    rcal = 1.0 / cal;
    zmin = valid_range[0];
    zmax = valid_range[1];
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    CHECK2(rank32 >= old_NAO->rank, "m4NAME: Main NAO has rank > that of SDS");
    dataType = Nap_Hdf2NapDataType(number_type);
    CHECK2(Nap_ValidDataType(dataType), "m4NAME: Illegal datatype");
    fill_nao = Nap_NewNAO(nap_cd, dataType, 0, shape);
    CHECK2(fill_nao, "m4NAME: Error calling Nap_NewNAO");
    status = SDgetfillvalue(sds_id, (void *) fill_nao->data.c);
    if (status != SUCCEED) {
	Nap_FreeNAO(nap_cd, fill_nao);
	fill_nao = Nap_StandardMissingValueNAO(nap_cd, dataType);
    }
    for (i = 0; i < rank32; i++) {
	shape[i] = 1;
    }
    for (i = 0; i < old_NAO->rank; i++) {
	shape[rank32 - old_NAO->rank + i] = old_NAO->shape[i];
    }
    new_NAO = Nap_NewNAO(nap_cd, dataType, rank32, shape);
    CHECK2(new_NAO, "m4NAME: Error calling Nap_NewNAO");
    status = Nap_SetMissing(nap_cd, new_NAO, fill_nao->slot);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
    switch (dataType) {
	m4ForAllUnboxedDataType(`m4scale(', `)')
	default:	    /* error */
	    assert(FALSE);
    }
    Nap_FreeNAO(nap_cd, fill_nao);
    *new_NAO_Ptr = new_NAO;
    return TCL_OK;
}

/*
 * Nap_HdfGetAttribute --
 */

m4define(`m4NAME', `Nap_HdfGetAttribute')

static int
Nap_HdfGetAttribute(
    NapClientData       *nap_cd,
    int32		sd_id,			/* file handle */
    char		*name,			/* SDS:ATT */
    Nap_NAO		*main_NAO)		/* attribute NAO */
{
    int32		attr_index;
    Nap_dataType	dataType;
    int			exists;			/* SDS exists? */
    char		*name_att;		/* name of attribute */
    char		name_sds[2*MAX_NC_NAME+2]; /* with space for name_att */
    int32		number_type;
    int32		sds_id;
    int32		shape32[NAP_MAX_RANK];
    int			status;
    char		name_tmp[MAX_NC_NAME+1]; /* for att name */

    CHECK2(main_NAO, "m4NAME: Pointer to main NAO is NULL");
    if (main_NAO->nels == 0) {
	return TCL_OK;
    }
    CHECK2(main_NAO->rank < 2, "m4NAME: main NAO rank > 1");
    CHECK2(strlen(name) <= 2*MAX_NC_NAME+1,
	    "m4NAME: <SDS:ATTRIBUTE> is too long");
    (void) strcpy(name_sds, name);
    name_att = strchr(name_sds, ':');
    assert(name_att);
    *name_att = '\0';
    ++name_att;
    number_type = Nap_Nap2HdfDataType(main_NAO->dataType);
    CHECK2(number_type >= 0, "m4NAME: Illegal datatype");
    if (strlen(name_sds) == 0) {
	sds_id = sd_id;
    } else {
	status = Nap_HdfOpenSDS(nap_cd, sd_id, name_sds, &exists, &sds_id);
	CHECK(status == TCL_OK);
	CHECK2(exists, "m4NAME: SDS does not exist");
    }
    attr_index = SDfindattr(sds_id, name_att);
    CHECK2(attr_index >= 0, "m4NAME: Error calling SDfindattr");
    status= SDattrinfo(sds_id, attr_index, name_tmp, &number_type, shape32);
    CHECK2(status == SUCCEED, "m4NAME: Error calling SDattrinfo");
    CHECK2(main_NAO->rank < 2, "m4NAME: NAO rank > 1");
    dataType = Nap_Hdf2NapDataType(number_type);
    CHECK2(dataType == main_NAO->dataType,
	    "m4NAME: HDF dataType != NAO dataType");
    CHECK2(main_NAO->nels >= shape32[0],
	    "m4NAME: NAO has too few elements");
    status = SDreadattr(sds_id, attr_index,
	    (VOIDP) main_NAO->data.c);
    CHECK2(status == SUCCEED, "m4NAME: Error calling SDreadattr");
    if (strlen(name_sds) > 0) {
	status = Nap_HdfCloseSDS(nap_cd, sds_id);
	CHECK(status == TCL_OK);
    }
    return TCL_OK;
}

/*
 * Nap_HdfPutAttribute --
 */

m4define(`m4NAME', `Nap_HdfPutAttribute')

static int
Nap_HdfPutAttribute(
    NapClientData       *nap_cd,
    int32		sd_id,			/* file handle */
    char		*name,			/* SDS:ATT */
    Nap_NAO		*main_NAO)		/* attribute NAO */
{
    int			exists;			/* SDS exists? */
    char		*name_att;		/* name of attribute */
    char		name_sds[2*MAX_NC_NAME+2]; /* with space for name_att */
    int32		number_type;
    int32		sds_id;
    int			status;

    CHECK2(main_NAO, "m4NAME: Pointer to main NAO is NULL");
    CHECK2(main_NAO->nels > 0, "m4NAME: main NAO is empty"); /* HDF does not allow empty att */
    CHECK2(main_NAO->rank < 2, "m4NAME: main NAO rank > 1");
    CHECK2(strlen(name) <= 2*MAX_NC_NAME+1,
	    "m4NAME: <SDS:ATTRIBUTE> is too long");
    (void) strcpy(name_sds, name);
    name_att = strchr(name_sds, ':');
    assert(name_att);
    *name_att = '\0';
    ++name_att;
    number_type = Nap_Nap2HdfDataType(main_NAO->dataType);
    CHECK2(number_type >= 0, "m4NAME: Illegal datatype");
    if (strlen(name_sds) == 0) {
	sds_id = sd_id;
    } else {
	status = Nap_HdfOpenSDS(nap_cd, sd_id, name_sds, &exists, &sds_id);
	CHECK(status == SUCCEED);
	CHECK2(exists, "m4NAME: SDS does not exist");
    }
    status = SDsetattr(sds_id, name_att, number_type, main_NAO->nels,
	    (VOIDP) main_NAO->data.c);
    CHECK2(status == SUCCEED, "m4NAME: error calling SDsetattr");
    if (strlen(name_sds) > 0) {
	status = Nap_HdfCloseSDS(nap_cd, sds_id);
	CHECK(status == TCL_OK);
    }
    return TCL_OK;
}

/*
 * Nap_HdfGetDim --
 *
 *	Get coordinate-variable & dimension-name from file.
 *	If no coordinate-variable then coordinate-variable result is NULL.
 *	If cv_hdf_NAO or name is NULL then do not define it.
 */

m4define(`m4NAME', `Nap_HdfGetDim')

static int
Nap_HdfGetDim(
    NapClientData       *nap_cd,
    int32		sds_id,
    intn		dim_index,
    Nap_NAO		**cv_hdf_NAO,	/* result (out: malloced here) */
    char		*name)			/* result (out) */
{
    int32		attr_index;
    int32		count;
    Nap_dataType	dataType;
    int32		dim_id;
    char		name_dim[MAX_NC_NAME];
    int32		natts;
    int32		number_type;
    int32		rank32;
    size_t		shape[1];		/* shape of coord var */
    int32		shape32[NAP_MAX_RANK];
    int			status;

    dim_id = SDgetdimid(sds_id, dim_index);
    CHECK2(dim_id >= 0, "m4NAME: Error calling SDgetdimid");
    name = name ? name : name_dim;
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    status = SDdiminfo(dim_id, name, &count, &number_type, &natts);
    CHECK2(status == SUCCEED, "m4NAME: Error calling SDdiminfo");
    if (cv_hdf_NAO) {
	if (number_type > 0  &&  ! SDiscoordvar(sds_id)) {
	    dataType = Nap_Hdf2NapDataType(number_type);
	    CHECK2(Nap_ValidDataType(dataType), "m4NAME: Illegal datatype");
	    shape[0] = dim_index == 0  &&  SDisrecord(sds_id) ? shape32[0] : count;
	    *cv_hdf_NAO = Nap_NewNAO(nap_cd, dataType, 1, shape);
	    CHECK2(*cv_hdf_NAO, "m4NAME: Error calling Nap_NewNAO");
	    status = SDgetdimscale(dim_id, (VOIDP) (*cv_hdf_NAO)->data.c);
	    CHECK2(status == SUCCEED, "m4NAME: Error calling SDgetdimscale");
	    attr_index = SDfindattr(dim_id, "C_format");
	    if (attr_index >= 0) {
		status= SDattrinfo(dim_id, attr_index, name_dim, &number_type, &count);
		CHECK2(status == SUCCEED, "m4NAME: Error calling SDattrinfo");
		(*cv_hdf_NAO)->format = (char *) NAP_ALLOC(nap_cd, count+1);
		assert((*cv_hdf_NAO)->format);
		status = SDreadattr(dim_id, attr_index, (*cv_hdf_NAO)->format);
		(*cv_hdf_NAO)->format[count] = '\0';
	    }
	    attr_index = SDfindattr(dim_id, "units");
	    if (attr_index >= 0) {
		status= SDattrinfo(dim_id, attr_index, name_dim, &number_type, &count);
		CHECK2(status == SUCCEED, "m4NAME: Error calling SDattrinfo");
		(*cv_hdf_NAO)->unit = (char *) NAP_ALLOC(nap_cd, count+1);
		assert((*cv_hdf_NAO)->unit);
		status = SDreadattr(dim_id, attr_index, (*cv_hdf_NAO)->unit);
		(*cv_hdf_NAO)->unit[count] = '\0';
	    }
	} else {
	    *cv_hdf_NAO = NULL;
	}
    }
    return TCL_OK;
}

/*
 * nap_HdfGetIndex --
 *
 *	Get index NAO from index arg.
 */

m4define(`m4NAME', `nap_HdfGetIndex')

EXTERN int
nap_HdfGetIndex(
    NapClientData       *nap_cd,
    int32		sds_id,
    Tcl_Obj		*indexObj,		/* index arg. */
    Nap_NAO		**index_nao)		/* result (out) */
{
    Nap_NAO		*boxedCV;		/* boxed NAO of CVs */
    Nap_NAO		*cv_hdf_NAO;		/* cv from hdf file */
    int			i;
    int32		number_type;
    int32		rank32;
    size_t		shape[1];
    int32		shape32[NAP_MAX_RANK];
    int			status;
    char		*str;
    Nap_NAO		*tmp_nao;

    assert(indexObj);
    assert(index_nao);
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    shape[0] = rank32;
    boxedCV = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
    CHECK2(boxedCV, "m4NAME: Error calling Nap_NewNAO");
    Nap_IncrRefCount(nap_cd, boxedCV);
    for (i = 0; i < rank32; i++) {
	status = Nap_HdfGetDim(nap_cd, sds_id, i, &cv_hdf_NAO, NULL);
	CHECK(status == TCL_OK);
	assert(Nap_IsNAO(nap_cd, cv_hdf_NAO) || !cv_hdf_NAO);
	boxedCV->data.Boxed[i] = cv_hdf_NAO ? cv_hdf_NAO->slot : 0;
	Nap_IncrRefCount(nap_cd, cv_hdf_NAO);
    }
    if (rank32 < 2) {
	*index_nao = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
	CHECK2(*index_nao, "m4NAME: Error calling Nap_NewNAO");
    }
    if (rank32 == 1) {
	if (indexObj->length == 0) {
	    (*index_nao)->data.Boxed[0] = 0;
	} else {
	    str = Nap_expression(nap_cd, indexObj, boxedCV);
	    CHECK2(str, "m4NAME: Error evaluating index expression");
	    tmp_nao = Nap_GetNaoFromId(nap_cd, str);
	    CHECK2(tmp_nao, "m4NAME: Error calling Nap_GetNaoFromId");
	    CHECK2(!Nap_IsBoxed(tmp_nao), "m4NAME: Illegal index expression");
	    (*index_nao)->data.Boxed[0] = tmp_nao->slot;
	    Nap_IncrRefCount(nap_cd, tmp_nao);
	}
    } else if (rank32 > 1) {
	if (indexObj->length == 0) {
	    *index_nao = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape);
	    CHECK2(*index_nao, "m4NAME: Error calling Nap_NewNAO");
	    for (i = 0; i < rank32; i++) {
		(*index_nao)->data.Boxed[i] = 0;
	    }
	} else {
	    str = Nap_expression(nap_cd, indexObj, boxedCV);
	    CHECK2(str, "m4NAME: Error evaluating index expression");
	    tmp_nao = Nap_GetNaoFromId(nap_cd, str);
	    CHECK2(tmp_nao, "m4NAME: Error calling Nap_GetNaoFromId");
	    CHECK2(Nap_IsBoxed(tmp_nao) && tmp_nao->nels == rank32,
		    "m4NAME: Illegal index expression");
	    *index_nao = tmp_nao;
	}
    }
    assert(Nap_IsNAO(nap_cd, boxedCV));
    Nap_DecrRefCount(nap_cd, boxedCV);
    assert(*index_nao);
    assert(Nap_IsBoxed(*index_nao));
    assert((*index_nao)->nels == rank32);
    return TCL_OK;
}

/*
 * Nap_HdfDefineSubscript --
 *
 *	Use subscript_NAO to define subscript_ptr, start32, edge32.
 *	If needed malloc buffer (else NULL).
 *	If doing input (mode == 'r') then attach coordinate vars to main_NAO.
 */

m4define(`m4NAME', `Nap_HdfDefineSubscript')

static int
Nap_HdfDefineSubscript(
    NapClientData       *nap_cd,
    int32		sds_id,
    Nap_NAO		*main_NAO,		/* main nao (in) */
    char		mode,			/* 'r' = read, 'w' = write */
    Nap_NAO		*subscript_NAO,		/* (boxed) subscript nao (in) */
    int32		*subscript_ptr[],	/* ragged matrix (out) */
    int32		start32[],		/* define final element (out) */
    int32		edge32[],	/* all 1 except final element (out) */
    size_t		shape1[NAP_MAX_RANK],	/* shape of main_NAO with additional 1s (out) */
    char		**buffer)	/* Malloced by Nap_HdfDefineSubscript */
{
    Nap_NAO		*boxed_subscript_NAO;	/* local (boxed) subscript nao */
    Nap_NAO		*cv_hdf_NAO;		/* cv from hdf file */
    Nap_NAO		*el_NAO;		/* element of subscript */
    int			i;
    int			is_contiguous;	    /* TRUE if final dim has no gaps */
    int			j;
    Nap_NAO		*linkNao;		/* used for indirect indexing */
    char		name[MAX_NC_NAME];
    int32		number_type;
    int32		rank32;
    size_t		shape_tmp[NAP_MAX_RANK];
    int32		shape32[NAP_MAX_RANK];	/* shape in file */
    size_t		size;			/* sizeof(dataType) */
    int32		smax;			/* max. subscript value */
    int32		smin;			/* min. subscript value */
    int			status;
    char		*str;
    Nap_NAO		*sub_NAO;		/* subscript */
    Nap_NAO		*tmp_NAO;
    Nap_NAO		*tmp_NAO2;

    assert(subscript_NAO);
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    if (rank32 > 0) {
	if (subscript_NAO->dataType == NAP_BOXED) {
	    boxed_subscript_NAO = subscript_NAO;
	} else {
	    shape1[0] = 1;
	    boxed_subscript_NAO = Nap_NewNAO(nap_cd, NAP_BOXED, 1, shape1);
	    CHECK2(boxed_subscript_NAO, "m4NAME: Error calling Nap_NewNAO");
	    boxed_subscript_NAO->data.Boxed[0] = subscript_NAO->slot;
	    Nap_IncrRefCount(nap_cd, subscript_NAO);
	}
	Nap_IncrRefCount(nap_cd, boxed_subscript_NAO);
	CHECK2(boxed_subscript_NAO->rank == 1, "m4NAME: Subscript rank != 1");
	CHECK2(boxed_subscript_NAO->nels == rank32,
		"m4NAME: # elements in subscript != nc rank");
	CHECK2(main_NAO->rank <= rank32, "m4NAME: rank of NAO exceeds rank of netCDF variable");
	if (main_NAO->rank == rank32) {
	    for (i = 0; i < rank32; i++) {
		shape1[i] = main_NAO->shape[i];
	    }
	} else {
	    j = main_NAO->rank - 1;
	    for (i = rank32-1; i >= 0; i--) {
		shape1[i] = 1;
		if (j >= 0) {
		    el_NAO = Nap_GetNaoFromSlot(boxed_subscript_NAO->data.Boxed[i]);
		    if (el_NAO) {
			CHECK2(el_NAO->rank <= 1, "m4NAME: Subscript rank > 1");
			CHECK2(Nap_IsInteger(el_NAO), "m4NAME: Subscript not integer");
			Nap_IncrRefCount(nap_cd, el_NAO);
			if (el_NAO->rank > 0) {
			    shape1[i] = main_NAO->shape[j--];
			    CHECK2(el_NAO->nels == shape1[i],
				    "m4NAME: Subscript element does not match NAO dimension");
			}
			Nap_DecrRefCount(nap_cd, el_NAO);
		    } else {
			shape1[i] = main_NAO->shape[j--];
		    }
		}
	    }
	}
	for (i = 0; i < rank32; i++) {
	    cv_hdf_NAO = el_NAO = sub_NAO = tmp_NAO = NULL;
	    edge32[i] = 1;
	    status = Nap_HdfGetDim(nap_cd, sds_id, i, &cv_hdf_NAO, name);
	    CHECK(status == TCL_OK);
	    subscript_ptr[i] = (int32 *) NAP_ALLOC(nap_cd, shape1[i] * sizeof(int32));
	    CHECK(subscript_ptr[i]);
	    if (i < boxed_subscript_NAO->nels	 &&  boxed_subscript_NAO->data.Boxed[i]) {
		el_NAO = Nap_GetNaoFromSlot(boxed_subscript_NAO->data.Boxed[i]);
		CHECK2(el_NAO->rank <= 1, "m4NAME: Subscript element rank > 1");
		Nap_IncrRefCount(nap_cd, el_NAO);
		if (!cv_hdf_NAO) {
		    shape_tmp[0] = shape32[i];
		    cv_hdf_NAO = Nap_NewNAO(nap_cd, NAP_I32, 1, shape_tmp);
		    CHECK2(cv_hdf_NAO, "m4NAME: Error calling Nap_NewNAO");
		    for (j = 0; j < shape32[i]; j++) {
			cv_hdf_NAO->data.I32[j] = j;
		    }
		}
		sub_NAO = Nap_CastNAO(nap_cd, el_NAO, NAP_I32);
		CHECK2(sub_NAO, "m4NAME: Error calling Nap_CastNAO");
	    } else {
		sub_NAO = Nap_NewNAO(nap_cd, NAP_I32, 1, shape1+i);
		CHECK2(sub_NAO, "m4NAME: Error calling Nap_NewNAO");
		for (j = 0; j < shape1[i]; j++) {
		    sub_NAO->data.I32[j] = j;
		}
	    }
	    Nap_IncrRefCount(nap_cd, cv_hdf_NAO);
	    assert(sub_NAO);
	    Nap_IncrRefCount(nap_cd, sub_NAO);
	    for (j = 0; j < shape1[i]; j++) {
		if (i == 0  &&  SDisrecord(sds_id)  &&  sub_NAO->data.I32[j] >= 0) {
		    subscript_ptr[i][j] = sub_NAO->data.I32[j];
		} else {
		    subscript_ptr[i][j] = Nap_mod(sub_NAO->data.I32[j], shape32[i]);
		}
	    }
	    if (mode == 'r') {
		if (cv_hdf_NAO) {
		    if (sub_NAO->linkSlot) {
			tmp_NAO = Nap_GetNaoFromSlot(sub_NAO->linkSlot);
			Nap_IncrRefCount(nap_cd, tmp_NAO);
		    } else {
			str = Nap_Index(nap_cd, cv_hdf_NAO->id , sub_NAO->id);
			CHECK2(str, "m4NAME: Error defining new coordinate variable");
			tmp_NAO = Nap_GetNumericNaoFromId(nap_cd, str);
			CHECK2(tmp_NAO, "m4NAME: Error calling Nap_GetNumericNaoFromId");
			Nap_IncrRefCount(nap_cd, tmp_NAO);
			if (tmp_NAO->rank == 0) {
			    tmp_NAO2 = tmp_NAO;
			    j = shape1[0];
			    shape1[0] = 1;
			    tmp_NAO = Nap_ReshapeNAO(nap_cd, tmp_NAO2, tmp_NAO2->dataType, 1,
				    shape1);
			    CHECK2(tmp_NAO, "m4NAME: Error calling Nap_ReshapeNAO");
			    Nap_IncrRefCount(nap_cd, tmp_NAO);
			    Nap_DecrRefCount(nap_cd, tmp_NAO2);
			    shape1[0] = j;
			}
		    }
		    NAP_FREE(nap_cd, tmp_NAO->format);
		    tmp_NAO->format = Nap_StrDup(nap_cd, cv_hdf_NAO->format);
		    NAP_FREE(nap_cd, tmp_NAO->unit);
		    tmp_NAO->unit = Nap_StrDup(nap_cd, cv_hdf_NAO->unit);
		    status = Nap_AttachCoordVar(nap_cd, main_NAO, tmp_NAO, name, i);
		    CHECK(status == TCL_OK);
		    Nap_DecrRefCount(nap_cd, tmp_NAO);
		} else {
		    status = Nap_AttachCoordVar(nap_cd, main_NAO, NULL, name, i);
		    CHECK(status == TCL_OK);
		}
	    }
	    Nap_DecrRefCount(nap_cd, cv_hdf_NAO);
	    Nap_DecrRefCount(nap_cd, el_NAO);
	    Nap_DecrRefCount(nap_cd, sub_NAO);
	}
	i = rank32-1;
	if (subscript_ptr[i]) {
	    smin = smax = subscript_ptr[i][0];
	    for (j = 1; j < shape1[i]; j++) {
		smin = Min(smin, subscript_ptr[i][j]);
		smax = Max(smax, subscript_ptr[i][j]);
	    }
	    start32[i] = smin;
	    edge32[i] = 1 + smax - smin;
	    is_contiguous = TRUE;
	    for (j = 1; j < shape1[i]; j++) {
		is_contiguous = is_contiguous && subscript_ptr[i][j] == smin+j;
	    }
	    if (is_contiguous) {
		*buffer = NULL;
	    } else {
		if (mode == 'r') {
		    size = Nap_SizeOf(main_NAO->dataType);
		} else {
		    size = DFKNTsize(number_type);
		}
		*buffer = (char *) NAP_ALLOC(nap_cd, edge32[i] * size);
		CHECK(*buffer);
	    }
	} else {
	    start32[i] = 0;
	    edge32[i] = shape1[i];
	    *buffer = NULL;
	}
	Nap_DecrRefCount(nap_cd, boxed_subscript_NAO);
    } else {
	*buffer = NULL;
    }
    return TCL_OK;
}

/*
 * Nap_HdfPutSubscripting --
 *
 *	Called by Nap_HdfPut to do recursive subscripting.
 */

m4define(`m4NAME', `Nap_HdfPutSubscripting')

static int
Nap_HdfPutSubscripting(
    NapClientData       *nap_cd,
    int32		sds_id,			/* HDF sds ID */
    int32		dim_num,		/* current dimension number */
    Nap_NAO		*scaled_NAO,
    int32		start32[],		/* HDF subscript */
    int32		edge32[],	     /* HDF edge (all 1 except final) */
    size_t		shape1[NAP_MAX_RANK],	/* shape of main_NAO with additional 1s */
    int32		*subscript_ptr[],      /* specified subscript vectors */
    char		**data_ptr,		/* points to next NAO element */
    char		*buffer)		/* For actual write */
{
    size_t		i;
    size_t		j;
    size_t		nels;
    int32		number_type;
    int32		rank32;			/* scaled_NAO & hdf rank */
    int32		shape32[NAP_MAX_RANK];
    size_t		size;			/* sizeof(dataType) */
    int			status;

    assert(dim_num >= 0);
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    assert(rank32 == 0	||  dim_num < rank32);
    size = DFKNTsize(number_type);
    if (rank32 == 0  ||	 dim_num == rank32-1) {
	if (buffer) {
	    nels = 1;
	    for (i = 0; i < rank32; i++) {
		CHECK3(start32[i] + edge32[i] <= shape32[i], "m4NAME: illegal index %d", i);
		nels *= shape32[i];
	    }
	    assert (nels > 0);
	    if (nels > 0) {
		status = SDreaddata(sds_id, start32, NULL, edge32, (VOIDP) buffer);
		CHECK2(status == SUCCEED, "m4NAME: Error calling SDreaddata");
	    }
	    for (i = 0; i < shape1[dim_num]; i++) {
		j = size * (subscript_ptr[dim_num][i] - start32[dim_num]);
		memcpy(buffer+j, *data_ptr, size);
		*data_ptr += size;
	    }
	    status = Nap_HdfPutSDS(nap_cd, sds_id, buffer, start32, edge32);
	    CHECK(status == TCL_OK);
	} else {
	    status = Nap_HdfPutSDS(nap_cd, sds_id, *data_ptr, start32, edge32);
	    CHECK(status == TCL_OK);
	    if (rank32 > 0) {
		*data_ptr += edge32[rank32-1] * size;
	    }
	}
    } else {
	assert(edge32[dim_num] == 1);
	assert(subscript_ptr[dim_num]);
	for (i = 0; i < shape1[dim_num]; i++) {
	    start32[dim_num] = subscript_ptr[dim_num][i];
	    status = Nap_HdfPutSubscripting(nap_cd, sds_id, dim_num+1,
		    scaled_NAO, start32, edge32, shape1, subscript_ptr, data_ptr, buffer);
	    CHECK(status == TCL_OK);
	}
    }
    return TCL_OK;
}

/*
 * Nap_HdfPutSubscriptingRagged --
 *
 *	Called by Nap_HdfPut to do recursive subscripting.
 */

m4define(`m4NAME', `Nap_HdfPutSubscriptingRagged')

static int
Nap_HdfPutSubscriptingRagged(
    NapClientData       *nap_cd,
    int32		sds_id,			/* HDF sds ID */
    int32		dim_num,		/* current dimension number */
    Nap_NAO		*main_NAO,		/* pointer to main nao */
    int32		start32[],		/* HDF subscript */
    int32		edge32[],	     /* HDF edge (all 1 except final) */
    int32		*subscript_ptr[],      /* specified subscript vectors */
    size_t		*row,		/* next row (NULL on 1st call) */
    char		*buffer)		/* For actual write */
{
    size_t		i;
    size_t		local_row = 0;
    int32		number_type;
    int32		rank32;			/* main_NAO & hdf rank */
    Nap_NAO		*scaled_NAO;
    size_t		*shape;			/* shape of main_NAO */
    int32		shape32[NAP_MAX_RANK];
    Nap_NAO		*startNao;		/* for ragged matrix */
    int			status;
    Nap_NAO		*tmp_NAO;

    assert(dim_num >= 0);
    if (dim_num == 0) {
	row = &local_row;
    }
    shape = main_NAO->shape;
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    assert(rank32 >= 2);
    assert(dim_num < rank32);
    if (dim_num == rank32-1) {
	if (buffer) {
	    CHECK2(0, "m4NAME: Not implemented");		/* TO DO */
	} else {
	    startNao = Nap_GetNaoFromSlot(main_NAO->raggedStartSlot);
	    CHECK2(startNao, "m4NAME: Error calling Nap_GetNaoFromSlot");
	    tmp_NAO = Nap_GetNaoFromSlot(main_NAO->data.Ragged[*row]);
	    if (tmp_NAO) {
		edge32[dim_num] = tmp_NAO->nels;
		if (edge32[dim_num] > 0) {
		    assert(tmp_NAO->rank == 1);
		    status = Nap_HdfScaleBeforePut(nap_cd, sds_id,tmp_NAO,&scaled_NAO);
		    CHECK(status == TCL_OK);
		    start32[dim_num] += startNao->data.I32[*row];
		    status = Nap_HdfPutSDS(nap_cd, sds_id,
			    scaled_NAO->data.c, start32, edge32);
		    CHECK(status == TCL_OK);
		    start32[dim_num] -= startNao->data.I32[*row];
		    if (scaled_NAO != tmp_NAO) {
			Nap_FreeNAO(nap_cd, scaled_NAO);
		    }
		}
	    }
	}
	++*row;
    } else {
	assert(edge32[dim_num] == 1);
	assert(subscript_ptr[dim_num]);
	for (i = 0; i < shape[dim_num]; i++) {
	    start32[dim_num] = subscript_ptr[dim_num][i];
	    status = Nap_HdfPutSubscriptingRagged(nap_cd, sds_id, dim_num+1,
		    main_NAO, start32, edge32, subscript_ptr, row, buffer);
	    CHECK(status == TCL_OK);
	}
    }
    return TCL_OK;
}

/*
 * Nap_HdfExtend --
 *	If necessary then extend unlimited dimension by writing to corresponding coord. var.
 */

m4define(`m4NAME', `Nap_HdfExtend')

EXTERN int
Nap_HdfExtend(
    NapClientData       *nap_cd,
    int32		sd_id,
    int32		sds_id,
    Nap_NAO		*main_NAO)		/* pointer to main nao */
{
    int32		edge[NAP_MAX_RANK];
    Nap_NAO		*cv;			/* coord. var. corr. to unlimited dim */
    Nap_NAO		*cv64;			/* cv cast to F64 */
    Nap_dataType	externalDataType;	/* HDF type */
    double		final;			/* final value in current cv */
    double		first;			/* first value in current cv */
    int			i;
    int32		i_sds;			/* index of SDS */
    int			is_unlimited;		/* Is dimension 0 unlimited? */
    int			n;			/* current # records */
    int32		n_sds;			/* number SDSs in file */
    int32		natts;
    int32		number_type;
    int32		rank32;
    int32		sds_id_cv;		/* sds id of cv */
    int32		shape32[NAP_MAX_RANK];	/* shape of SDS */
    size_t		size;			/* # bytes in element */
    int32		start[NAP_MAX_RANK];
    int			status;
    Nap_NAO		*tmp_NAO;
    double		x;			/* value in internal cv */

    for (i = 0; i < NAP_MAX_RANK; i++) {
	start[i] = 0;
	edge[i] = 1;
    }
    if (SDiscoordvar(sds_id)) {
	cv = main_NAO;
	sds_id_cv = sds_id;
    } else {
	cv = Nap_GetCoordVar(nap_cd, main_NAO, 0);
	if (cv) {
	    status = SDfileinfo(sd_id, &n_sds, &natts);
	    CHECK2(status == SUCCEED, "m4NAME: Error calling SDfileinfo");
	    for (i_sds = 0; i_sds < n_sds; i_sds++) {
		sds_id_cv = SDselect(sd_id, i_sds);
		status = Nap_HdfSdsGetInfo(nap_cd, sds_id_cv, &rank32, shape32, &is_unlimited,
			&number_type);
		CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
		if (is_unlimited  &&  SDiscoordvar(sds_id_cv)) {
		    i_sds = n_sds;
		}
	    }
	    CHECK2(i_sds == n_sds + 1, "m4NAME: coord. var. for unlimited dim. not found");
	}
    }
    Nap_IncrRefCount(nap_cd, cv);
    if (cv  &&  cv->nels > 0) {
	CHECK2(cv->rank == 1, "m4NAME: rank of internal coord. var. not 1");
	status = Nap_HdfSdsGetInfo(nap_cd, sds_id_cv, &rank32, shape32, &is_unlimited,
		&number_type);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
	CHECK2(rank32 == 1, "m4NAME: rank of HDF coord. var. not 1");
	CHECK2(is_unlimited, "m4NAME: HDF coord. var. does not have unlimited dim.");
	externalDataType = Nap_Hdf2NapDataType(number_type);
	CHECK2(Nap_ValidDataType(externalDataType), "m4NAME: Illegal datatype");
	size = Nap_SizeOf(externalDataType);
	tmp_NAO = cv;
	cv = Nap_CastNAO(nap_cd, tmp_NAO, externalDataType);
	CHECK2(cv, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, cv);
	Nap_DecrRefCount(nap_cd, tmp_NAO);
	cv64 = Nap_CastNAO(nap_cd, cv, NAP_F64);
	CHECK2(cv64, "m4NAME: Error calling Nap_CastNAO");
	Nap_IncrRefCount(nap_cd, cv64);
	n = shape32[0];
	if (n > 0) {		/* define first, final */
	    tmp_NAO = Nap_NewNAO(nap_cd, externalDataType, 0, NULL);
	    CHECK2(tmp_NAO, "m4NAME: Error calling Nap_NewNAO");
	    Nap_IncrRefCount(nap_cd, tmp_NAO);
	    start[0] = 0;
	    edge[0] = 1;
	    status = SDreaddata(sds_id_cv, start, NULL, edge, (VOIDP) tmp_NAO->data.c);
	    CHECK2(status == SUCCEED, "m4NAME: Error calling SDreaddata");
	    status = Nap_F64ScalarValue(nap_cd, tmp_NAO, &first);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
	    start[0] = n - 1;
	    status = SDreaddata(sds_id_cv, start, NULL, edge, (VOIDP) tmp_NAO->data.c);
	    CHECK2(status == SUCCEED, "m4NAME: Error calling SDreaddata");
	    status = Nap_F64ScalarValue(nap_cd, tmp_NAO, &final);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_F64ScalarValue");
	    Nap_DecrRefCount(nap_cd, tmp_NAO);
	}
	for (i = 0; i < cv->nels; i++) {
	    x = cv64->data.F64[i];
	    if (shape32[0] == 0  ||  (x-first)*(x-final) > 0.0) {
		start[0] = n;
		status = SDwritedata(sds_id_cv, start, NULL, edge, (void *) (cv->data.c + size*i));
		CHECK2(status == SUCCEED, "m4NAME: error calling SDwritedata");
		++n;
	    }
	    if (sds_id_cv != sds_id) {
		status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, &is_unlimited,
			&number_type);
		CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
		if (shape32[0] < n) {
		    start[0] = shape32[0];
		    edge[0] = n - shape32[0];
			/* Force creation of records (do not care what data is written) */
		    status = SDwritedata(sds_id, start, NULL, edge, (void *) (main_NAO->data.c));
		    CHECK2(status == SUCCEED, "m4NAME: error calling SDwritedata");
		    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, &is_unlimited,
			    &number_type);
		    CHECK2(shape32[0] == n, "m4NAME: Error using SDwritedata to extend dim.");
		}
	    }
	}
	Nap_DecrRefCount(nap_cd, cv64);
    }
    Nap_DecrRefCount(nap_cd, cv);
    return TCL_OK;
}

/*
 * Nap_HdfPut --
 *	Write NAO to whole or part of sds in hdf file.
 *	Allow chunking by defining coordinate variables larger than current NAO.
 *
 *	If file does not exist then create it.
 *
 *	If sds_name contains ':' then treat part after ':' as attribute name.
 *	If sds does not exist then create it with dimensions & coordinate
 *	variables defined by cv_hdf[0], cv_hdf[1], ... cv_hdf[rank].
 *	If cv_hdf or cv_hdf[i] is NULL then use main_NAO->shape[i] &
 *	(if defined) CV for dim i defined by main_NAO->boxedCV
 *
 *	If sds_dataType is undefined then use type corresponding to that of
 *	main_NAO.
 *
 *	Use CV for dim i defined by main_NAO->boxedCV to define start, etc.
 */

m4define(`m4NAME', `Nap_HdfPut')

EXTERN int
Nap_HdfPut(
    NapClientData       *nap_cd,
    int32		sd_id,			/* File handle */
    char		*sds_name,		/* HDF sds (var) name */
    Nap_dataType	sds_dataType,		/* HDF data type for new SDS */
    Nap_NAO		*scale_factor_NAO,	/* for new SDS */
    Nap_NAO		*add_offset_NAO,	/* for new SDS */
    Nap_NAO		*valid_range_NAO,	/* for new SDS */
    Nap_NAO		*main_NAO,		/* pointer to main nao */
    Nap_NAO		*boxed_cv_hdf,		/* pointers to CV NAOs */
    Tcl_Obj		*indexObj,		/* index arg. */
    int			isRecord)		/* Want unlimited dim in new sds? */
{
    size_t		altShape[] = {1};	/* in case scalar */
    char		*buffer;		/* For actual write */
    Nap_NAO		*cv_hdf_local[NAP_MAX_RANK];	/* local cv_hdf */
    char		*data_ptr;		/* points to next NAO element */
    Nap_dataType	dataType;
    char		*dimName[NAP_MAX_RANK];	/* external dimension names */
    int			exists;			/* SDS exists? */
    int32		edge32[NAP_MAX_RANK];
    int			i;
    int			id;
    int			is_unlimited;		/* Is dimension 0 unlimited? */
    int32		number_type;
    int32		rank;			/* internal rank */
    int32		rank32;			/* external rank */
    Nap_NAO		*scaled_NAO;
    int32		sds_id;
    size_t		shape1[NAP_MAX_RANK];	/* shape of main_NAO with additional 1s */
    int32		shape32[NAP_MAX_RANK];	/* shape of SDS */
    int			status;
    int32		start32[NAP_MAX_RANK];
    Nap_NAO		*subscript_NAO;		/* pointer to subscript nao */
    int32		*subscript_ptr[NAP_MAX_RANK];
    Nap_NAO		*tmp_NAO;

    CHECK2(sds_name, "m4NAME: Pointer to SDS name is NULL");
    CHECK2(main_NAO, "m4NAME: Pointer to main NAO is NULL");
    if (strchr(sds_name, ':')) {
	status = Nap_HdfPutAttribute(nap_cd, sd_id, sds_name, main_NAO);
	CHECK(status == TCL_OK);
    } else {
	rank32 = rank = main_NAO->rank;
	status = Nap_HdfOpenSDS(nap_cd, sd_id, sds_name, &exists, &sds_id);
	CHECK(status == TCL_OK);
	if (exists) {
	    boxed_cv_hdf = NULL;
	    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, &is_unlimited,
		    &number_type);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
	} else {
	    if (boxed_cv_hdf) {
		if (boxed_cv_hdf->dataType != NAP_BOXED) {
		    tmp_NAO = boxed_cv_hdf;
		    boxed_cv_hdf = Nap_NewNAO(nap_cd, NAP_BOXED, 1, altShape);
		    boxed_cv_hdf->data.Boxed[0] = tmp_NAO->slot;
		    Nap_IncrRefCount(nap_cd, tmp_NAO);
		}
		assert(boxed_cv_hdf->dataType == NAP_BOXED);
		CHECK2(boxed_cv_hdf->rank == 1,
			"m4NAME: Illegal Coordinate variable boxed NAO");
		Nap_IncrRefCount(nap_cd, boxed_cv_hdf);
		rank32 = boxed_cv_hdf->nels;
	    }
	    for (i = 0; i < rank32; i++) {
		tmp_NAO = NULL;
		if (boxed_cv_hdf  &&  (id = boxed_cv_hdf->data.Boxed[i])) {
		    tmp_NAO = Nap_GetNaoFromSlot(id);
		    assert(tmp_NAO);
		    CHECK3(tmp_NAO->rank == 1,
			"m4NAME: Coordinate variable %s has rank other than 1",
			    tmp_NAO->id);
		    shape32[i] = tmp_NAO->nels;
		    if (tmp_NAO->dimName[0]) {
			dimName[i] = tmp_NAO->dimName[0];
		    } else if (rank == rank32) {
			dimName[i] = main_NAO->dimName[i];
		    } else {
			dimName[i] = NULL;
		    }
		} else if (rank == rank32) {
		    shape32[i] = main_NAO->shape[i];
		    tmp_NAO = Nap_GetCoordVar(nap_cd, main_NAO, i);
		    dimName[i] = main_NAO->dimName[i];
		}
		cv_hdf_local[i] = Nap_Promote(nap_cd, tmp_NAO, NAP_I32, 1, altShape);
		Nap_IncrRefCount(nap_cd, cv_hdf_local[i]);
	    }
	    tmp_NAO = Nap_UnboxedElement1(nap_cd, main_NAO);
	    if (!tmp_NAO) {
		return TCL_OK;
	    }
	    dataType = tmp_NAO->dataType;
	    if (sds_dataType == NAP_NULL_TYPE) {
		sds_dataType = dataType;
	    }
	    status = Nap_HdfCreateSDS(nap_cd, sd_id, sds_name, sds_dataType,
		    rank32, shape32, cv_hdf_local, dimName,
		    dataType, scale_factor_NAO, add_offset_NAO,
		    valid_range_NAO, main_NAO, isRecord, &sds_id);
	    CHECK(status == TCL_OK);
	    for (i = 0; i < rank32; i++) {
		Nap_DecrRefCount(nap_cd, cv_hdf_local[i]);
	    }
	}
	if (main_NAO->nels > 0) {
	    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, &is_unlimited,
		    &number_type);
	    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
	    if (is_unlimited  &&  rank == rank32) {	/* has unlimited dim? */
		status = Nap_HdfExtend(nap_cd, sd_id, sds_id, main_NAO);
		CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfExtend");
	    }
	    dataType = Nap_Hdf2NapDataType(number_type);
	    CHECK2(Nap_ValidDataType(dataType), "m4NAME: Illegal datatype");
	    if (!indexObj) {
		indexObj = Tcl_NewStringObj("", 0);
		for (i = 0; i < rank; i++) {
		    tmp_NAO = Nap_GetCoordVar(nap_cd, main_NAO, i);
		    if (tmp_NAO) {
			Tcl_AppendStringsToObj(indexObj, "@@", tmp_NAO->id, (char *) NULL);
		    }
		    if (i < rank-1) {
			Tcl_AppendStringsToObj(indexObj, ",", (char *) NULL);
		    }
		}
	    }
	    assert(indexObj);
	    Tcl_IncrRefCount(indexObj);
	    status = nap_HdfGetIndex(nap_cd, sds_id, indexObj, &subscript_NAO);
	    CHECK2(status == TCL_OK, "m4NAME: Error evaluating index");
	    assert(subscript_NAO);
	    Nap_IncrRefCount(nap_cd, subscript_NAO);
	    assert(subscript_NAO);
	    status = Nap_HdfDefineSubscript(nap_cd, sds_id, main_NAO, 'w',
		    subscript_NAO, subscript_ptr, start32, edge32, shape1, &buffer);
	    CHECK(status == TCL_OK);
	    if (main_NAO->dataType == NAP_RAGGED) {
		status = Nap_HdfPutSubscriptingRagged(nap_cd, sds_id, 0,
			main_NAO, start32, edge32, subscript_ptr, NULL, buffer);
		NAP_FREE(nap_cd, buffer);
		CHECK(status == TCL_OK);
	    } else {
		status = Nap_HdfScaleBeforePut(nap_cd, sds_id, main_NAO, &scaled_NAO);
		CHECK(status == TCL_OK);
                Nap_IncrRefCount(nap_cd, scaled_NAO);
		data_ptr = scaled_NAO->data.c;
		status = Nap_HdfPutSubscripting(nap_cd, sds_id, 0, scaled_NAO, start32, edge32,
			shape1, subscript_ptr, &data_ptr, buffer);
		NAP_FREE(nap_cd, buffer);
		CHECK(status == TCL_OK);
		Nap_DecrRefCount(nap_cd, scaled_NAO);
	    }
	    for (i = 0; i < rank32; i++) {
		NAP_FREE(nap_cd, subscript_ptr[i]);
	    }
	    Tcl_DecrRefCount(indexObj);
	    Nap_DecrRefCount(nap_cd, subscript_NAO);
	    Nap_DecrRefCount(nap_cd, boxed_cv_hdf);
	    status = Nap_HdfCloseSDS(nap_cd, sds_id);
	    CHECK(status == TCL_OK);
	}
    }
    return TCL_OK;
}

/*
 * Nap_HdfGetSubscripting --
 *
 *	Called by Nap_HdfGet to do recursive subscripting.
 */

m4define(`m4NAME', `Nap_HdfGetSubscripting')

static int
Nap_HdfGetSubscripting(
    NapClientData       *nap_cd,
    int32		sds_id,			/* HDF sds ID */
    int			raw,			/* 1 to request raw data */
    Nap_NAO		*main_NAO,		/* pointer to main nao */
    int32		dim_num,		/* current dimension number */
    int32		start32[],		/* HDF subscript */
    int32		edge32[],	     /* HDF edge (all 1 except final) */
    int32		*subscript_ptr[],      /* specified subscript vectors */
    char		**data_ptr,		/* points to next NAO element */
    char		*buffer)		/* For actual read */
{
    size_t		i;
    size_t		j;
    int32		number_type;
    int32		rank32;			/* main_NAO & hdf rank */
    int32		shape32[NAP_MAX_RANK];
    size_t		size = Nap_SizeOf(main_NAO->dataType);
    int			status;

    assert(dim_num >= 0);
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    assert(rank32 == 0	||  dim_num < rank32);
    if (rank32 == 0  ||	 dim_num == rank32-1) {
	if (buffer) {
	    status = Nap_HdfGetSDS(nap_cd, sds_id, raw, buffer, main_NAO->missingValuePtr,
		    start32, edge32);
	    CHECK(status == TCL_OK);
	    for (i = 0; i < main_NAO->shape[dim_num]; i++) {
		j = size * (subscript_ptr[dim_num][i] - start32[dim_num]);
		memcpy(*data_ptr, buffer+j, size);
		*data_ptr += size;
	    }
	} else {
	    status = Nap_HdfGetSDS(nap_cd, sds_id, raw, *data_ptr, main_NAO->missingValuePtr,
		    start32, edge32);
	    CHECK(status == TCL_OK);
	    if (rank32 > 0) {
		*data_ptr += edge32[rank32-1] * size;
	    }
	}
    } else {
	for (i = 0; i < main_NAO->shape[dim_num]; i++) {
	    start32[dim_num] = subscript_ptr[dim_num][i];
	    status = Nap_HdfGetSubscripting(nap_cd, sds_id, raw, main_NAO, dim_num+1,
		    start32, edge32, subscript_ptr, data_ptr, buffer);
	    CHECK(status == TCL_OK);
	}
    }
    return TCL_OK;
}

/*
 * Nap_HdfGet --
 *
 *	Read data from hdf file into existing NAO.
 *	If sds_name contains ':' then treat part after ':' as attribute name.
 *	Also any dim. names & coord. vars.
 */

m4define(`m4NAME', `Nap_HdfGet')

EXTERN int
Nap_HdfGet(
    NapClientData       *nap_cd,
    int32		sd_id,		/* file handle */
    char		*sds_name,	/* HDF sds (var) name */
    Nap_NAO		*subscript_NAO, /* pointer to subscript nao */
    int			raw,		/* 1 to request raw data */
    Nap_NAO		*main_NAO)	/* pointer to main nao (out) */
{
    int32		attr_index;
    char		*buffer;		/* For actual read */
    float64		cal;			/* scale factor */
    int32		count;			/* length of attribute */
    Nap_NAO		*cv_hdf_NAO;		/* cv from hdf file */
    char		*data_ptr;		/* points to next NAO element */
    int32		edge32[NAP_MAX_RANK];
    int			exists;			/* SDS exists? */
    Nap_dataType	externalDataType;	/* HDF type */
    Nap_NAO		*fill_nao;		/* missing value from hdf file */
    int			i;
    Nap_dataType	internalDataType;	/* NAO type */
    char		name[MAX_NC_NAME];
    int32		number_type;
    float64		off;			/* offset */
    int32		rank32;
    int32		sds_id;
    size_t		shape1[NAP_MAX_RANK];	/* shape of main_NAO with additional 1s */
    int32		shape32[NAP_MAX_RANK];	/* shape of hdf sds */
    int			status;
    int32		start32[NAP_MAX_RANK];
    int32		*subscript_ptr[NAP_MAX_RANK];
    float64		valid_range[2];		/* min, max */

    CHECK2(sds_name, "m4NAME: Pointer to SDS name is NULL");
    CHECK2(main_NAO, "m4NAME: Pointer to main NAO is NULL");
    if (main_NAO->nels == 0) {
	return TCL_OK;
    }
    if (strchr(sds_name, ':')) {
	status = Nap_HdfGetAttribute(nap_cd, sd_id, sds_name, main_NAO);
	CHECK(status == TCL_OK);
    } else {
	status = Nap_HdfOpenSDS(nap_cd, sd_id, sds_name, &exists, &sds_id);
	CHECK3(exists, "m4NAME: SDS %s not found", sds_name);
	status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
	CHECK2(rank32 == main_NAO->rank, "m4NAME: HDF rank != NAO rank");
	externalDataType = Nap_Hdf2NapDataType(number_type);
	status = Nap_HdfGetScalingInfo(nap_cd, sds_id, raw, &number_type, &cal, &off, valid_range);
	CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfGetScalingInfo");
	internalDataType = Nap_Hdf2NapDataType(number_type);
	CHECK2(internalDataType == main_NAO->dataType, "m4NAME: HDF dataType != NAO dataType");
	if (internalDataType == externalDataType  &&  cal == 1.0  &&  off == 0.0) {
	    fill_nao = Nap_NewNAO(nap_cd, internalDataType, 0, main_NAO->shape);
	    CHECK2(fill_nao, "m4NAME: Error calling Nap_NewNAO");
	    status = SDgetfillvalue(sds_id, (void *) fill_nao->data.c);
	    if (status == SUCCEED) {
		status = Nap_SetMissing(nap_cd, main_NAO, fill_nao->slot);
		CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_SetMissing");
	    }
	    Nap_FreeNAO(nap_cd, fill_nao);
	}
	attr_index = SDfindattr(sds_id, "C_format");
	if (attr_index >= 0) {
	    status= SDattrinfo(sds_id, attr_index, name, &number_type, &count);
	    CHECK2(status == SUCCEED, "m4NAME: Error calling SDattrinfo");
	    NAP_FREE(nap_cd, main_NAO->format);
	    main_NAO->format = (char *) NAP_ALLOC(nap_cd, count+1);
	    assert(main_NAO->format);
	    status = SDreadattr(sds_id, attr_index, main_NAO->format);
	    main_NAO->format[count] = '\0';
	}
	attr_index = SDfindattr(sds_id, "long_name");
	if (attr_index >= 0) {
	    status= SDattrinfo(sds_id, attr_index, name, &number_type, &count);
	    CHECK2(status == SUCCEED, "m4NAME: Error calling SDattrinfo");
	    NAP_FREE(nap_cd, main_NAO->label);
	    main_NAO->label = (char *) NAP_ALLOC(nap_cd, count+1);
	    assert(main_NAO->label);
	    status = SDreadattr(sds_id, attr_index, main_NAO->label);
	    main_NAO->label[count] = '\0';
	}
	attr_index = SDfindattr(sds_id, "units");
	if (attr_index >= 0) {
	    status= SDattrinfo(sds_id, attr_index, name, &number_type, &count);
	    CHECK2(status == SUCCEED, "m4NAME: Error calling SDattrinfo");
	    NAP_FREE(nap_cd, main_NAO->unit);
	    main_NAO->unit = (char *) NAP_ALLOC(nap_cd, count+1);
	    assert(main_NAO->unit);
	    status = SDreadattr(sds_id, attr_index, main_NAO->unit);
	    main_NAO->unit[count] = '\0';
	}
	if (subscript_NAO) {
	    status = Nap_HdfDefineSubscript(nap_cd, sds_id, main_NAO, 'r',
			subscript_NAO, subscript_ptr, start32, edge32, shape1, &buffer);
	    CHECK(status == TCL_OK);
	    data_ptr = main_NAO->data.c;
	    status = Nap_HdfGetSubscripting(nap_cd, sds_id, raw, main_NAO, 0,
		    start32, edge32, subscript_ptr, &data_ptr, buffer);
	    NAP_FREE(nap_cd, buffer);
	    CHECK(status == TCL_OK);
	    for (i = 0; i < rank32; i++) {
		NAP_FREE(nap_cd, subscript_ptr[i]);
	    }
	} else {
	    for (i = 0; i < rank32; i++) {
		start32[i] = 0;
		edge32[i]  = shape32[i];
	    }
	    status = Nap_HdfGetSDS(nap_cd, sds_id, raw, main_NAO->data.c, main_NAO->missingValuePtr,
		    start32, edge32);
	    CHECK(status == TCL_OK);
	    if (! SDiscoordvar(sds_id)) {
		for (i = 0; i < rank32; i++) {
		    status = Nap_HdfGetDim(nap_cd, sds_id, i, &cv_hdf_NAO, name);
		    CHECK(status == TCL_OK);
		    status = Nap_AttachCoordVar(nap_cd, main_NAO, cv_hdf_NAO, name, i);
		    CHECK(status == TCL_OK);
		}
	    }
	}
	status = Nap_HdfCloseSDS(nap_cd, sds_id);
	CHECK(status == TCL_OK);
    }
    return TCL_OK;
}

/*
 * Nap_HdfInfo --
 *
 *	Get shape & datatype corresponding to sds in hdf file.
 *	If data is scaled (i.e. calibrated) then this datatype is that of
 *	uncalibrated (internal) data, not sds (external) data.
 *	If sds_name contains ':' then treat part after ':' as attribute name.
 */

m4define(`m4NAME', `Nap_HdfInfo')

EXTERN int
Nap_HdfInfo(
    NapClientData       *nap_cd,
    char		*fileName,		/* HDF file name */
    char		*sds_name,		/* HDF sds (var) name */
    int                 raw,			/* 1 to request raw data */
    int			*rank,			/* rank of sds (out) */
    size_t		shape[NAP_MAX_RANK],	/* shape of sds (out) */
    Nap_dataType	*externalDataType,	/* datatype of sds (out) */
    Nap_dataType	*internalDataType)	/* datatype of NAO (out) */

{
    int32		attr_index;
    float64		cal;
    int			exists;			/* SDS exists? */
    int			i;
    char		name[MAX_NC_NAME];
    char		*name_att;		/* name of attribute */
    char		name_sds[2*MAX_NC_NAME+2]; /* with space for name_att */
    int32		number_type;
    float64		off;
    int32		rank32;
    int32		sd_id;
    int32		sds_id;			/* sds ID */
    int32		shape32[NAP_MAX_RANK];
    int			status;
    float64		valid_range[2];		/* min, max */

    CHECK2(fileName, "m4NAME: Pointer to file name is NULL");
    CHECK2(sds_name, "m4NAME: Pointer to SDS name is NULL");
    CHECK2(strlen(sds_name) <= 2*MAX_NC_NAME+1, "m4NAME: sds_name is too long");
    (void) strcpy(name_sds, sds_name);
    name_att = strchr(name_sds, ':');
    if (name_att) {
	*name_att = '\0';
	++name_att;
    } else {
	name_att = "";
    }
    status = Nap_HdfOpenFile(nap_cd, fileName, 'r', &sd_id);
    CHECK(status == TCL_OK);
    if (strlen(name_sds) > 0) {
	status = Nap_HdfOpenSDS(nap_cd, sd_id, name_sds, &exists, &sds_id);
	if (!exists) {
	    status = Nap_HdfCloseSDS(nap_cd, sds_id);
	    CHECK3(0, "m4NAME: SDS %s not found", name_sds);
	}
    } else {
	sds_id = sd_id;
    }
    if (strlen(name_att) > 0) {
	attr_index = SDfindattr(sds_id, name_att);
	if (attr_index < 0) {
	    status = Nap_HdfCloseSDS(nap_cd, sds_id);
	    CHECK2(0, "m4NAME: Error calling SDfindattr");
	}
	status= SDattrinfo(sds_id, attr_index, name, &number_type, shape32);
	if (status != SUCCEED) {
	    status = Nap_HdfCloseSDS(nap_cd, sds_id);
	    CHECK2(0, "m4NAME: Error calling SDattrinfo");
	}
	*internalDataType = *externalDataType = Nap_Hdf2NapDataType(number_type);
	rank32 = shape32[0] != 1;
    } else {
	status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
	if (status != TCL_OK) {
	    status = Nap_HdfCloseSDS(nap_cd, sds_id);
	    CHECK2(0, "m4NAME: Error calling Nap_HdfSdsGetInfo");
	}
	*externalDataType = Nap_Hdf2NapDataType(number_type);
	status = Nap_HdfGetScalingInfo(nap_cd, sds_id, raw, &number_type, &cal,
		&off, valid_range);
	if (status != TCL_OK) {
	    status = Nap_HdfCloseSDS(nap_cd, sds_id);
	    CHECK2(0, "m4NAME: Error calling Nap_HdfGetScalingInfo");
	}
	*internalDataType = Nap_Hdf2NapDataType(number_type);
	status = Nap_HdfCloseSDS(nap_cd, sds_id);
	CHECK(status == TCL_OK);
    }
    CHECK2(Nap_ValidDataType(*externalDataType), "m4NAME: Illegal datatype");
    CHECK2(Nap_ValidDataType(*internalDataType), "m4NAME: Illegal datatype");
    assert(rank32 <= NAP_MAX_RANK);
    *rank = rank32;
    for (i = 0; i < rank32; i++) {
	shape[i] = shape32[i];
    }
    status = Nap_HdfCloseFile(nap_cd, sd_id);
    CHECK(status == TCL_OK);
    return TCL_OK;
}

/*
 * Nap_HdfList --
 *
 *	Define tcl result as list of names of SDSs & attributes in hdf file.
 *	Use regular expression to filter these.
 */

m4define(`m4NAME', `Nap_HdfList')

EXTERN int
Nap_HdfList(
    NapClientData       *nap_cd,
    char		*fileName,		/* HDF file name */
    char		*reg_exp)		/* regular expression */
{
    int32		count;
    Tcl_RegExp		cre;		/* compiled regular expression */
    int32		data_type;
    int32		i_att;			/* index of attribute */
    int32		i_sds;			/* index of SDS */
    size_t		len;
    int32		n_sds;			/* number SDSs in file */
    char		name[2*MAX_NC_NAME];	/* SDS:ATT */
    Tcl_Obj		*nameObj;		/* name as tcl object */
    int32		natts;			/* number attributes */
    Tcl_Obj		*reObj;			/* regular expression object */
    int32		sd_id;
    int32		sds_id;
    int32		shape32[NAP_MAX_RANK];
    int32		rank32;
    int			status;

    CHECK2(fileName, "m4NAME: Pointer to file name is NULL");
    CHECK2(reg_exp, "m4NAME: Pointer to regular expression is NULL");
    status = Nap_HdfOpenFile(nap_cd, fileName, 'r', &sd_id);
    CHECK(status == TCL_OK);
    status = SDfileinfo(sd_id, &n_sds, &natts);
    CHECK2(status == SUCCEED, "m4NAME: Error calling SDfileinfo");
    reObj = Tcl_NewStringObj(reg_exp, -1);
    CHECK(reObj);
    Tcl_IncrRefCount(reObj);
    cre = Tcl_GetRegExpFromObj(nap_cd->interp, reObj, TCL_REG_ADVANCED | TCL_REG_NOSUB);
    CHECK(cre);
    name[0] = ':';
    for (i_att = 0; i_att < natts; i_att++) {
	status= SDattrinfo(sd_id, i_att, name+1, &data_type, &count);
	CHECK2(status == SUCCEED, "m4NAME: Error calling SDattrinfo");
	nameObj = Tcl_NewStringObj(name, -1);
	CHECK(nameObj);
	Tcl_IncrRefCount(nameObj);
	status = Tcl_RegExpExecObj(nap_cd->interp, cre, nameObj, 0, 0, 0);
	Tcl_DecrRefCount(nameObj);
	CHECK2(status == 0  ||	status == 1,
		"m4NAME: Error calling Tcl_RegExpExecObj");
	if (status == 1) {
	    status = Nap_AppendLines(nap_cd, name);
	    CHECK(status == TCL_OK);
	}
    }
    for (i_sds = 0; i_sds < n_sds; i_sds++) {
	sds_id = SDselect(sd_id, i_sds);
	status= SDgetinfo(sds_id, name, &rank32, shape32, &data_type, &natts);
	CHECK2(status == SUCCEED, "m4NAME: Error calling SDgetinfo");
	nameObj = Tcl_NewStringObj(name, -1);
	CHECK(nameObj);
	Tcl_IncrRefCount(nameObj);
	status = Tcl_RegExpExecObj(nap_cd->interp, cre, nameObj, 0, 0, 0);
	Tcl_DecrRefCount(nameObj);
	CHECK2(status == 0  ||	status == 1,
		"m4NAME: Error calling Tcl_RegExpExecObj");
	if (status == 1) {
	    status = Nap_AppendLines(nap_cd, name);
	    CHECK(status == TCL_OK);
	}
	len = strlen(name);
	name[len] = ':';
	for (i_att = 0; i_att < natts; i_att++) {
	    status= SDattrinfo(sds_id, i_att, name+len+1, &data_type, &count);
	    CHECK2(status == SUCCEED, "m4NAME: Error calling SDattrinfo");
	    nameObj = Tcl_NewStringObj(name, -1);
	    CHECK(nameObj);
	    Tcl_IncrRefCount(nameObj);
	    status = Tcl_RegExpExecObj(nap_cd->interp, cre, nameObj, 0, 0, 0);
	    Tcl_DecrRefCount(nameObj);
	    CHECK2(status == 0	||  status == 1,
		    "m4NAME: Error calling Tcl_RegExpExecObj");
	    if (status == 1) {
		status = Nap_AppendLines(nap_cd, name);
		CHECK(status == TCL_OK);
	    }
	}
	status = Nap_HdfCloseSDS(nap_cd, sds_id);
	CHECK(status == TCL_OK);
    }
    status = Nap_HdfCloseFile(nap_cd, sd_id);
    CHECK(status == TCL_OK);
    Tcl_DecrRefCount(reObj);
    return TCL_OK;
}


/*
 * Nap_HdfDimNames --
 *
 *	Define tcl result as list of dimension names of specified SDS in specified file.
 */

m4define(`m4NAME', `Nap_HdfDimNames')

EXTERN int
Nap_HdfDimNames(
    NapClientData       *nap_cd,
    char		*fileName,		/* HDF file name */
    char		*name_sds)		/* HDF sds (var) name */
{
    int			dim_index;
    char		dim_name[MAX_NC_NAME];
    int			exists;			/* SDS exists? */
    int32		number_type;
    int32		rank32;
    int32		sd_id;
    int32		sds_id;
    int32		shape32[NAP_MAX_RANK];
    int			status;

    assert(fileName);
    assert(name_sds);
    assert(dim_name);
    status = Nap_HdfOpenFile(nap_cd, fileName, 'r', &sd_id);
    CHECK(status == TCL_OK);
    status = Nap_HdfOpenSDS(nap_cd, sd_id, name_sds, &exists, &sds_id);
    CHECK(status == SUCCEED);
    CHECK2(exists, "m4NAME: SDS does not exist");
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    for (dim_index = 0; dim_index < rank32; dim_index++) {
	status = Nap_HdfGetDim(nap_cd, sds_id, dim_index, NULL, dim_name);
	CHECK(status == TCL_OK);
	status = Nap_AppendListElement(nap_cd, dim_name);
	CHECK(status == 0);
    }
    status = Nap_HdfCloseSDS(nap_cd, sds_id);
    CHECK(status == TCL_OK);
    status = Nap_HdfCloseFile(nap_cd, sd_id);
    CHECK(status == TCL_OK);
    return TCL_OK;
}


/*
 * Nap_HdfCoordVar --
 *
 *	Define tcl result as ID of new NAO containing coordinate-variable of specified dimension
 *	of specified SDS in specified file.  Dimension is specified by string which can contain
 *	either dimension-name or dimension-number (0 ... (rank-1)).  If dimension has no
 *	coordinate-variable, then the result is blank.
 */

m4define(`m4NAME', `Nap_HdfCoordVar')

EXTERN int
Nap_HdfCoordVar(
    NapClientData       *nap_cd,
    char		*fileName,		/* HDF file name */
    char		*name_sds,		/* HDF sds (var) name */
    char		*dim_str)		/* dimension name or number */
{
    Nap_NAO		*cv_nao;		/* cv from hdf file */
    int			dim_index;
    char		dim_name[MAX_NC_NAME];
    int			exists;			/* SDS exists? */
    int32		number_type;
    int32		rank32;
    int32		sd_id;
    int32		sds_id;
    int32		shape32[NAP_MAX_RANK];
    int			status;

    assert(fileName);
    assert(name_sds);
    assert(dim_str);
    assert(dim_name);
    status = Nap_HdfOpenFile(nap_cd, fileName, 'r', &sd_id);
    CHECK(status == TCL_OK);
    status = Nap_HdfOpenSDS(nap_cd, sd_id, name_sds, &exists, &sds_id);
    CHECK(status == SUCCEED);
    CHECK2(exists, "m4NAME: SDS does not exist");
    status = Nap_HdfSdsGetInfo(nap_cd, sds_id, &rank32, shape32, NULL, &number_type);
    CHECK2(status == TCL_OK, "m4NAME: Error calling Nap_HdfSdsGetInfo");
    CHECK2(rank32 > 0, "m4NAME: SDS is scalar");
    status = Tcl_GetInt(nap_cd->interp, dim_str, &dim_index);
    if (status == TCL_OK) {
	dim_index = Nap_mod(dim_index, rank32);
    } else {
	status = 1;
	for (dim_index = 0; dim_index < rank32  &&  status != 0; dim_index++) {
	    status = Nap_HdfGetDim(nap_cd, sds_id, dim_index, NULL, dim_name);
	    CHECK(status == TCL_OK);
	    status = strcmp(dim_str, dim_name);
	}
	--dim_index;
	CHECK3(dim_index < rank32, "m4NAME: Unable to find dimension named '%s'", dim_str);
    }
    status = Nap_HdfGetDim(nap_cd, sds_id, dim_index, &cv_nao, NULL);
    CHECK(status == TCL_OK);
    status = Nap_HdfCloseSDS(nap_cd, sds_id);
    CHECK(status == TCL_OK);
    status = Nap_HdfCloseFile(nap_cd, sd_id);
    CHECK(status == TCL_OK);
    if (cv_nao) {
	status = Nap_AppendLines(nap_cd, cv_nao->id);
    } else {
	status = Nap_AppendLines(nap_cd, "");
    }
    CHECK(status == 0);
    return TCL_OK;
}


/*
 * Nap_OOC_hdf --
 *
 * Object-oriented sub-command 'hdf'.
 *
 *	<ID> hdf ?<SWITCHES>? <FILE> <SDS>
 *	    HDF: Write to sds named <SDS> within HDF file named <FILE>.
 *
 *	?<SWITCHES>? can be anywhere e.g. following are equivalent:
 *	nao.9-9 hdf -d i16 a.hdf x
 *	nao.9-9 hdf -d i16 a.hdf x
 *	nao.9-9 hdf a.hdf -d i16 x
 */

m4define(`m4NAME', `Nap_OOC_hdf')

EXTERN int 
Nap_OOC_hdf(
    NapClientData       *nap_cd,
    int                 objc,
    Tcl_Obj *CONST      objv[],
    Nap_NAO		*naoPtr)
{
    Nap_NAO		*add_offset_NAO = NULL;		/* For new HDF SDS */
    Nap_NAO             *boxed_cv_hdf = NULL;		/* pointers to CVs */
    Nap_dataType	dataType = NAP_NULL_TYPE;
    char                *file_name = NULL;
    int			i;
    int			index;
    Tcl_Obj		*indexObj = NULL;		/* index */
    int			isRecord = 0;			/* Want unlimited dim in new sds? */
    Nap_NAO		*scale_factor_NAO = NULL;	/* For new HDF SDS */
    int32		sd_id;				/* File handle */
    char                *sds_name = NULL;
    int			status;
    int			status_close;			/* Indicates whether file closed OK */
    int			status_open;			/* Indicates whether file opened OK */
    char		*str;
    Nap_NAO		*valid_range_NAO = NULL;	/* For new HDF SDS */

    CONST char		*switches[] = {
				"-coordinateVariable",
				"-datatype",
				"-index",
				"-offset",
				"-range",
				"-scale",
				"-subscript",
				"-unlimited",
				(char *) NULL};

    CHECK2(objc >= 4, "m4NAME: wrong # arguments");
    for (i = 2; i < objc; i++) {
	status = Tcl_GetIndexFromObj(nap_cd->interp, objv[i], switches,
				"switch", 0, &index);
	if (status == TCL_OK) {
	    switch (index) {
		case 0:			/* -coordinateVariable */
		    boxed_cv_hdf = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, boxed_cv_hdf);
		    break;
		case 1:			/* -datatype */
		    str = Tcl_GetStringFromObj(objv[++i], NULL);
		    dataType = Nap_TextToDataType(str);
		    break;
		case 2:			/* -index */
		    indexObj = objv[++i];
		    break;
		case 3:			/* -offset */
		    add_offset_NAO = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, add_offset_NAO);
		    break;
		case 4:			/* -range */
		    valid_range_NAO = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, valid_range_NAO);
		    break;
		case 5:			/* -scale */
		    scale_factor_NAO = Nap_GetNaoFromObj(nap_cd, objv[++i]);
		    Nap_IncrRefCount(nap_cd, scale_factor_NAO);
		    break;
		case 6:			/* -subscript (old name for -index) */
		    indexObj = objv[++i];
		    break;
		case 7:			/* -unlimited */
		    isRecord = 1;
		    break;
		default:
		    assert(FALSE);
	    }
	} else if (!file_name) {
	    file_name = Tcl_GetStringFromObj(objv[i], NULL);
	} else if (!sds_name) {
	    sds_name  = Tcl_GetStringFromObj(objv[i], NULL);
	} else {
	    CHECK(FALSE);
	}
	Tcl_ResetResult(nap_cd->interp); /* Delete any message from Tcl_GetIndexFromObj */
    }
    CHECK2(file_name, "m4NAME: Filename not specified");
    CHECK2(sds_name, "m4NAME: sds_name not specified");
    status_open = Nap_HdfOpenFile(nap_cd, file_name, 'w', &sd_id);
    if (status_open == TCL_OK) {
	status = Nap_HdfPut(nap_cd, sd_id, sds_name, dataType, scale_factor_NAO,
		add_offset_NAO, valid_range_NAO, naoPtr, boxed_cv_hdf,
		indexObj, isRecord); 
	status_close = Nap_HdfCloseFile(nap_cd, sd_id);
    }
    Nap_DecrRefCount(nap_cd, scale_factor_NAO);
    Nap_DecrRefCount(nap_cd, add_offset_NAO);
    Nap_DecrRefCount(nap_cd, valid_range_NAO);
    Nap_DecrRefCount(nap_cd, boxed_cv_hdf);
    CHECK3(status_open  == TCL_OK, "m4NAME: Unable to open file %s", file_name);
    CHECK3(status_close == TCL_OK, "m4NAME: Unable to close file %s", file_name);
    CHECK3(status       == TCL_OK, "m4NAME: Error writing file %s", file_name);
    return TCL_OK;
}
