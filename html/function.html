<!-- $Id: function.html,v 1.1 2002/08/07 08:09:24 dav480 Exp $ -->
<html>

<head> <title>
NAP Built-in Functions
</title> </head>

<body>

<h2> <center>
Built-in Functions
</center> </h2>

<h3>Elemental Functions</h3>

<p>
The result of an elemental function has the same shape as its argument(s).
Each element of the result is defined by applying the function to the corresponding
element of the argument.

<p>
The following table is very similar to <b>Table 5.3</b> in Ousterhout's
1994 classic <cite>Tcl and the Tk Toolkit</cite>:

<p>
<table border rules=groups>
    <colgroup span=1> <colgroup span=1>

  <tr>
    <th align=center>Function
    <th align=center>Result

<tbody>
  <tr valign=bottom> <td>
	<code>abs(</code><var>x</var><code>)</code>
  <td>
	Absolute value of <var>x</var>

  <tr valign=bottom> <td>
	<code>acos(</code><var>x</var><code>)</code>
  <td>
	Arc cosine of <var>x</var>, in the range 0 to &pi;

  <tr valign=bottom> <td>
	<code>asin(</code><var>x</var><code>)</code>
  <td>
	Arc sine of <var>x</var>, in the range -&pi;/2 to &pi;/2

  <tr valign=bottom> <td>
	<code>atan(</code><var>x</var><code>)</code>
  <td>
	Arc tangent of <var>x</var>, in the range -&pi;/2 to &pi;/2

  <tr valign=bottom> <td>
	<code>atan(</code><var>y</var><code>,</code><var>x</var><code>)</code>
  <td>
	Arc tangent of <var>y</var>/<var>x</var>, in the range
	    -&pi; to &pi;

  <tr valign=bottom> <td>
	<code>atan2(</code><var>y</var><code>,</code><var>x</var><code>)</code>
  <td>
	Alias for <code>atan</code>

  <tr valign=bottom> <td>
	<code>ceil(</code><var>x</var><code>)</code>
  <td>
	Smallest integer not less than <var>x</var>

  <tr valign=bottom> <td>
	<code>cos(</code><var>x</var><code>)</code>
  <td>
	Cosine of <var>x</var> (<var>x</var> in radians)

  <tr valign=bottom> <td>
	<code>cosh(</code><var>x</var><code>)</code>
  <td>
	Hyperbolic cosine of <var>x</var>

  <tr valign=bottom> <td>
	<code>exp(</code><var>x</var><code>)</code>
  <td>
	<var>e</var><sup><var>x</var></sup>,
	where <var>e</var> is base of natural logarithms

  <tr valign=bottom> <td>
	<code>floor(</code><var>x</var><code>)</code>
  <td>
	Largest integer not greater than <var>x</var>

  <tr valign=bottom> <td>
	<code>fmod(</code><var>x</var><code>,</code><var>y</var><code>)</code>
  <td>
	<var>x</var><code>%</code><var>y</var>

  <tr valign=bottom> <td>
	<code>isnan(</code><var>x</var><code>)</code>
  <td>
	1 if <var>x</var> is NaN, 0 otherwise

  <tr valign=top> <td>
	<code>log(</code><var>x</var><code>)</code>
  <td>
        log<sub><var>e</var></sub><var>x</var>
	(natural logarithm of <var>x</var>)

  <tr valign=top> <td>
	<code>log(</code><var>x</var>,<var>y</var><code>)</code>
  <td>
        log<sub><var>y</var></sub><var>x</var>

  <tr valign=top> <td>
	<code>log10(</code><var>x</var><code>)</code>
  <td>
        log<sub>10</sub><var>x</var>

  <tr valign=bottom> <td>
	<code>hypot(</code><var>x</var><code>,</code><var>y</var><code>)</code>
  <td>
	&radic;(<var>x</var><sup>2</sup>+<var>y</var><sup>2</sup>)

  <tr valign=bottom> <td>
	<code>nint(</code><var>x</var><code>)</code>
  <td>
	Nearest integer to <var>x</var>

  <tr valign=bottom> <td>
	<code>pow(</code><var>x</var><code>,</code><var>y</var><code>)</code>
  <td>
	<var>x</var><sup><var>y</var></sup>

  <tr valign=bottom> <td>
	<code>random(</code><var>x</var><code>)</code>
  <td>
	<code>f32</code> or <code>f64</code> random number <var>r</var> such that
	    <code>0</code> &le; <var>r</var> &lt; <var>x</var>

  <tr valign=bottom> <td>
	<code>round(</code><var>x</var><code>)</code>
  <td>
	Alias for <code>nint</code>

  <tr valign=bottom> <td>
	<code>sign(</code><var>x</var><code>)</code>
  <td>
	Sign of <var>x</var>, &nbsp; i.e.
	<code>(</code><var>x</var>&gt;<code>0)-(</code><var>x</var>&lt;<code>0)</code>

  <tr valign=bottom> <td>
	<code>sin(</code><var>x</var><code>)</code>
  <td>
	Sine of <var>x</var> (<var>x</var> in radians)

  <tr valign=bottom> <td>
	<code>sqrt(</code><var>x</var><code>)</code>
  <td>
	&radic;<var>x</var>

  <tr valign=bottom> <td>
	<code>sinh(</code><var>x</var><code>)</code>
  <td>
	Hyperbolic sine of <var>x</var>

  <tr valign=bottom> <td>
	<code>tan(</code><var>x</var><code>)</code>
  <td>
	Tangent of <var>x</var> (<var>x</var> in radians)

  <tr valign=bottom> <td>
	<code>tanh(</code><var>x</var><code>)</code>
  <td>
	Hyperbolic tangent of <var>x</var>

</table>

<p>
The following data-type conversion functions are also elemental:
<br>
<code>c8(</code><var>x</var><code>)</code><br>
<code>f32(</code><var>x</var><code>)</code><br>
<code>f64(</code><var>x</var><code>)</code><br>
<code>i8(</code><var>x</var><code>)</code><br>
<code>i16(</code><var>x</var><code>)</code><br>
<code>i32(</code><var>x</var><code>)</code><br>
<code>u8(</code><var>x</var><code>)</code><br>
<code>u16(</code><var>x</var><code>)</code><br>
<code>u32(</code><var>x</var><code>)</code><br>
Here are some examples of their use:
<pre>
% [nap "f32(97 .. 102)"] all; # convert from i32 to f32
::NAP::43-43  f32  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 6      Name: (NULL)    Coordinate-variable: (NULL)
Value:
97 98 99 100 101 102
% [nap "u8('abcdef')"]; # Display ASCII codes for 'abcdef'
97 98 99 100 101 102
% [nap "c8(97 .. 102)"]; # Reverse this process
abcdef
</pre>

<h3>Reduction and Scan Functions</h3>

<p>
A <em>reduction</em> or <em>insert</em> function is one which has the effect of
inserting a binary operator between the <em>cells</em> of its argument.
If the argument is a vector then its elements are the cells and the result is a scalar.
If the argument is a matrix then its rows are the cells and the result is a vector
containing the sum of each column.
Such functions are termed <em>reductions</em> because the result has a rank which is one
less than the argument.

<p>
A classic example is the &sum; summation operation, which corresponds to
the NAP function <code>sum</code>.  
This can be used as follows to produce a scalar (rank 0) result by summing
a vector (rank 1):
<pre>
% [nap "sum({0.5 2 -1 8})"]
9.5
</pre>

This function <code>sum</code> can be applied to a matrix (rank 2) to produce
a vector (rank 1). If the second argument is omitted then we get the sum
of each column.  If it is 1 we get the sum of each row. This is shown by:
<pre>
% nap "mat = {
{2 5 0}
{6 7 1}
}"
::NAP::49-49
% [nap "sum mat"]
8 12 1
% [nap "sum(mat,1)"]
7 14
</pre>

<p>
The NAP reduction and scan functions are listed in the following table:

<p>
<table border rules=groups>
    <colgroup span=1>
    <colgroup span=1>
    <colgroup span=1>

  <tr>
    <th align=center>Function
    <th align=center>Type
    <th align=center>Result

<tbody>
  <tr valign=top> <td>
    <code>count(</code><var>x</var>[<code>,</code><var>r</var>]<code>)</code>
  <td> reduction <td>
    Number of non-missing elements in rank-<var>r</var>
	 sub-arrays of <var>x</var>
  <td>

  <tr valign=top> <td>
    <code>max(</code><var>x</var>[<code>,</code><var>r</var>]<code>)</code>
  <td> reduction <td>
    Maximum of rank-<var>r</var>
	 sub-arrays of <var>x</var>

  <tr valign=top> <td>
    <code>min(</code><var>x</var>[<code>,</code><var>r</var>]<code>)</code>
  <td> reduction <td>
    Minimum of rank-<var>r</var>
	 sub-arrays of <var>x</var>

  <tr valign=top> <td>
    <code>prod(</code><var>x</var>[<code>,</code><var>r</var>]<code>)</code>
  <td> reduction <td>
    Product of rank-<var>r</var>
	 sub-arrays of <var>x</var>

  <tr valign=top> <td>
    <code>psum(</code><var>x</var><code>)</code>
  <td> scan <td>
    Partial sums of <var>x</var> (see below)

  <tr valign=top> <td>
    <code>sum(</code><var>x</var>[<code>,</code><var>r</var>]<code>)</code>
  <td> reduction <td>
    Sum of rank-<var>r</var>
	 sub-arrays of <var>x</var>

    </td>
</table>

<p>
The optional second argument of reduction functions is called the <em>verb-rank</em> (as in J).
It specifies the rank of the sub-arrays (cells) to which the process
is applied.
In the above example the verb-rank was 1, so the matrix was split into
vectors (corresponding to each row) before doing the summation.
This final summation process is always done by summing along the first
(most significant) dimension.

<p>
It is possible to specify a verb-rank of 0.
This is useful with <code>count()</code> because each (rank 0) element is
processed separately.
If it is missing the result is 0, otherwise it is 1.
So this gives us an elemental function for testing whether values are missing.
Note that the rank does not change in this case!
E.g.

<pre>
% [nap "count({4 _ 2 -9}, 0)"]
1 0 1 1
</pre>

The result of <code>psum(</code><var>x</var><code>)</code>
has the same shape as
<var>x</var>.
If <var>x</var> is a vector and <var>r</var>
is the result (with the same shape) then each element of 
<var>r</var> is defined by
<br>

<table>
    <tr align=center>
	<td>
	<td> 
	    <var>I</var>
    </tr>
    <tr align=center>
	<td>
	    <var>r</var> <sub><var>I</var></sub> =
	<td>
	    &sum;
	<td>
	    <var>x</var> <sub><var>i</var></sub>
    </tr>
    <tr align=center>
	<td>
	<td>
	    <var>i=0
    </tr>
</table>

If <var>x</var> is a matrix and <var>r</var>
is the result (with the same shape) then each element of 
<var>r</var> is defined by
<br>

<table>
    <tr align=center>
	<td>
	<td> 
	    <var>I</var>
	<td> 
	    <var>J</var>
    </tr>
    <tr align=center>
	<td>
	    <var>r</var> <sub><var>IJ</var></sub> =
	<td>
	    &sum;
	<td>
	    &sum;
	<td>
	    <var>x</var> <sub><var>ij</var></sub>
    </tr>
    <tr align=center>
	<td>
	<td>
	    <var>i=0
	<td>
	    <var>j=0
    </tr>
</table>

<p>
The following example shows how
partial sums can be used to calculate a 3-point moving-average in an
efficient manner:

<pre>
% nap "x = {2 7 1 3 8 2 5 0 2 5}"
::NAP::136-136
% nap "ps = 0 // psum(x)"
::NAP::141-141
% $ps all -col -1
::NAP::141-141  i32  MissingValue: -2147483648  References: 1  Unit: (NULL)
Dimension 0   Size: 11     Name: (NULL)    Coordinate-variable: (NULL)
Value:
0 2 9 10 13 21 23 28 28 30 35
% [nap "(ps(3 .. 10) - ps(0 .. 7)) / 3.0"] value
3.33333 3.66667 4 4.33333 5 2.33333 2.33333 2.33333
</pre>
Can you allow for missing values?
How about averages of a moving window in 2 dimensions?

<p>
Other similar <em>scan</em> functions can be defined for partial products and so on.
However NAP currently has only <code>psum</code>.

<h3>Metadata Functions</h3>

Metadata functions return information (other than data values) from a NAO.
The same information can be obtained using an OOC, but these functions are
more convenient within expressions.

<p>
<table border rules=groups>
    <colgroup span=1> <colgroup span=1>

  <tr>
    <th align=center>Function
    <th align=center>Result

<tbody>
  <tr> <td> 
	<code>coordinate_variable(</code><var>x</var>[<var>d</var>]<code>)</code>
  <td>
	Coordinate variable of dimension <var>d</var> (default 0)

  </tr> <tr> <td> 
	<code>label(</code><var>x</var><code>)</code>
  <td>
	Descriptive title

  </tr> <tr> <td> 
	<code>missing_value(</code><var>x</var><code>)</code>
  <td>
	Value indicating null or undefined data

  </tr> <tr> <td> 
	<code>nels(</code><var>x</var><code>)</code>
  <td>
	Number of elements <code>= prod(</code><var>shape</var><code>)</code>

  </tr> <tr> <td> 
	<code>rank(</code><var>x</var><code>)</code>
  <td>
	Number of dimensions <code>= nels(</code><var>shape</var><code>)</code>

  </tr> <tr> <td> 
	<code>shape(</code><var>x</var><code>)</code>
  <td>
	Vector of dimension sizes

    </td>
</table>

<h3>Functions which change shape or order</h3>

<p>
<table border rules=groups>
    <colgroup span=1> <colgroup span=1>

  <tr>
    <th align=center>Function
    <th align=center>Result

<tbody>
  <tr> <td> 
	<code>sort(</code><var>x</var><code>)</code>
  <td>
	Sort <var>x</var> into ascending order

  </tr> <tr> <td> 
	<code>reshape(</code><var>x</var><code>)</code>
  <td>
	Spread the elements of <var>x</var> into a vector
	with shape <code>nels(</code><var>x</var><code>)</code>

  <tr> <td> 
	<code>reshape(</code><var>x</var>,<var>s</var><code>)</code>
  <td>
	Reshape the elements of <var>x</var> into an array
	with shape <var>s</var>

  </tr> <tr> <td> 
	<code>transpose(</code><var>x</var><code>)</code>
  <td>
	Reverse the order of dimensions of <var>x</var>

  </tr> <tr> <td> 
	<code>transpose(</code><var>x</var>,<var>p</var><code>)</code>
  <td>
	Permute the dimensions of <var>x</var>
	    to the order specified by <var>p</var>

    </td>
</table>

<p>
Here are some examples of the use of these functions:
<pre>
% [nap "sort {6.3 0.5 9 -2.1 0}"]
-2.1 0 0.5 6.3 9
% [nap "reshape {{1 3 7}{0 9 2}}"] all
::NAP::217-217  i32  MissingValue: -2147483648  References: 0  Unit: (NULL)
Dimension 0   Size: 6      Name: (NULL)    Coordinate-variable: (NULL)
Value:
1 3 7 0 9 2
% [nap "reshape({6.3 0.5 9 -2.1 0}, {2 4})"] all
::NAP::224-224  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 4      Name: (NULL)    Coordinate-variable: (NULL)
Value:
 6.3  0.5  9.0 -2.1
 0.0  6.3  0.5  9.0
% [nap "transpose {{1 3 7}{0 9 2}}"] all
::NAP::228-228  i32  MissingValue: -2147483648  References: 0  Unit: (NULL)
Dimension 0   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Value:
1 0
3 9
7 2
</pre>
<h3>Linear-algebra Functions</h3>

<p>
The function 
<code>solve_linear(</code><var>A</var>[,<var>B</var>])</code>
solves a system 
of linear equations defined by matrix <var>A</var> and right-hand-sides 
<var>B</var>.
<var>B</var> 
can be either a vector or a matrix (representing multiple right-hand sides). If 
<var>B</var> is omitted then the result is the matrix inverse. 

<p>
If the system is <em>over-determined</em> (more equations than unknowns)
then the result is the solution of the <em>linear least-squares problem</em>.
This solution
minimizes the sum of the squares of the differences between the left and right-hand sides.

<p>
The following system of linear equations is solved by the following example:<br>
&nbsp;
3<var>x</var> &minus; 4<var>y</var> = 20<br>
&minus;5<var>x</var> + 8<var>y</var> = &minus;36

<pre>
% nap "A = {
{3 -4}
{-5 8}
}"
::NAP::14-14
% nap "B = {20 -36}"
::NAP::17-17
% nap "x = solve_linear(A, B)"
::NAP::20-20
% $x a
::NAP::20-20  f64  MissingValue: NaN  References: 1  Unit: (NULL)
Dimension 0   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Value:
4 -2
</pre>

<p>
We can check the result using matrix multiplication:
<pre>
% [nap "A +* x"]
20 -36
</pre>

<h3>Correlation</h3>

<p>
Function <code>correlation</code> calculates Pearson product-moment correlations 
(omitting cases where either value is missing).
If
<var>x</var>
or
<var>y</var>
is <code>f64</code>
then the result is 
<code>f64</code>, else it is 
<code>f32</code>.
(But calculation is still done using <code>f64</code>.)
Dimension 0 of the result has size 2.
Index 0 of this dimension corresponds to the correlation values themselves, while index 1
corresponds to the sample sizes (number of non-missing data elements)
used to calculate these values .

<p>
Usage:
<br>
<code>correlation(</code><var>x</var>[, <var>y</var>,
[<var>lag</var><sub>0</sub>,
<var>lag</var><sub>1</sub>,
&hellip; ]]<code>)</code>

<p>
If the only argument is
<var>x</var>,
then it must be a matrix.
Let <var>nc</var> be the number of columns in this matrix data argument.
In this case the result has the shape 2 
by <var>nc</var>
by <var>nc</var>.
Layer 0 contains the correlation matrix.
Element
<var>r</var><sub><var>ij</var></sub>
of this matrix is the correlation between columns 
<var>i</var> and <var>j</var> of matrix
<var>x</var>.

<p>
The following example is from Table 15.2 (page 274) of
<cite>Schaum's Outline of Theory and Problems of Statistics</cite>,
M.R. Spiegel, 1961:

<pre>
% [nap "correlation{
	{64 57 8}
	{71 59 10}
	{53 49 6}
	{67 62 11}
	{55 51 8}
	{58 50 7}
	{77 55 10}
	{57 48 9}
	{56 52 10}
	{51 42 6}
	{76 61 12}
	{68 57 9}
}"] -f %6.4f
 1.0000  0.8196  0.7698
 0.8196  1.0000  0.7984
 0.7698  0.7984  1.0000

12.0000 12.0000 12.0000
12.0000 12.0000 12.0000
12.0000 12.0000 12.0000
</pre>

Layer 0 of the result is the correlation matrix.<br>
The correlation between columns 0 and 1 is 0.8196.<br>
The correlation between columns 0 and 2 is 0.7698.<br>
The correlation between columns 1 and 2 is 0.7984.<br>
There is no missing data, so all values in layer 1 are 12.

<p>
If
<var>y</var>
<em>is</em> specified then the result contains one or more correlations between
<var>x</var> and <var>y</var>.
The ranks of <var>x</var> and <var>y</var> must be the same.  
(The current version supports ranks 1 and 2 only.)

<p>
If <var>x</var> and <var>y</var>
have the same shape then the result contains a single correlation, calculated by
treating the elements of each array as two lists of values.
An example is:
<pre>
% [nap "correlation({1 3 _ 6 6}, {6 6 4 2 3})"] all
::NAP::118-118  f32  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 1      Name: (NULL)    Coordinate-variable: ::NAP::119-119
Value:
-0.924138
 4.000000
</pre>
Element 2 (base 0) of 
<var>x</var> 
is missing, so element 2 from
<var>y</var> 
is not used and the sample size is 4 (as shown in the second element of the result).
The correlation between {1&nbsp;3&nbsp;6&nbsp;6} and {6&nbsp;6&nbsp;2&nbsp;3}
is calculated to be -0.924138.

<p>
If <var>x</var> and <var>y</var>
have different shapes then the smaller of 
<var>x</var> and <var>y</var> 
is a window (<em>chip</em>) array which is moved around in the other array,
producing a correlation for each position.<br>
<var>lag</var><sub>0</sub> 
is vector of row    lags (default: all possible)<br>
<var>lag</var><sub>1</sub> 
is vector of column lags (default: all possible)

<h3>Grid Functions</h3>

<p>
There is currently just one grid function,
<code>invert_grid</code>, but it has variants for one and two dimensions.
The function defines a piecewise (bi-)linear mapping 
as the inverse of a given piecewise (bi-)linear mapping.

<p>
In the 1D case, the function is called by
<code>invert_grid(</code><var>y<code>,</code>ycv</var><code>)</code>,<br>
where
<var>y</var>
is the known mapping (and has a coordinate variable corresponding to 
<var>x</var>)<br>
and
<var>ycv</var>
is the desired new <var>y</var> coordinate variable.<br>
We have a piecewise-linear mapping from <var>x</var> to <var>y</var>,
and we want a piecewise-linear mapping from <var>y</var> to <var>x</var>.
The following example starts with a mapping from <var>x</var> to <var>y</var>
defined by the two lines
joining the three points (0,&nbsp;0), (2,&nbsp;1) and (5,&nbsp;4).
It produces the inverse mapping from <var>y</var> to <var>x</var> 
defined by the four lines joining the five points
(0,&nbsp;0),
(1,&nbsp;0.5),
(2,&nbsp;1.5),
(2.5,&nbsp;1.5)
and
(3,&nbsp;2).

<pre>
% nap "y = {0 1 4}"
::NAP::90-90
% $y set coo "{0 2 5}"
% [nap "coordinate_variable(y) /// y"]
0 2 5
0 1 4
% [nap "ycv = 0 .. 2 ... 1r2"]
0 0.5 1 1.5 2
% nap "x = invert_grid(y,ycv)"
::NAP::106-106
% $x all
::NAP::106-106  f32  MissingValue: NaN  References: 1  Unit: (NULL)
Link: ::NAP::107-107
Dimension 0   Size: 5      Name: (NULL)    Coordinate-variable: ::NAP::103-103
Value:
0 1 2 2.5 3
% [nap "coordinate_variable(x) /// x"]
0.0 0.5 1.0 1.5 2.0
0.0 1.0 2.0 2.5 3.0
</pre>

<p>
In the 2D case, the function is called by
<code>invert_grid(</code><var>y<code>,</code>ycv</var><code>,</code><var>x,xcv</var><code>)</code>,<br>
where matrix <var>y</var> defines a mapping from
<var>ij</var> space to <var>y</var>.<br>
matrix <var>x</var> defines a mapping from
<var>ij</var> space to <var>x</var>.<br>
The result is a 3D array whose 
<li>dimension 0 is of size 2, corresponding to the 
    <var>i</var> and <var>j</var> mappings
<li>Dimension 1 has the specified coordinate-variable
    <var>ycv</var>
<li>Dimension 2 has the specified coordinate-variable 
    <var>xcv</var>.<br>
We can think of the result as two matrices defining mappings from
<var>xy</var> space to <var>i</var>
and <var>j</var> respectively.

<h3>Functions related to Special Data-types</h3>

<p>
<table border rules=groups>
    <colgroup span=1> <colgroup span=1>

  <tr>
    <th align=center>Function
    <th align=center>Result

<tbody>

  <tr> <td> 
	<code>open_box(</code><var>x</var><code>)</code>
  <td>
	NAO pointed to by boxed NAO <var>x</var>

  </tr> <tr> <td> 
	<code>pad(</code><var>x</var><code>)</code>
  <td>
	Normal NAO corresponding to ragged NAO <var>x</var>

  </tr> <tr> <td> 
	<code>prune(</code><var>x</var><code>)</code>
  <td>
	Ragged NAO corresponding to normal NAO <var>x</var>

    </td>
</table>

<p>
The following example illustrates the use of the function
<code>open_box</code>, which allows one to extract NAOs from
a structure created with the operator &quot;<code>,</code>&quot;.

<pre>
% nap "pointers = {4 5} , 'hello' , 9"
::NAP::9776-9776
% $pointers
9772 9773 9775
% [nap "open_box(pointers(0))"] all
::NAP::9772-9772  i32  MissingValue: -2147483648  References: 1  Unit: (NULL)
Dimension 0   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Value:
4 5
% [nap "open_box(pointers(1))"] all
::NAP::9773-9773  c8  MissingValue: (NULL)  References: 1  Unit: (NULL)
Dimension 0   Size: 5      Name: (NULL)    Coordinate-variable: (NULL)
Value:
hello
% [nap "open_box(pointers(2))"] all
::NAP::9775-9775  i32  MissingValue: -2147483648  References: 1  Unit: (NULL)
Value:
9
</pre>

<p>
The following example illustrates the use of 
functions
<code>prune</code>
and its inverse
<code>pad</code>.
Function
<code>prune</code>
creates a <code>ragged</code> array.
This suppresses missing values at the start and end of the least significant
dimension (column in this matrix case).
In this matrix case it creates a separate NAO for each row and stores an
index (slot number) to these in the result.

<pre>
% nap "data = {{0 1.5 2 -1}{_ 1 4 1n}{4#_}{2#_ 9 -9}}"
::NAP::9736-9736
% $data
 0.0  1.5  2.0 -1.0
   _  1.0  4.0    _
   _    _    _    _
   _    _  9.0 -9.0
% nap "compressed_data = prune(data)"
::NAP::9738-9738
% $compressed_data all
::NAP::9738-9738  ragged  MissingValue: 0  References: 1  Unit: (NULL)
Dimension 0   Size: 4      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 4      Name: (NULL)    Coordinate-variable: (NULL)
Value:

0   start-index: 0   ::NAP::9740-9740
1   start-index: 1   ::NAP::9741-9741
2   start-index: 4   ::NAP::9742-9742
3   start-index: 2   ::NAP::9743-9743
% ::NAP::9743-9743
9 -9
% [nap "pad(compressed_data)"] all
::NAP::9745-9745  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 4      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 4      Name: (NULL)    Coordinate-variable: (NULL)
Value:
 0.0  1.5  2.0 -1.0
   _  1.0  4.0    _
   _    _    _    _
   _    _  9.0 -9.0
</pre>

<h3>Morphological Functions</h3>

<p>
<table border rules=groups>
    <colgroup span=1> <colgroup span=1>

  <tr>
    <th align=center>Function
    <th align=center>Result

<tbody>

  <tr> <td> 
	<code>dilate(</code><var>x</var>,<var>se</var>[,<var>seo</var>])</code>
  <td>
	Binary dilation of <var>x</var>;
	    <var>se</var> = structure-element;
	    <var>seo</var> = origin of structure-element

  </tr> <tr> <td> 
	<code>erode(</code><var>x</var>,<var>se</var>[,<var>seo</var>])</code>
  <td>
	Binary erosion of <var>x</var>;
	    <var>se</var> = structure-element;
	    <var>seo</var> = origin of structure-element

  </tr> <tr> <td> 
	<code>moving_range(</code><var>x</var>,<var>s</var><code>)</code>
  <td>
	Range (max-min) of moving shape-<var>s</var> window around matrix
    <var>x</var>

    </td>
</table>

<h4>
    Morphological Binary Dilation and Erosion
</h4>

<p>
    <var>x</var> is an <var>n</var> by <var>m</var> non-negative matrix that is being
    dilated or eroded.<br>
    <var>se</var> is the morphological structure element,
    an <var>a</var> by <var>b</var> matrix, where <var>a</var>&lt;<var>n</var>
    and <var>b</var>&lt;<var>m</var>.<br>
    <var>seo</var> is the origin of the structure element indexed from 0 at the top left corner.<br>

<h4>
    Moving Range
</h4>

<p>
    Move a window over the matrix <var>x</var> and find
    the maximum difference between values in the moving window.
    The result is placed in the element nearest the centre of the moving window.

<P>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="737b9c">
  <TR>
    <TD align="center"><FONT color="#ffffff" size=-2><SPAN class="titlebar">
        <b>Author:</b> <a href="http://sourceforge.net/users/dav480/">Harvey Davies</a>
        &nbsp; &nbsp; &nbsp;
        &copy; 2002, CSIRO Australia.
        &nbsp; &nbsp; &nbsp;
        <a href="http://www.csiro.au/legalnotices/disclaimer.html">Legal Notice and Disclaimer</a>
        <br>

        <b>CVS Version Details:</b> $Id: function.html,v 1.1 2002/08/07 08:09:24 dav480 Exp $
        </SPAN></FONT>
    </TD>
  </TR>
</TABLE>

</body>
</html>
