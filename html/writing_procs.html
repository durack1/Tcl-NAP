<!-- $Id: writing_procs.html,v 1.4 2005/08/04 05:37:43 dav480 Exp $ -->
<html>

<head> <title>
Writing Procedures
</title> </head>

<body>

<h2> <center>
Writing Procedures to be called as Commands or Functions
</center> </h2>

<h3>Table of Contents</h3>

<ol>
    <li><a href="#Introduction">Introduction</a>
    <li><a href="#Command_or_Function">Command or Function?</a>
    <li><a href="#Function">Writing a Procedure to be called as a Function</a>
	<ol>
	    <li><a href="#sind">Function <code>sind</code></a>
	    <li><a href="#lam">Function <code>lam</code></a>
	    <li><a href="#get_bin">Function <code>get_bin</code></a>
	    <li><a href="#fact">Function <code>fact</code></a>
	    <li><a href="#factorial">Function <code>factorial</code></a>
	</ol>
    <li><a href="#How">How NAP Functions Work</a>
    <li><a href="#Command">Writing a Procedure to be called as a Command</a>
	<ol>
	    <li><a href="#write_expr">Command <code>write_expr</code></a>
	    <li><a href="#get_binary">Command <code>get_binary</code></a>
	</ol>
</ol>

<h3>
<a name=Introduction>Introduction
</h3>

One can write a Tcl procedure which defines a new NAP function or
replaces a built-in NAP function.
Of course it is also possible to write a Tcl procedure which is called in the normal
Tcl manner (as a Tcl command) to do something related to NAP.

<p>
The following sections include various examples of procedure definition directly
from the command-line.
Of course in practice one would normally create such code in files, which would be sourced.

<p>
Tcl has facilities for automatically defining undefined commands when an attempt is made to
execute them.
In particular, the array
<code>auto_index</code>
contains the commands to define indexed commands.

<p>
Users with small libraries of their own procedures may prefer to simply source the
relevant files as part of Tcl startup.
The startup files distributed with NAP automatically source any file called
<code>my.tcl</code>
in the home directory.
This file can contain
<code>source</code>
commands to define one's own procedures.

<h3>
<a name=Command_or_Function>Command or Function?
</h3>

Before writing a procedure to perform some NAP task, one needs to decide whether it is
to be called as a command or as a function.
The first question to ask is
"Is the sole purpose to define a NAO?".
If the answer is "no" then it should be a command.
If the answer is "yes" then it should probably be a 
function, provided the arguments are not too complex.
If there are many optional string arguments then a command would probably be better.
Such a command can be called from within a NAP expression using the Tcl bracket
<code>[]</code>
facility.

<h3>
<a name=Function>Writing a Procedure to be called as a Function
</h3>

The following examples comprise a variety 
of function definitions starting from the simplest imaginable and ending with
some sophistication.

<h4>
<a name=sind>Function <code>sind</code>
</h4>

Let's begin with a simple function defined by a simple expression with one argument.
How about the sine of an angle in degrees?
Let's call it "<code>sind</code>".
The procedure can be defined on one line as follows:

<PRE>
% proc sind degrees {nap "sin(1r180p * degrees)"}
</PRE>

Note that 
"<code>1r180p</code>"
is the constant &pi;/180.
Now let's test function 
"<code>sind</code>":
<PRE>
% nap "x = 0 .. 180 ... 30"
::NAP::76-76
% nap "y = sind x"
::NAP::83-83
% [nap "transpose(x /// y)"]
            0             0
           30           0.5
           60     0.8660254
           90             1
          120     0.8660254
          150           0.5
          180  1.224606e-16
</PRE>

<h4>
<a name=lam>Function <code>lam</code>
</h4>

<p>
Now let's define a function (with two arguments x and y) defined by the above expression
<br>
"<code>transpose(x /// y)</code>".
<br>
This is the transpose of the <em>laminated</em> arguments, so let's call it
"<code>lam</code>".

<PRE>
% proc lam {
    x
    y
} {
    nap "z = x /// y"
    nap "transpose z"
}
</PRE>

There are two lines in the body of this procedure.
The result of the final line defines the result of the function.
Testing:

<PRE>
% [nap "lam(x,y)"]
            0             0
           30           0.5
           60     0.8660254
           90             1
          120     0.8660254
          150           0.5
          180  1.224606e-16
</PRE>

<h4>
<a name=get_bin>Function <code>get_bin</code>
</h4>

<P>
Now let's define a function 
"<code>get_bin</code>"
for binary input using the
"<code>nap_get</code>"
command:

<PRE>
% proc get_bin {
    filename
    {datatype {'f32'}}
    {swap 0}
} {
    # convert all arguments to strings
    set filename [[nap "filename"]]
    set datatype [[nap "datatype"]]
    set swap     [[nap "swap"]]
    set channel [open $filename]
    nap "in = [nap_get [lindex {binary swap} $swap] $channel $datatype]"
    close $channel
    nap "in"; # Define result
}
</PRE>

Note that the arguments
"<code>datatype</code>"
and
"<code>swap</code>"
have default values.
Also note how all three arguments are converted from NAP expressions to Tcl strings.

<p>
Now let's test it.
The following uses the OOC
<code>binary</code>
method to write six 
<code>f64</code>
values to the file 
"<code>double.dat</code>".
Then this file is read using function
"<code>get_bin</code>".

<PRE>
% set file [open double.dat w]
filee1eb10
% [nap "{1.5 -3 0 2 4 5}"] binary $file
% close $file
% nap "x = get_bin('double.dat', 'f64')"
::NAP::27-27
% $x all
::NAP::27-27  f64  MissingValue: NaN  References: 1
Dimension 0   Size: 6      Name: (NULL)    Coordinate-variable: (NULL)
Value:
1.5 -3 0 2 4 5
</PRE>

<h4>
<a name=fact>Function <code>fact</code>
</h4>

<p>
Now let's define a factorial function called
"<code>fact</code>".
Of course we cannot resist the temptation to use recursion:

<PRE>
% proc fact n {
    if {[$n] > 1} {
	nap "n * fact(n-1)"
    } else {
	nap "1"
    }
}
</PRE>

This works fine for scalar arguments:
<PRE>
% [nap "fact 4"]
24
% [nap "fact 1"]
1
% [nap "fact 0"]
1
</PRE>

But the following shows that it fails for a vector argument!

<PRE>
% [nap "fact {0 1 4 6}"]
1
</PRE>

<h4>
<a name=factorial>Function <code>factorial</code>
</h4>

<p>
One can define a proper elemental factorial function as follows:

<PRE>
% proc factorial n {
    if {[[nap "max(reshape(n)) > 1"]]} {
	nap "n > 1 ? n * factorial(n-1) : 1"
    } else {
	nap "1"
    }
}
% [nap "factorial {0 1 4 6}"]
1 1 24 720
</PRE>

Note the double brackets in the if command. The inner
brackets produce an OOC-name. The outer brackets execute
this OOC to produce the string 
"<code>0</code>"
or
"<code>1</code>".

<h3>
<a name=How>How NAP Functions Work
</h3>

As an example, consider the expression 
"<code>a(b)</code>",
which is of course equivalent to
"<code>a b</code>".
NAP checks whether
"<code>a</code>"
is a Tcl variable.
If not, it is assumed to be a function.
In this case NAP first looks for a Tcl procedure called
"<code>::NAP::a</code>."
If this does not exist then NAP looks for a built-in NAP function called
"<code>a</code>".
If this does not exist then NAP looks for a Tcl procedure called
"<code>a</code>".

<p>
The following example shows that a procedure with the global name
"<code>sin</code>"
does not override the built-in function with that name,
whereas defining it within the NAP namespace
"<code>::NAP::</code>"
does override:

<PRE>
% proc sin x {nap "2*x"}
% [nap "sin 1"]
0.841471
% proc ::NAP::sin x {nap "2*x"}
% [nap "sin 1"]
2
</PRE>

<p>
It is possible to call some procedures as either functions or commands.
The following example defines and uses the same function
"<code>sind</code>"
defined above:

<PRE>
% proc sind degrees {nap "sin(1r180p * degrees)"}
% [nap "sind 30"]; # call as function
0.5
% nap "s = [sind 30]"; # call as command within NAP expression
::NAP::80-80
% $s
0.5
% [sind 30] all; # call as direct OOC
::NAP::86-86  f64  MissingValue: NaN  References: 0
Value:
0.5
</PRE>

<p>
But there is a problem calling procedures as commands if the result is referenced by
a variable which is local to the procedure.
At the end of the procedure Tcl deletes such local variables.
This causes the referenced NAOs to be deleted.
For example we could redefine function
"<code>sind</code>"
as follows:

<PRE>
% proc sind degrees {
    nap "result = sin(1r180p * degrees)"
    nap "result"
}
% [nap "sind 30"]
0.5
% [sind 30]
invalid command name "::NAP::32-32"
</PRE>

<p>
Note that the call as a function still worked but not the call as a command.
NAP operates in a special mode while executing a procedure called as a function.
The deletion of NAOs referenced by local variables
is delayed until after the result has been saved.
This is one advantage of calling procedures as functions rather than commands.

<h3>
<a name=Command>Writing a Procedure to be called as a Command
</h3>

<h4>
<a name=write_expr>Command <code>write_expr</code>
</h4>

First let's define a procedure whose Tcl result is empty and of no interest.
It is obvious that such a procedure cannot be called as a function.
The purpose of the procedure is to write to a text file the result of a NAP expression,
which can of course contain variables and therefore must be executed in the caller's
namespace.
The following defines and tests the procedure:

<PRE>
% proc write_expr {
    expr
    filename
} {
    set channel [open $filename w]
    puts $channel [[uplevel nap \"$expr\"] value]
    close $channel
}
% nap "to = 5"
::NAP::52-52
% write_expr "1 .. to /// {0 7}" matrix.txt
% cat matrix.txt; # display contents of file 'matrix.txt'
1 2 3 4 5
0 7 0 7 0
</PRE>

<h4>
<a name=get_binary>Command <code>get_binary</code>
</h4>

<P>
Next let's define a procedure called
"<code>get_binary</code>"
which is intended to be called as a command,
but does essentially the same thing as the above function 
"<code>get_bin</code>".
This will help us to compare the two techniques in a situation where each has some
advantages and some disadvantages.
We assume the file
"<code>double.dat</code>"
still exists.
The following example defines and tests procedure 
"<code>get_binary</code>":

<PRE>
% proc get_binary {
    filename
    {datatype f32}
    {swap 0}
} {
    set channel [open $filename]
    nap "in = [nap_get [lindex {binary swap} $swap] $channel $datatype]"
    close $channel
    nap "+in"; # Define result as copy of 'in' to prevent premature deletion
}
% nap "x = [get_binary double.dat f64]"
::NAP::63-63
% $x all
::NAP::63-63  f64  MissingValue: NaN  References: 1
Dimension 0   Size: 6      Name: (NULL)    Coordinate-variable: (NULL)
Value:
1.5 -3 0 2 4 5
</PRE>

Note that 
"<code>get_binary</code>"
is simpler to define and simpler to use than
"<code>get_bin</code>".
The main reason for this is the fact that all three arguments are used as strings
rather than NAOs.
One disadvantage of the command approach is the need to define the result as
"<code>+in</code>"
rather than simply
"<code>in</code>".

<P>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="737b9c">
  <TR>
    <TD align="center"><FONT color="#ffffff" size=-2><SPAN class="titlebar">
        <b>Author:</b> <a href="http://sourceforge.net/users/dav480/">Harvey Davies</a>
        &nbsp; &nbsp; &nbsp;
        &copy; 2002, CSIRO Australia.
        &nbsp; &nbsp; &nbsp;
        <a href="http://www.csiro.au/legalnotices/disclaimer.html">Legal Notice and Disclaimer</a>
        <br>

        <b>CVS Version Details:</b> $Id: writing_procs.html,v 1.4 2005/08/04 05:37:43 dav480 Exp $
        </SPAN></FONT>
    </TD>
  </TR>
</TABLE>

</body>
</html>

