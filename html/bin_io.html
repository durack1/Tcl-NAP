<!-- $Id: bin_io.html,v 1.4 2004/04/02 06:08:49 dav480 Exp $ -->
<html>

<head> <title>
NAP Library: bin_io.tcl
</title> </head>

<body>

<h2> <center>
Binary Input/Output Procedures
</center> </h2>

<h3>Table of Contents</h3>

<ol>
    <li><a href="#Introduction">Introduction</a>
    <li><a href="#Simple_Binary_Files">Reading and Writing Simple Binary Files</a>
    <ol>
	<li><a href="#get_nao">Procedure <code>get_nao</code> [<var>fileName</var>
	    [<var>dataType</var> [<var>shape</var>]]]</a>
	<li><a href="#put_nao">Procedure <code>put_nao</code> [<var>nap_expr</var>
	    [<var>fileName</var>]]</a>
    </ol>
    <li><a href="#Fortran_Unformatted_Files">Reading and Writing Fortran Unformatted Files</a>
    <ol>
	<li><a href="#get_bin">Procedure <code>get_bin</code> <var>dataType</var>
	    [<var>fileId</var> [<var>mode</var>]]</a>
	<li><a href="#put_bin">Procedure <code>put_bin</code> <var>nap_expr</var>
	    [<var>fileId</var> [<var>mode</var>]]</a>
	<li><a href="#Example">Example</a>
    </ol>
    <li><a href="#cif">Reading and Writing <code>cif</code> Files</a>
    <ol>
	<li><a href="#get_cif">Procedure <code>get_cif</code> [<var>options</var>]
	    <var>pattern</var> [<var>pattern</var> ...]</a>
	<li><a href="#put_cif">Procedure <code>put_cif</code> <var>nap_expr</var>
	    [<var>fileName</var> [<var>mode</var>]]</a>
	<li><a href="#get_cif1">Procedure <code>get_cif1</code> [<var>options</var>]
	    <var>fileId</var></a>
	<li><a href="#put_cif1">Procedure <code>put_cif1</code> <var>nap_expr</var>
	    [<var>fileId</var> [<var>mode</var>]]</a>
    </ol>
    <li><a href="#Miscellaneous_Procedures">Miscellaneous Procedures</a>
    <ol>
	<li><a href="#size_of">Procedure <code>size_of</code> <var>dataType</var></a>
    </ol>
</ol>

<h3><a name=Introduction>Introduction</h3>
 
The following procedures are defined in the file <code>bin_io.tcl</code>.

<h3><a name=Simple_Binary_Files>Reading and Writing Simple Binary Files</h3>

A simple binary file is a file containing nothing except data of a single data type.

<h4><a name=get_nao>
Procedure <code>get_nao</code> [<var>fileName</var> [<var>dataType</var> [<var>shape</var>]]]</h4>

Read NAO from binary file.
<br>
<var>filename</var>: file name (default: <code>""</code> which is treated as <code>stdin</code>)
<br>
<var>dataType</var>:
<code>c8</code>,
<code>u8</code>,
<code>u16</code>,
<code>u32</code>,
<code>i8</code>,
<code>i16</code>,
<code>i32</code>,
<code>f32</code> or
<code>f64</code>
<br>
<var>shape</var>: shape of result (Default: number of elements until end)

<h4><a name=put_nao>Procedure <code>put_nao</code> [<var>nap_expr</var> [<var>fileName</var>]]</h4>

Write NAO to binary file.
<br>
<var>nap_expr</var>: NAP expression to be evaluated in caller namespace
<br>
<var>fileName</var>: file name (default: <code>stdout</code>)

<h3><a name=Fortran_Unformatted_Files>Reading and Writing Fortran Unformatted Files</h3>

Fortran unformatted files are files consisting of binary records preceded and followed by
32-bit byte-counts.

<h4><a name=get_bin>
Procedure <code>get_bin</code> <var>dataType</var> [<var>fileId</var> [<var>mode</var>]]</h4>

Read next Fortran binary (unformatted) record.
<br>
<var>dataType</var>:
<code>c8</code>,
<code>u8</code>,
<code>u16</code>,
<code>u32</code>,
<code>i8</code>,
<code>i16</code>,
<code>i32</code>,
<code>f32</code> or
<code>f64</code>
<br>
<var>fileId</var>: Tcl file handle (default: <code>stdin</code>)
<br>
<var>mode</var>: <code>binary</code> (default) or <code>swap</code>

<h4><a name=put_bin>
Procedure <code>put_bin</code> <var>nap_expr</var> [<var>fileId</var> [<var>mode</var>]]</h4>

Write Fortran binary (unformatted) record.
<br>
<var>nap_expr</var>: NAP expression to be evaluated in caller namespace
<br>
<var>fileId</var>: Tcl file handle (default: <code>stdout</code>)
<br>
<var>mode</var>: <code>binary</code> (default) or <code>swap</code>
<h4><a name=Example>Example</h4>

The following example creates a NAO called <code>squares</code>,
writes it to a file, then reads the data from this file into
a NAO called <code>in</code>.
<pre>
% nap "squares = (0 .. 4)**2"
::NAP::66-66
% $squares all
::NAP::66-66  f32  MissingValue: NaN  References: 1  Unit: (NULL)
Dimension 0   Size: 5      Name: (NULL)    Coordinate-variable: (NULL)
Value:
0 1 4 9 16
% set file [open tmp.bin w]; # open file "tmp.bin" for writing
file5
% put_bin squares $file; # write data from squares
% close $file
% set file [open tmp.bin]; # open file "tmp.bin" for reading
file5
% nap "in = [get_bin f32 $file]"; # read data into in
::NAP::78-78
% close $file
% $in all
::NAP::78-78  f32  MissingValue: NaN  References: 1  Unit: (NULL)
Dimension 0   Size: 5      Name: (NULL)    Coordinate-variable: (NULL)
Value:
0 1 4 9 16
</pre>

<h3><a name=cif>Reading and Writing <code>cif</code> Files</h3>

<p>
The <code>cif</code> (<code>conmap</code> input file) format is one which originated
in the Melbourne University Department of Meteorology in the days before netCDF and HDF.
It is now rather obsolete but is still used within CSIRO and other Australian organisations.
A cif is a Fortran unformatted file consisting of one or more frames, each
of which consists of six records as follows:
<ul>
<li> number of rows
<li> vertical coordinate variable (often latitude)
<li> number of columns
<li> horizontal coordinate variable (often longitude)
<li> title
<li> main data (matrix)
</ul>

<p>
The main input procedure is <code>get_cif</code>, which 
reads one or more matrices from each of one or more cif files.
The main output procedure is <code>put_cif</code>, which writes a NAO as an entire cif.
These procedures call the low-level procedures <code>get_cif1</code>
or <code>put_cif1</code> for each frame.
The default <var>mode</var> for <code>put_cif</code> and <code>put_cif1</code>
is <code>auto</code> which produces a big-endian file regardless of the platform.

<h4><a name=get_cif>
Procedure <code>get_cif</code> [<var>options</var>] <var>pattern</var> [<var>pattern</var> ...]</h4>

Read one or more matrices from each of one or more cif files
(whose names are specified by one or more glob patterns).
The result is 2D if only one frame is read, otherwise it is 3D.
Check whether byte swapping is needed by examining 1st word in file.
<br>
Options:
<br><code>-g 0|1</code>: <code>1</code> (default) for geographic mode, 
<code>0</code> for non-geographic mode
<br><code>-m</code> <b>real</b>: Input missing value (default: <code>-7777777.0</code>)
<br><code>-um</code> <b>text</b>: Units for matrix (default: none)
<br><code>-ux</code> <b>text</b>: Units for x (default: if geographic mode then 
<code>degrees_east</code>, else none)
<br><code>-uy</code> <b>text</b>: Units for y (default: if geographic mode then 
<code>degrees_north</code>, else none)
<br><code>-x</code> <b>text</b>: Name of dimension x 
(default: if geographic mode then <code>longitude</code> else x)
<br><code>-y</code> <b>text</b>: Name of dimension y 
(default: if geographic mode then <code>latitude</code> else x)
<p>
The following example reads a single-frame cif named <code>7.cif</code>
into a NAO called <code>in</code>, then
displays it (including the coordinate variables).
<pre>
% nap "in = [get_cif 7.cif]"
::NAP::357-357
% $in all
::NAP::357-357  f32  MissingValue: NaN  References: 1  Unit: (NULL)
This data originated from ascii conmap input file 'acif.7'
Dimension 0   Size: 3      Name: latitude  Coordinate-variable: ::NAP::236-236
Dimension 1   Size: 4      Name: longitude  Coordinate-variable: ::NAP::308-308
Value:
 1  1  2 -3
 1  _  3 -4
 2  0  4  5
% [nap "coordinate_variable(in,0)"]
-60 30 60
% [nap "coordinate_variable(in,1)"]
-90 30 90 180
</pre>

<h4><a name=put_cif>
Procedure <code>put_cif</code> <var>nap_expr</var> [<var>fileName</var> [<var>mode</var>]]</h4>

Write NAO as entire cif.
<br>
<var>nap_expr</var>: NAP expression to be evaluated in caller namespace
<br>
<var>fileName</var>: file name (default: <code>stdout</code>)
<br>
<var>mode</var>: <code>auto</code> (default), <code>binary</code> or <code>swap</code>

<h4><a name=get_cif1>Procedure <code>get_cif1</code> [<var>options</var>] <var>fileId</var></h4>

Read next frame from cif (Conmap Input File).
<br>
Options:
<br><code>-g 0|1</code>: <code>1</code> (default) for geographic mode, 
<code>0</code> for non-geographic mode
<br><code>-m</code> <b>real</b>: Input missing value (default: <code>-7777777.0</code>)
<br><code>-s 0|1</code>: <code>0</code> (default) for binary mode, 
<code>1</code> for swap (byte-swapping) mode
<br><code>-um</code> <b>text</b>: Units for matrix (default: none)
<br><code>-ux</code> <b>text</b>: Units for x (default: if geographic mode then 
<code>degrees_east</code>, else none)
<br><code>-uy</code> <b>text</b>: Units for y (default: if geographic mode then 
<code>degrees_north</code>, else none)
<br><code>-x</code> <b>text</b>: Name of dimension x 
(default: if geographic mode then <code>longitude</code> else x)
<br><code>-y</code> <b>text</b>: Name of dimension y 
(default: if geographic mode then <code>latitude</code> else x)
<p>
The following example reads the first frame of a cif named <code>7.cif</code>
into a NAO called <code>in</code>, then displays it (including the coordinate variables).
<pre>
% set f [open 7.cif]
file5
% nap "in = [get_cif1 $f]"
::NAP::218-218
% close $f
% $in all
::NAP::218-218  f32  MissingValue: NaN  References: 1  Unit: (NULL)
This data originated from ascii conmap input file 'acif.7'
Dimension 0   Size: 3      Name: latitude  Coordinate-variable: ::NAP::97-97
Dimension 1   Size: 4      Name: longitude  Coordinate-variable: ::NAP::169-169
Value:
 1  1  2 -3
 1  _  3 -4
 2  0  4  5
% ::NAP::97-97
-60 30 60
% ::NAP::169-169
-90 30 90 180
</pre>

<h4><a name=put_cif1>
Procedure <code>put_cif1</code> <var>nap_expr</var> [<var>fileId</var> [<var>mode</var>]]</h4>

Write NAO as frame of cif.
<br>
<var>nap_expr</var>: NAP expression to be evaluated in caller namespace
<br>
<var>fileId</var>: Tcl file handle (default: <code>stdout</code>)
<br>
<var>mode</var>: <code>auto</code> (default), <code>binary</code> or <code>swap</code>

<h3><a name=Miscellaneous_Procedures>Miscellaneous Procedures</h3>

<h4><a name=size_of>Procedure <code>size_of</code> <var>dataType</var></h4>

Number of bytes in <var>dataType</var>.
<p>
Example:
<pre>
% size_of i16
2
</pre>

<P>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="737b9c">
  <TR>
    <TD align="center"><FONT color="#ffffff" size=-2><SPAN class="titlebar">
        <b>Author:</b> <a href="http://sourceforge.net/users/dav480/">Harvey Davies</a>
        &nbsp; &nbsp; &nbsp;
        &copy; 2002, CSIRO Australia.
        &nbsp; &nbsp; &nbsp;
        <a href="http://www.csiro.au/legalnotices/disclaimer.html">Legal Notice and Disclaimer</a>
        <br>

        <b>CVS Version Details:</b> $Id: bin_io.html,v 1.4 2004/04/02 06:08:49 dav480 Exp $
        </SPAN></FONT>
    </TD>
  </TR>
</TABLE>

</body>
</html>
