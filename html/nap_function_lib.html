<!-- $Id: nap_function_lib.html,v 1.7 2004/07/19 00:10:49 dav480 Exp $ -->
<html>

<head> <title>
NAP Library: nap_function_lib.tcl
</title> </head>

<body>

<h2> <center>
Miscellaneous Functions
</center> </h2>

<h3>Table of Contents</h3>

<ol>
    <li><a href="#Introduction">Introduction</a>
    <li><a href="#color_wheel"><code>color_wheel(</code><var>n</var><code>,</code><var>v</var><code>,</code><var>b</var><code>)</code></a>
    <li><a href="#cv">
	<code>cv(</code><var>main_nao</var>[<code>,</code><var>dim_number</var>]<code>)</code></a>
    <li><a href="#derivative">
	<code>derivative(</code><var>a</var>[<code>,</code><var>dim_number</var>]<code>)</code></a>
    <li><a href="#fill_holes"><code>fill_holes(</code><var>x</var><code>)</code></a>
    <li><a href="#fuzzy_floor">
	<code>fuzzy_floor(</code><var>x</var>[<code>,</code><var>eps</var>]<code>)</code></a>
    <li><a href="#fuzzy_ceil">
	<code>fuzzy_ceil(</code><var>x</var>[<code>,</code><var>eps</var>]<code>)</code></a>
    <li><a href="#gets_matrix"><code>gets_matrix(</code><var>filename</var><code>)</code></a>
    <li><a href="#head"><code>head(</code><var>x</var>[<code>,</code><var>n</var>]<code>)</code></a>
    <li><a href="#hsv2rgb"><code>hsv2rgb(</code><var>hsv</var><code>)</code></a>
    <li><a href="#isMissing"><code>isMissing(</code><var>x</var><code>)</code></a>
    <li><a href="#isPresent"><code>isPresent(</code><var>x</var><code>)</code></a>
    <li><a href="#magnify_interp"><code>magnify_interp(</code><var>a</var><code>, </code><var>mag_factor</var><code>)</code></a>
    <li><a href="#mixed_base">
	<code>mixed_base(</code><var>x</var><code>,</code><var>b</var><code>)</code></a>
    <li><a href="#nub"><code>nub(</code><var>x</var><code>)</code></a>
    <li><a href="#outer"><code>outer(</code><var>dyad</var><code>,</code><var>y</var>[,</code><var>x</var>]<code>)</code></a>
    <li><a href="#scattered2grid"><code>scattered2grid(</code><var>xyz</var><code>,</code><var>ycv</var><code>,</code><var>xcv</var><code>)</code></a>
    <li><a href="#scaleAxis"><code>scaleAxis(</code><var>xstart</var><code>,</code><var>xend</var>[<code>,</code><var>nmax</var>[<code>,</code><var>nice</var>]]<code>)</code></a>
    <li><a href="#scaleAxisSpan"><code>scaleAxisSpan(</code><var>xstart</var><code>,</code><var>xend</var>[<code>,</code><var>nmax</var>[<code>,</code><var>nice</var>]]<code>)</code></a>
    <li><a href="#range"><code>range(</code><var>a</var><code>)</code></a>
    <li><a href="#tail"><code>tail(</code><var>x</var>[<code>,</code><var>n</var>]<code>)</code></a>
</ol>

<h3><a name=Introduction>Introduction</h3>

The following functions are defined in the file <code>nap_function_lib.tcl</code>.

<h3><a name=color_wheel>
<code>color_wheel(</code><var>n</var><code>,</code><var>v</var><code>,</code><var>b</var><code>)</code>
</h3>

Square containing color wheel.
<br>
<var>n</var> is number rows & columns
<br>
<var>v</var> is desired "value" level
<br>
<var>b</var> is background colour outside circle
<p>
Example:
<br>
<code>
nap "color_wheel(100,255,3#150)"
</code>
<br>
This produces a <code>u8</code> array with shape
<code>{3 100 100}</code> & values from 0 to 255.

<h3><a name=cv>
<code>cv(</code><var>main_nao</var>[<code>,</code><var>dim_number</var>]<code>)</code>
</h3>

This is simply an alias for <code>coordinate_variable</code>.

<h3><a name=derivative>
<code>derivative(</code><var>a</var>[<code>,</code><var>dim_number</var>]<code>)</code>
</h3>

Estimate derivative along dimension <var>dim_number</var> (default is 0) of array <var>a</var>.
The result has the same shape as <var>a</var>.

<p>
Example (assuming <code>vector</code> has dimension (& coordinate variable) <code>time</code>:
<br>
<pre>
derivative(vector); # result is derivative with respect to time
</pre>

<p>
Examples (assuming <code>matrix</code> has dimensions
<code>latitude</code> & <code>longitude</code>):
<br>
<pre>
derivative(matrix, 'latitude');	# result is derivative with respect to latitude
derivative(matrix, 0);		# result is derivative with respect to latitude
derivative(matrix);		# result is derivative with respect to latitude
derivative(matrix,'longitude');	# result is derivative with respect to longitude
derivative(matrix, 1);		# result is derivative with respect to longitude
</pre>

<p>
Based on quadratic through 3 points (provided size of dimension is > 2 -- if only 2 then
based on straight line). These always include the point corresponding to the result.
For interior points, the other 2 are the closest neighbour on each side.  For boundry
points, these are the 2 closest neighbours.

<p>
Let D(x) be the derivative of quadratic through points
<code>(x0,y0), (x1,y1), (x2,y2)</code>.
<br>
<pre>
D1 = D(x1) = a0 * y0 + a1 * y1 + a2 * y2
where the coefficients a0, a1, a2 are defined by:
	a0 = (x1 - x2) / ((x1 - x0) * (x2 - x0))
	a1 = 1 / (x1 - x0) - 1 / (x2 - x1)
	a2 = (x1 - x0) / ((x2 - x0) * (x2 - x1))
</pre>

<h3><a name=fill_holes>
<code>fill_holes(</code><var>x</var><code>)</code>
</h3>

Replace missing values by estimates based on means of neighbours.

<h3><a name=fuzzy_floor>
<code>fuzzy_floor(</code><var>x</var>[<code>,</code><var>eps</var>]<code>)</code>
</h3>

Like <code>floor()</code> except allow for rounding error.
<br>
<var>eps</var> is tolerance and defaults to <code>1e-9</code>.
<p>
Example:
<br>
<code>
% [nap "fuzzy_floor({4.998 4.9998},1e-3)"]
<br>
4 5
</code>

<h3><a name=fuzzy_ceil>
<code>fuzzy_ceil(</code><var>x</var>[<code>,</code><var>eps</var>]<code>)</code>
</h3>

Like <code>ceil()</code> except allow for rounding error.
<br>
<var>eps</var> is tolerance and defaults to <code>1e-9</code>.
<p>
Example:
<br>
<code>
% [nap "fuzzy_ceil({5.002 5.0002},1e-3)"]
<br>
6 5
</code>

<h3><a name=gets_matrix>
<code>gets_matrix(</code><var>filename</var><code>)</code>
</h3>

Read text file and return NAO matrix whose rows correspond to the lines in the file.
Ignore blank lines and lines whose first non-whitespace character is '#'.
<br>
<p>
Example:
<br>
<code>
gets_matrix('my_matrix.txt')
</code>

<h3><a name=head>
<code>head(</code><var>x</var>[<code>,</code><var>n</var>]<code>)</code>
</h3>

If <var>n</var> &ge; 0 then result is 1st <var>n</var> elements of <var>x</var>,
cycling if <var>n</var> > nels(<var>x</var>).
<br>
<var>n</var> defaults to 1.
<br>
If <var>n</var> <  0 then result is 1st nels(<var>x</var>)+<var>n</var> elements of <var>x</var>
i.e. drop &minus;<var>n</var> from end
<br>
<p>
Example:
<br>
<pre>
% [nap "head({3 1 9 2 7})"]
3
% [nap "head({3 1 9 2 7}, 2)"]
3 1
% [nap "head({3 1 9 2 7}, -2)"]
3 1 9
</pre>

<h3><a name=hsv2rgb>
<code>hsv2rgb(</code><var>hsv</var><code>)</code>
</h3>

Convert colour in HSV form to RGB.
<br>
<var>hsv</var> is an array whose leading dimension has size 3.
<p>
    Layer 0 along this dimension corresponds to hue as an angle in degrees.
    Angles of any sign or magnitude are allowed.
    Red&nbsp;=&nbsp;0, yellow&nbsp;=&nbsp;60, green&nbsp;=&nbsp;120,
    cyan&nbsp;=&nbsp;180, blue&nbsp;=&nbsp;&minus;120, magenta&nbsp;=&nbsp;&minus;60.
<p>
    Layer 1 along this dimension corresponds to saturation in range 0.0 to 1.0.
<p>
    Layer 2 along this dimension corresponds to "value". This has the same
    range as the RGB values, normally either 0.0 to 1.0 or 0 to 255.
    If you are casting the result to an integer & want a maximum of 255 then
    set the maximum to say 255.999. Otherwise you will get few if any 255s.
<p>
    The result has the same shape as the argument (hsv).
<p>
    See Foley, vanDam, Feiner and Hughes, Computer Graphics
    <em>Principles and Practice</em>, Second Edition, 1990, ISBN 0201121107
    page 593. 
<br>
<p>
Example:
<br>
<code>
% [nap "hsv2rgb {180.0 0.5 100.0}"]
<br>
50 100 100
</code>

<h3><a name=isMissing>
<code>isMissing(</code><var>x</var><code>)</code>
</h3>

1 if <var>x</var> missing, 0 if present.
<br>
<p>
Example:
<br>
<code>
% [nap "isMissing {0 _ 9}"]
<br>
0 1 0
</code>

<h3><a name=isPresent>
<code>isPresent(</code><var>x</var><code>)</code>
</h3>

0 if <var>x</var> missing, 1 if present.
<br>
<p>
Example:
<br>
<code>
% [nap "isPresent {0 _ 9}"]
<br>
1 0 1
</code>

<h3><a name=magnify_interp>
<code>magnify_interp(</code><var>a</var><code>, </code><var>mag_factor</var><code>)</code>
</h3>


Magnify each dimension of array <var>a</var> by factor defined by the
corresponding element of </code><var>mag_factor</var> if this is a vector.
If this is a scalar then every dimension is magnified by the same factor.
The new values are estimated using multi-linear interpolation.

<p>
This function can be used to make images larger or smaller.

<p>
Example:
<br>
<code>
% [nap "magnify_interp({{1 2 3}{4 5 6}}, {1 3})"] value
<br>
1.00000 1.33333 1.66667 2.00000 2.33333 2.66667 3.00000
<br>
4.00000 4.33333 4.66667 5.00000 5.33333 5.66667 6.00000
</code>

<h3><a name=magnify_nearest>
<code>magnify_nearest(</code><var>a</var><code>, </code><var>mag_factor</var><code>)</code>
</h3>


This function is similar to 
<code>magnify_interp</code>
except that the new values are defined by the nearest neighbour rather than interpolation.

<p>
Example:
<br>
<code>
% [nap "magnify_nearest({{1 2 3}{4 5 6}}, {1 3})"] value
<br>
1 1 2 2 2 3 3
<br>
4 4 5 5 5 6 6
</code>

<h3><a name=mixed_base>
<code>mixed_base(</code><var>x</var><code>,</code><var>b</var><code>)</code>
</h3>

Convert scalar value <var>x</var> to mixed base defined by vector <var>b</var>.
<br>
<p>
Following example converts 87 inches to yards, feet & inches:
<br>
<code>
% [nap "mixed_base(87, {3 12})"]
<br>
2 1 3
</code>

<h3><a name=nub>
<code>nub(</code><var>x</var><code>)</code>
</h3>

Result is vector of distinct values in argument (in same order).

<h3><a name=outer>
<code>outer(</code><var>dyad</var><code>,</code><var>y</var>[,</code><var>x</var>]<code>)</code>
</h3>

Tensor outer-product.
<p>
<var>dyad</var> is name of either
<li> function with two arguments
<li> binary (dyadic) operator
<br>
<var>x</var> is vector
<br>
<var>y</var> is vector defaulting to <var>x</var>
<br>
Result is cross-product of <var>x</var> and <var>y</var>,
applying <var>dyad</var> to each combination of <var>x</var> & <var>y</var>.
<br>
<var>x</var> & <var>y</var> are the coordinate variables of the result.
<br>
<p>
Following example produces a multiplication table:
<br>
<pre>
% [nap "outer('*', 1 .. 5)"]
 1  2  3  4  5
 2  4  6  8 10
 3  6  9 12 15
 4  8 12 16 20
 5 10 15 20 25
</pre>

<h3><a name=scattered2grid>
<code>scattered2grid(</code><var>xyz</var><code>,</code><var>ycv</var><code>,</code><var>xcv</var><code>)</code>
</h3>

<p>
Produce a matrix grid from scattered (<var>x,y,z</var>) data using triangulation.
Grid points within each triangle are defined by interpolating using a plane
through the three vertices of the triangle.

<p>
<var>xyz</var>
is an <var>n</var>&times;<var>m</var>
matrix containing data corresponding to
<var>n</var>
points
(<var>x,y,z</var>).
The number of columns
(<var>m</var>)
must be at least 3.
Columns 0, 1 and 2 contain x, y and z values respectively.
Any further columns are ignored.

<p>
<var>ycv</var> and <var>xcv</var> specify the coordinate-variables for the grid.

<p>
The following example defines a grid from the four points
(2,2,0), (6,4,0), (2,4,4) and (4,5,3). 
Note that the missing values in the result correspond to points which are outside
of both the triangles produced by the triangulation.
You could eliminate these missing values by defining values at all four corners of the grid.

<pre>
% nap "z = scattered2grid({{2 2 0}{6 4 0}{2 4 4}{4 5 3}}, 2 .. 5, 2 .. 6)"
::NAP::1020-1020
% $z
0.00    _    _    _    _
2.00 0.75 0.00    _    _
4.00 2.50 1.50 0.75 0.00
   _    _ 3.00    _    _
% [nap "z(@2, @2)"]; # Check value at x=2, y=2
0
% [nap "z(@4, @6)"]; # Check value at x=6, y=4
0
% [nap "z(@4, @2)"]; # Check value at x=2, y=4
4
% [nap "z(@5, @4)"]; # Check value at x=4, y=5
3
</pre>

<h3><a name=scaleAxis>
<code>scaleAxis(</code><var>xstart</var><code>,</code><var>xend</var>[<code>,</code><var>nmax</var>[<code>,</code><var>nice</var>]]<code>)</code>
</h3>

Find suitable values for axis of graph.
<br>
<var>xstart</var>: 1st data value
<br>
<var>xend</var>: Final data value
<br>
<var>nmax</var>: Max. allowable number of elements in result (Default: 10)
<br>
<var>nice</var>: Allowable increments (Default: <code>{1 2 5}</code>)
<br>
Result is the arithmetic progression which:
<li> is within interval from <var>xstart</var> to <var>xend</var>
<li> has same order (ascending/descending) as <var>xstart</var><code>//</code><var>xend</var>
<li> has increment equal to element of <var>nice</var> times a power
	<code>(-30 .. 30)</code> of 10
<li> has at least two elements
<li> has no more than <var>nmax</var> elements if possible
<li> has as many elements as possible.
	(Ties are resolved by choosing earlier element in <var>nice</var>.)
<p>
Example:
<br>
<code>
% [nap "axis = scaleAxis(-370, 580, 10, {10 20 25 50})"] value
<br>
-300 -200 -100 0 100 200 300 400 500
</code>

<h3><a name=scaleAxisSpan>
<code>scaleAxisSpan(</code><var>xstart</var><code>,</code><var>xend</var>[<code>,</code><var>nmax</var>[<code>,</code><var>nice</var>]]<code>)</code>
</h3>

Find suitable values for axis of graph.
<br>
<var>xstart</var>: 1st data value
<br>
<var>xend</var>: Final data value
<br>
<var>nmax</var>: Max. allowable number of elements in result (Default: 10)
<br>
<var>nice</var>: Allowable increments (Default: <code>{1 2 5}</code>)
<br>
Result is the arithmetic progression which:
<li> includes the interval from <var>xstart</var> to <var>xend</var>
<li> has same order (ascending/descending) as <var>xstart</var><code>//</code><var>xend</var>
<li> has increment equal to element of <var>nice</var> times a power
	<code>(-30 .. 30)</code> of 10
<li> has at least two elements
<li> has no more than <var>nmax</var> elements if possible
<li> has as many elements as possible.
	(Ties are resolved by choosing earlier element in <var>nice</var>.)
<p>
Example:
<br>
<code>
% [nap "axis = scaleAxisSpan(-370, 580, 10, {10 20 25 50})"] value
<br>
-400 -200 0 200 400 600
</code>

<h3><a name=range>
<code>range(</code><var>a</var><code>)</code>
</h3>

Result is 2-element vector containing minimum and maximum of array <var>a</var>.
<br>
Example:
<br>
<code>
% [nap "range {{9 -1 -5}{2 9 3}}"]
<br>
-5 9
</code>

<h3><a name=tail>
<code>tail(</code><var>x</var>[<code>,</code><var>n</var>]<code>)</code>
</h3>

If <var>n</var> &ge; 0 then result is final <var>n</var> elements of <var>x</var>,
cycling if <var>n</var> > nels(<var>x</var>).
<br>
<var>n</var> defaults to 1.
<br>
If <var>n</var> <  0 then result is final 
<code>nels(</code><var>x</var><code>)+</code><var>n</var> elements of <var>x</var>
i.e. drop &minus;<var>n</var> from start.
<br>
<p>
Example:
<br>
<pre>
% [nap "tail({3 1 9 2 7})"]
7
% [nap "tail({3 1 9 2 7}, 2)"]
2 7
% [nap "tail({3 1 9 2 7}, -2)"]
9 2 7
</pre>

<P>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="737b9c">
  <TR>
    <TD align="center"><FONT color="#ffffff" size=-2><SPAN class="titlebar">
        <b>Author:</b> <a href="http://sourceforge.net/users/dav480/">Harvey Davies</a>
        &nbsp; &nbsp; &nbsp;
        &copy; 2002, CSIRO Australia.
        &nbsp; &nbsp; &nbsp;
        <a href="http://www.csiro.au/legalnotices/disclaimer.html">Legal Notice and Disclaimer</a>
        <br>

        <b>CVS Version Details:</b> $Id: nap_function_lib.html,v 1.7 2004/07/19 00:10:49 dav480 Exp $
        </SPAN></FONT>
    </TD>
  </TR>
</TABLE>

</body>
</html>
