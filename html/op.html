<!-- $Id: op.html,v 1.2 2002/08/07 08:58:48 dav480 Exp $ -->
<html>

<head> <title>
NAP Operators
</title> </head>

<body>

<h2> <center>
NAP Operators
</center> </h2>

<h3>Operators and Precedence</h3>

<p>
The following table is essentially a superset of <b>Table 5.2</b> in Ousterhout's 
1994 classic <cite>Tcl and the Tk Toolkit</cite>. As there, groups of operators 
between horizontal lines have the same precedence; higher groups have higher precedence. 

<p>
Operators are left-associative unless specified otherwise.
For example, <code>**</code> is right-associative, as shown by:

<pre>
% [nap "10 ** 2 ** 3"]
1e+08
</pre>

<p>
The nature of arguments is indicated as follows:
<br>
<var>a</var> and <var>b</var> represent general arrays.
<br>
<var>x</var> and <var>y</var> represent scalars.
<br>
<var>u</var> and <var>v</var> represent vectors.
<br>
<var>A</var> and <var>B</var> represent matrices.
<br>
<var>n</var> represents a Tcl name, which may include namespaces.
<br>
<var>p</var> represents a boxed vector of pointers to arrays.

<p>
<table border rules=groups>
    <colgroup span=1> <colgroup span=1>

    <tr>
	<th align=center>Syntax
	<th align=center>Result

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>**</code><var>b</var>
	    <td>
		<var>a</var> raised to the power <var>b</var>. Right-associative

    <tbody>
	<tr valign=top> <td>
		<code>-</code><var>a</var>
	    <td>
		Negative of <var>a</var>
	<tr valign=top> <td>
		<code>!</code><var>a</var>
	    <td>
		Logical NOT: 1 if <var>a</var> is zero, 0 otherwise
	<tr valign=top> <td>
		<code>~</code><var>a</var>
	    <td>
		Bit-wise complement of <var>a</var>
	<tr valign=top> <td>
		<code>#</code><var>a</var>
	    <td>
		Frequencies of values 0, 1, 2, &hellip;&nbsp;
		(Ignore negative and missing values)
	<tr valign=top> <td>
		<code>@</code><var>a</var>
	    <td>
		Interpolated subscript:
		<var>s</var> such that 
		<var>c</var>(<var>s</var>)=<var>a</var>,
		<br>
		where <var>c</var> is the coordinate variable of this dimension

	<tr valign=top> <td>
		<code>@@</code><var>a</var>
	    <td>
		Subscript of closest:
		<code>i32</code> <var>s</var> for which 
<code>abs(</code><var>c</var><code>(</code><var>s</var><code>)-</code><var>a</var><code>)</code>
		    is least,
		<br>
		where <var>c</var> is the coordinate variable of this dimension

    <tbody>
	<tr valign=top> <td>
		<var>v</var><code>@</code><var>b</var>
	    <td>
		Interpolated subscript:
		<code>f32</code> subscript <var>s</var> such that
		<var>v</var><code>(</code><var>s</var><code>)==</code><var>b</var>,
		<br>
		where <var>v</var> is ordered vector
	<tr valign=top> <td>
		<var>v</var><code>@@</code><var>b</var>
	    <td>
		Subscript of closest:
		<code>i32</code> subscript <var>s</var> for which 
<code>abs(</code><var>v</var><code>(</code><var>s</var><code>)-</code><var>b</var><code>)</code>
		    is least
	<tr valign=top> <td>
		<var>v</var><code>@@@</code><var>b</var>
	    <td>
		Subscript of match:
		smallest <code>i32</code> subscript <var>s</var> for which
		    <var>v</var><code>(</code><var>s</var><code>)==</code><var>b</var>

	<tr valign=top> <td nowrap>
		[<var>a</var>]<code>...</code>[<var>b</var>]
	    <td>
		High-precedence Link:
		Boxed vector pointing to <var>a</var>
		and <var>b</var>

    <tbody>
	<tr valign=top> <td>
		<var>x</var><code>..</code><var>y</var>
	    <td>
		(<var>x</var> and <var>y</var> scalar)
		Arithmetic progression from <var>x</var> to <var>y</var>
		in steps of <code>+1</code> or <code>-1</code>

	<tr valign=top> <td>
		<var>x</var><code>..</code><var>p</var>
	    <td>
		(<var>x</var> scalar, <var>p</var> boxed 2-element vector)
		Arithmetic progression
		<br>
		<var>x</var> is 1st element;
		<var>p</var><sub>0</sub> points to final element;
		<var>p</var><sub>1</sub> points to step
		<br>
		<var>p</var> often defined using &quot;<code>...</code>&quot;, as in
		&quot;<code>3..7...2</code>&quot; which is <code>{3 5 7}</code>

    <tbody>
	<tr valign=top> <td>
		<var>u</var><code>#</code><var>v</var>
	    <td>
		<var>u</var> copies of <var>v</var>
		(<var>u</var> and <var>v</var> are vectors with same shape (or scalars))

	<tr valign=top> <td>
		<var>p</var><code>#</code><var>b</var>
	    <td>
		Cross-product replication
		(<var>p</var> boxed vector with <code>rank(</code><var>b</var><code>)</code>
		elements)

    <tbody>
	<tr valign=top> <td>
		<var>u</var><code>+*</code><var>v</var>
	    <td>
		(<var>u</var> and <var>v</var> vectors)
		Scalar (dot) product

	<tr valign=top> <td>
		<var>A</var><code>+*</code><var>B</var>
	    <td>
		(<var>A</var> and <var>B</var> matrices)
		Matrix product

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>*</code><var>b</var>
	    <td>
		Multiply <var>a</var> and <var>b</var> 
	<tr valign=top> <td>
		<var>a</var><code>/</code><var>b</var>
	    <td>
		Divide <var>a</var> by <var>b</var>
	<tr valign=top> <td>
		<var>a</var><code>%</code><var>b</var>
	    <td>
		Remainder <var>r</var> after dividing <var>a</var>
		by <var>b</var>, which need not be integers
		<br>
		If <var>b</var>&gt;0 then 0&le;<var>r</var>&lt;<var>b</var>.
		If <var>b</var>=0 then <var>r</var>=0.
		If <var>b</var>&lt;0 then <var>b</var>&lt;<var>r</var>&le;0

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>+</code><var>b</var>
	    <td>
		Add <var>a</var> and <var>b</var>
	<tr valign=top> <td>
		<var>a</var><code>-</code><var>b</var>
	    <td>
		Subtract <var>b</var> from <var>a</var>

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code><<</code><var>b</var>
	    <td>
		Left-shift <var>a</var> by <var>b</var> bits
	<tr valign=top> <td>
		<var>a</var><code>>></code><var>b</var>
	    <td>
		Right-shift <var>a</var> by <var>b</var> bits

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code><<<</code><var>b</var>
	    <td>
		Lesser of <var>a</var> and <var>b</var>
	<tr valign=top> <td>
		<var>a</var><code>>>></code><var>b</var>
	    <td>
		Greater of <var>a</var> and <var>b</var>

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code><</code><var>b</var>
	    <td>
		1 if <var>a</var> is less than <var>b</var>,
		0 otherwise
	<tr valign=top> <td>
		<var>a</var><code>></code><var>b</var>
	    <td>
		1 if <var>a</var> is greater than <var>b</var>,
		0 otherwise
	<tr valign=top> <td>
		<var>a</var><code><=</code><var>b</var>
	    <td>
		1 if <var>a</var> is less than or equal to <var>b</var>,
		0 otherwise
	<tr valign=top> <td>
		<var>a</var><code>>=</code><var>b</var>
	    <td>
		1 if <var>a</var> is greater than or equal to
		<var>b</var>, 0 otherwise

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>==</code><var>b</var>
	    <td>
		1 if <var>a</var> is equal to <var>b</var>, 0 otherwise
	<tr valign=top> <td>
		<var>a</var><code>!=</code><var>b</var>
	    <td>
		1 if <var>a</var> is not equal to <var>b</var>,
		0 otherwise

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>&</code><var>b</var>
	    <td>
		Bit-wise AND of <var>a</var> and <var>b</var>

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>^</code><var>b</var>
	    <td>
		Bit-wise exclusive OR of <var>a</var> and <var>b</var>

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>|</code><var>b</var>
	    <td>
		Bit-wise OR of <var>a</var> and <var>b</var>

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>&&</code><var>b</var>
	    <td>
		Logical AND: 1 if both <var>a</var> and
		<var>b</var> are non-zero, 0 otherwise

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>||</code><var>b</var>
	    <td>
		Logical OR: 1 if either <var>a</var> or
		<var>b</var> is non-zero, 0 otherwise

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>?</code><var>b</var><code>:</code><var>c</var>
	    <td>
		Choice: if <var>a</var> is non-zero then <var>b</var>, 
		    else <var>c</var>

    <tbody>
	<tr valign=top> <td>
		<var>a</var><code>//</code><var>b</var>
	    <td>
		Concatenate along an existing dimension
	<tr valign=top> <td>
		<var>a</var><code>///</code><var>b</var>
	    <td>
		Concatenate along a new dimension

    <tbody>
	<tr valign=top> <td>
		[<var>a</var>]<code>,</code>[<var>b</var>]
		<td>
		Low-precedence Link:
		Boxed vector pointing to <var>a</var>
		and <var>b</var>

    <tbody>
	<tr valign=top> <td>
		<var>n</var><code>=</code><var>a</var>
	    <td>
		Assignment: Set <var>n</var> to OOC-name of <var>a</var>.
		Result is <var>a</var>. Right-associative

</table>

<h3>Assignment Operator &quot;<code>=</code>&quot;</h3>

<p>
The &quot;<code>nap</code>&quot; command
(unlike &quot;<code>expr</code>&quot;)
allows the assignment operator 
  &quot;<code>=</code>&quot;. The left-hand operand must be a Tcl name, which 
  is used to define a Tcl variable whose (string) value is set to the OOC-name of 
  the right-hand operand. The assignment operator has a result like any other 
  operator. This result is the value of the right-hand operand. This is shown 
  in the following: </p>

<PRE>
% nap "a = (b = 6) + 2"
::NAP::15-15
% $b
6
% $a
8
</PRE>

<p>
The assignment operator has the lowest precedence and is right-associative, allowing 
expressions such as:

<PRE>
% nap "a = 3 + b = {1.5 0}"
::NAP::16-16
% $b
1.5 0
% $a
4.5 3
</PRE>

<h3>Arithmetic Progression Operator &quot;<code>..</code>&quot;</h3>

<P>
The data-type of the result depends on the data-types of
<var>first</var>, <var>final</var> and <var>step</var>.

<P>
If <code>(</code><var>final</var><code>-</code><var>first</var><code>)/</code><var>step</var>
is non-integer then 
<var>final</var> is adjusted to the closest value giving an integer.
For example:

<PRE>
% [nap "-3 .. 8 &hellip; 3"] all
::NAP::51-51  i32  MissingValue: -2147483648  References: 0  Unit: (NULL)
Dimension 0   Size: 5      Name: (NULL)    Coordinate-variable: (NULL)
Value:
-3 0 3 6 9
% [nap "9.1 .. 4.7"] all
::NAP::55-55  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 5      Name: (NULL)    Coordinate-variable: (NULL)
Value:
9.1 8.1 7.1 6.1 5.1
</PRE>

<h3> Link Operators &quot;<code>...</code>&quot; and &quot;<code>,</code>&quot;</h3>

<P>
The link operators &quot;<code>...</code>&quot; and &quot;<code>,</code>&quot;
are identical except for precedence.
The left operand generates one boxed vector and the right operand generates another.
These two boxed vectors are concatenated to form the result, which is also a boxed vector.

<P>
If the data-type of an operand is not boxed then it generates a single-element boxed
vector pointing to it.
If an operand is a boxed vector then it generates a copy of itself.
If an operand is a boxed scalar then it is treated as a boxed vector with a single element.
If an operand is absent (NULL) then it generates a single-element (whose value is 0,
the missing-value) boxed vector.

<P>
A binary operator takes exactly two arguments, one on its left and one on its right.
However some operators allow the effect of additional arguments by
allowing the right-hand argument to be a boxed vector pointing to other NAOs.
In particular, the arithmetic progression operator
&quot;<code>..</code>&quot;
allows its right argument to be a 2-element
boxed vector pointing to <var>final</var> and <var>step</var>, as in:

<PRE>
% [nap "3 .. (9,2)"]
3 5 7 9
</PRE>

which can be written using 
&quot;<code>...</code>&quot; as:

<PRE>
% [nap "3 .. 9 ... 2"]
3 5 7 9
</PRE>

<P>
Similarly, some functions accept multiple arguments.
These are normally specified using the operator &quot;<code>,</code>&quot;.
For example the logarithm function <code>log</code> takes an optional second argument
specifying <var>base</var>, as in:

<PRE>
% [nap "log(32, 2)"]
5
</PRE>

<P>
The operator &quot;<code>,</code>&quot; is also used in <em>cross-product indexing</em>,
as discussed in the section 
<a href="indexing.html">NAP Indexing</a>.

<h3> Concatenation Operators &quot;<code>//</code>&quot; and &quot;<code>///</code>&quot;</h3>

The following example illustrates the difference between 
&quot;<code>//</code>&quot; and &quot;<code>///</code>&quot;:

<PRE>
% [nap "{5 2} // {9 8}"]
5 2 9 8
% [nap "{5 2} /// {9 8}"]
5 2
9 8
</PRE>

<P>
However if the arguments differ in rank (by 1) then both operators are equivalent, as shown by:

<PRE>
% [nap "{{1 3 5}{2 4 6}} // {-1 -9 -2}"]
 1  3  5
 2  4  6
-1 -9 -2
% [nap "{{1 3 5}{2 4 6}} /// {-1 -9 -2}"]
 1  3  5
 2  4  6
-1 -9 -2
</PRE>

<P>
This is convenient for expressions such as:

<PRE>
% [nap "{5 2} /// {9 8} /// {0 1}"]
5 2
9 8
0 1
</PRE>

<h3>Inverse Indexing Operators &quot;<code>@</code>&quot;, &quot;<code>@@</code>&quot;
and &quot;<code>@@@</code>&quot;</h3>

<P>
These three operators all take an optional vector left argument.
The result is a subscript of this vector.
The left argument defaults to the coordinate-variable of the dimension (only relevant
to indirect cross-product indexing, which is discussed in the section 
<a href="indexing.html">NAP Indexing</a>.)

<h3>Interpolated Subscript &quot;<code>@</code>&quot;</h3>

The &quot;<code>@</code>&quot; operator requires a sorted left argument.
The result of
<var>v</var><code>@</code><var>b</var>
is the 
<code>f32</code> subscript <var>s</var> such that
<var>v</var><code>(</code><var>s</var><code>)==</code><var>b</var>.
For example:

<PRE>
% [nap "{1.5 3.4 3.6 4} @ 3.5"]
1.5
% [nap "{1.5 3.4 3.6 4} @ 3.7"]
2.25
</PRE>

<p>
Note that 3.5 is halfway between 3.4 (subscript 1) and 3.6 (subscript 2), so the first
result is 1.5.
Similarly, 3.7 is quarterway between 3.6 (subscript 2) and 4 (subscript 3), so the second
result is 2.25.

<p>
Combining these two examples into one:

<PRE>
% [nap "{1.5 3.4 3.6 4} @ {3.5 3.7}"]
1.5 2.25
</PRE>

<p>
We can check this result by using it as an index:

<PRE>
% [nap "{1.5 3.4 3.6 4} {1.5 2.25}"]
3.5 3.7
</PRE>

<h3>Subscript of Closest &quot;<code>@@</code>&quot;</h3>

<P>
The result of
<var>v</var><code>@@</code><var>b</var>
is the <code>i32</code> subscript <var>s</var> for which 
<code>abs(</code><var>v</var><code>(</code><var>s</var><code>)-</code><var>b</var><code>)</code>
is least.
For example:

<PRE>
% [nap "{1.5 3.4 0 2.4 -1 0} @@ {2 -99}"]
3 4
</PRE>

Element 3 has the value 2.4, which is the closest to 2.
Element 4 has the value -1, which is the closest to -99.

<h3>Subscript of Match &quot;<code>@@@</code>&quot;</h3>

<P>
The result of
<var>v</var><code>@@@</code><var>b</var>
is the smallest <code>i32</code> subscript <var>s</var> for which
<var>v</var><code>(</code><var>s</var><code>)==</code><var>b</var>.
For example:

<PRE>
% [nap "{3 2 9 2 0 3} @@@ {0 3 2}"]
4 0 1
</PRE>

<P>
Element 4 is the only 0,
element 0 is the first 3 and
element 1 is the first 2.

<P>
The following example shows that this operator can be used with character data:

<PRE>
% [nap 'hello world' @@@ 'wol']
6 4 2
</PRE>

<h3>Tally Unary Operator &quot;<code>#</code>&quot;</h3>

<P>
Unary &quot;<code>#</code>&quot; produces a frequency table.
It tallies the number of 0s, 1s, 2s, &hellip;,
as in the following:

<PRE>
% [nap "#{2 5 4 5 2 -3 0 2}"]
1 0 3 0 1 2
</PRE>

<p>
There is one zero, no ones, three twos, no threes, one four and two fives.
Note that the negative value (<code>-3</code>) is ignored.

<p>
If the argument has more than 1 dimension then the result has the same shape, except
that the size of the first dimension is changed to
<var>m</var>+1,
where 
<var>m</var> is the maximum value.
Each element of the result is a frequency tallied over the first dimension.
For example:

<PRE>
% [nap "{{2 5 4 5}{2 -3 0 2}}"]
 2  5  4  5
 2 -3  0  2
% [nap "#{{2 5 4 5}{2 -3 0 2}}"]
0 0 1 0
0 0 0 0
2 0 0 1
0 0 0 0
0 0 1 0
0 1 0 1
</PRE>

<h3>Replicate Binary Operator &quot;<code>#</code>&quot;</h3>

<P>
<code>#</code> can appear within array constants, as in:

<PRE>
% [nap "{7 3#8 0}"]
7 8 8 8 0
</PRE>

<P>
The <code>#</code> operator has a related meaning, as shown by:

<PRE>
% [nap "3#8"]
8 8 8
% [nap "{4 1 0 2} # {7 12 9 8}"] value
7 7 7 7 12 8 8
</PRE>

<P>
Each element of the left argument defines the number of replications of the corresponding
element of the right argument.
The arguments can be vectors or scalars.
The result is a vector.

<p>
Note that one can use this operator to select from a vector those elements which
satisfy some condition.
The following example selects the even elements:

<PRE>
% nap "x = {9 1 0 2 3 -8 0}"
::NAP::286-286
% [nap "(x % 2 == 0) # x"]
0 2 -8 0
</PRE>

<p>
This works because the left-hand argument is:

<PRE>
% [nap "(x % 2 == 0)"] value
0 0 1 1 0 1 1
</PRE>

<P>
If the right-hand argument <var>b</var> is multidimensional then the left-hand
argument must be a boxed vector pointing to a vector corresponding to each dimension of 
<var>b</var>.
For example:

<PRE>
% nap "mat = reshape(1 .. 12, {3 4})"
::NAP::316-316
% $mat
 1  2  3  4
 5  6  7  8
 9 10 11 12
% [nap "({2 0 1},{3 2 0 1}) # mat"]
 1  1  1  2  2  4
 1  1  1  2  2  4
 9  9  9 10 10 12
</PRE>

<p>
This is equivalent to using the following cross-product index:

<PRE>
% [nap "mat({0 0 2},{0 0 0 1 1 3})"]
 1  1  1  2  2  4
 1  1  1  2  2  4
 9  9  9 10 10 12
</PRE>

<P>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="737b9c">
  <TR>
    <TD align="center"><FONT color="#ffffff" size=-2><SPAN class="titlebar">
        <b>Author:</b> <a href="http://sourceforge.net/users/dav480/">Harvey Davies</a>
        &nbsp; &nbsp; &nbsp;
        &copy; 2002, CSIRO Australia.
        &nbsp; &nbsp; &nbsp;
        <a href="http://www.csiro.au/legalnotices/disclaimer.html">Legal Notice and Disclaimer</a>
        <br>

        <b>CVS Version Details:</b> $Id: op.html,v 1.2 2002/08/07 08:58:48 dav480 Exp $
        </SPAN></FONT>
    </TD>
  </TR>
</TABLE>

</body>
</html>
