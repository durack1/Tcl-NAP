<!-- $Id: op.html,v 1.14 2005/07/14 08:16:09 dav480 Exp $ -->
<html>

<head> <title>
NAP Operators
</title> </head>

<body>

<h2> <center>
Operators
</center> </h2>

<h3>Table of Contents</h3>

<ol>
    <li><a href="#Precedence">Operators and Precedence</a>
    <li><a href="#Assignment">Assignment Operator &quot;<code>=</code>&quot;</a>
    <li><a href="#Link">
	Link Operator &quot;<code>,</code>&quot;</a>
    <li><a href="#AP">Arithmetic Progression Operators &quot;<code>..</code>&quot;
	and &quot;<code>...</code>&quot;</a>
    <li><a href="#Concatenation">
	Concatenation Operators &quot;<code>//</code>&quot; and &quot;<code>///</code>&quot;</a>
    <li><a href="#Inverse_Indexing">
	Inverse Indexing Operators &quot;<code>@</code>&quot;, &quot;<code>@@</code>&quot;
	and &quot;<code>@@@</code>&quot;</a>
    <ol>
	<li><a href="#Interpolated_Subscript">Interpolated Subscript &quot;<code>@</code>&quot;</a>
	<li><a href="#Subscript_of_Closest">Subscript of Closest &quot;<code>@@</code>&quot;</a>
	<li><a href="#Subscript_of_Match">Subscript of Match &quot;<code>@@@</code>&quot;</a>
    </ol>
    <li><a href="#Tally">Tally Unary Operator &quot;<code>#</code>&quot;</a>
    <li><a href="#Replicate">Replicate Binary Operator &quot;<code>#</code>&quot;</a>
    <li><a href="#Remainder">Remainder Operator &quot;<code>%</code>&quot;</a>
</ol>

<h3><a name=Precedence>Operators and Precedence</h3>

<p>
The following table is essentially a superset of <b>Table 5.2</b> in Ousterhout's 
1994 classic <cite>Tcl and the Tk Toolkit</cite>. As there, groups of operators 
between horizontal lines have the same precedence; higher groups have higher precedence. 

<p>
Operators are left-associative unless specified otherwise.
For example, <code>**</code> is right-associative, as shown by:

<pre>
% [nap "10 ** 2 ** 3"]
1e+08
</pre>

<p>
The nature of operands is indicated as follows:
<br>
<var>a</var> and <var>b</var> represent general arrays.
<br>
<var>x</var>, <var>y</var> and <var>z</var> represent scalars.
<br>
<var>u</var> and <var>v</var> represent vectors.
<br>
<var>A</var> and <var>B</var> represent matrices.
<br>
<var>n</var> represents a Tcl name, which may include namespaces.
<br>
<var>p</var> represents a boxed vector of pointers to arrays
<var>a<sub>0</sub></var>,
<var>a<sub>1</sub></var>,
<var>a<sub>2</sub></var>,
&hellip;

<p>
'AP' means <em>arithmetic progression</em>.

<p>
<table>
    <colgroup span=1> <colgroup span=1>

    <tr><td><hr><td><hr>

    <tr>
	<th align=left>Syntax
	<th align=left>Result

    <tr><td><hr><td><hr>

	<tr valign=bottom> <td>
		<var>a</var><code>**</code><var>b</var>
	    <td>
		<var>a<sup>b</sup></var>. Right-associative

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<code>+</code><var>a</var>
	    <td>
		New copy of <var>a</var>
	<tr valign=top> <td>
		<code>-</code><var>a</var>
	    <td>
		Negative of <var>a</var>
	<tr valign=top> <td>
		<code>!</code><var>a</var>
	    <td>
		Logical NOT: 1 if <var>a</var> is zero, else 0
	<tr valign=top> <td>
		<code>|</code><var>a</var>
	    <td>
		Absolute value of <var>a</var> = <code>abs(</code><var>a</var><code>)</code>
	<tr valign=top> <td>
		<code>^</code><var>a</var>
	    <td>
		Nearest integer to <var>a</var>
		= <code>i32(nint(</code><var>a</var><code>))</code>
	<tr valign=top> <td>
		<code><</code><var>a</var>
	    <td>
		Largest integer not greater than <var>a</var>
		= <code>i32(floor(</code><var>a</var><code>))</code>
	<tr valign=top> <td>
		<code>></code><var>a</var>
	    <td>
		Smallest integer not less than <var>a</var>
		= <code>i32(ceil(</code><var>a</var><code>))</code>
	<tr valign=top> <td>
		<code>~</code><var>a</var>
	    <td>
		Bit-wise complement of <var>a</var>
	<tr valign=top> <td>
		<code>#</code><var>a</var>
	    <td>
		Frequencies of values 0, 1, 2, &hellip;
	<tr valign=top> <td>
		<code>@</code><var>a</var>
	    <td>
		Indirect subscript

	<tr valign=top> <td>
		<code>@@</code><var>a</var>
	    <td>
		Indirect subscript

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>v</var><code>@</code><var>b</var>
	    <td>
		smallest <var>s</var> such that
		<var>v<sub>s</sub>=b</var>
	<tr valign=top> <td>
		<var>v</var><code>@@</code><var>b</var>
	    <td>
		<code>i32</code> <var>s</var> for which 
		|<var>v<sub>s</sub>-b</var>|
		    is least
	<tr valign=top> <td>
		<var>v</var><code>@@@</code><var>b</var>
	    <td>
		smallest <code>i32</code> <var>s</var> for which
		<var>v<sub>s</sub>=b</var>

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>u</var><code>#</code><var>v</var>
	    <td>
		<var>u</var> copies of <var>v</var>

	<tr valign=top> <td>
		<var>p</var><code>#</code><var>b</var>
	    <td>
		Cross-product replication

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>u</var><code>.</code><var>v</var>
	    <td>
		(<var>u</var> and <var>v</var> vectors)
		Scalar (dot) product

	<tr valign=top> <td>
		<var>A</var><code>.</code><var>B</var>
	    <td>
		(<var>A</var> and <var>B</var> matrices)
		Matrix product

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>*</code><var>b</var>
	    <td>
		<var>a</var> &times; <var>b</var> 
	<tr valign=top> <td>
		<var>a</var><code>/</code><var>b</var>
	    <td>
		<var>a</var> &divide; <var>b</var> 
	<tr valign=top> <td>
		<var>a</var><code>%</code><var>b</var>
	    <td>
		Remainder after dividing <var>a</var> by <var>b</var>

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>+</code><var>b</var>
	    <td>
		<var>a</var> + <var>b</var>
	<tr valign=top> <td>
		<var>a</var><code>-</code><var>b</var>
	    <td>
		<var>a</var> &minus; <var>b</var> 

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code><<</code><var>b</var>
	    <td>
		Left-shift <var>a</var> by <var>b</var> bits
	<tr valign=top> <td>
		<var>a</var><code>>></code><var>b</var>
	    <td>
		Right-shift <var>a</var> by <var>b</var> bits

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code><<<</code><var>b</var>
	    <td>
		Lesser of <var>a</var> and <var>b</var>
	<tr valign=top> <td>
		<var>a</var><code>>>></code><var>b</var>
	    <td>
		Greater of <var>a</var> and <var>b</var>

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code><</code><var>b</var>
	    <td>
		1 if <var>a</var> &lt; <var>b</var>,
		else 0
	<tr valign=top> <td>
		<var>a</var><code>></code><var>b</var>
	    <td>
		1 if <var>a</var> &gt; <var>b</var>,
		else 0
	<tr valign=top> <td>
		<var>a</var><code><=</code><var>b</var>
	    <td>
		1 if <var>a</var> &le; <var>b</var>,
		else 0
	<tr valign=top> <td>
		<var>a</var><code>>=</code><var>b</var>
	    <td>
		1 if <var>a</var> &ge; <var>b</var>,
		else 0

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>==</code><var>b</var>
	    <td>
		1 if <var>a</var> = <var>b</var>, else 0
	<tr valign=top> <td>
		<var>a</var><code>!=</code><var>b</var>
	    <td>
		1 if <var>a</var> &ne; <var>b</var>,
		else 0

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>&</code><var>b</var>
	    <td>
		Bit-wise AND of <var>a</var> and <var>b</var>

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>^</code><var>b</var>
	    <td>
		Bit-wise exclusive OR of <var>a</var> and <var>b</var>

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>|</code><var>b</var>
	    <td>
		Bit-wise OR of <var>a</var> and <var>b</var>

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>&&</code><var>b</var>
	    <td>
		Logical AND: 1 if 
		<var>a</var> &ne; 0
		and
		<var>b</var> &ne; 0,
		else 0

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>||</code><var>b</var>
	    <td>
		Logical OR: 1 if 
		<var>a</var> &ne; 0
		or
		<var>b</var> &ne; 0,
		else 0

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>x</var><code>..</code><var>y</var>
	    <td>
		AP from <var>x</var> to <var>y</var>
		in steps of <code>+1</code> or <code>-1</code>

	<tr valign=top> <td>
		<var>x</var><code>..</code><var>y</var><code>...</code><var>z</var>
	    <td>
		AP from <var>x</var> to <var>y</var>
		in steps of <var>z</var>

	<tr valign=top> <td>
		<var>x</var><code>...</code><var>y</var><code>..</code><var>z</var>
	    <td>
		AP from
		<var>y</var> to <var>z</var>
		with <var>x</var> elements

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>?</code><var>b</var><code>:</code><var>c</var>
	    <td>
		Choice: if 
		<var>a</var> &ne; 0
		then <var>b</var>, 
		else <var>c</var>

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>a</var><code>//</code><var>b</var>
	    <td>
		Concatenate along existing dimension
	<tr valign=top> <td>
		<var>a</var><code>///</code><var>b</var>
	    <td>
		Concatenate along new dimension

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		[<var>a</var>]<code>,</code>[<var>b</var>]
		<td>
		Boxed vector pointing to <var>a</var>
		and <var>b</var>
		(unless already boxed)
		<br>
		If <var>a</var> or <var>b</var>
		is already boxed then concatentate it

    <tr><td><hr><td><hr>

	<tr valign=top> <td>
		<var>n</var><code>=</code><var>a</var>
	    <td>
		Result is <var>a</var>. Right-associative
		<br>
		Side Effect: Set <var>n</var> to OOC-name of <var>a</var>

    <tr><td><hr><td><hr>

</table>

<h3><a name=Assignment>Assignment Operator &quot;<code>=</code>&quot;</h3>

<p>
The &quot;<code>nap</code>&quot; command
(unlike &quot;<code>expr</code>&quot;)
allows the assignment operator 
  &quot;<code>=</code>&quot;. The left-hand operand must be a Tcl name, which 
  is used to define a Tcl variable whose (string) value is set to the OOC-name of 
  the right-hand operand. The assignment operator has a result like any other 
  operator. This result is the value of the right-hand operand. This is shown 
  in the following: </p>

<PRE>
% nap "a = (b = 6) + 2"
::NAP::15-15
% $b
6
% $a
8
</PRE>

<p>
The assignment operator has the lowest precedence and is right-associative, allowing 
expressions such as:

<PRE>
% nap "a = 3 + b = {1.5 0}"
::NAP::16-16
% $b
1.5 0
% $a
4.5 3
</PRE>

<h3><a name=Link>Link Operator &quot;<code>,</code>&quot;</h3>

<P>
The link operator &quot;<code>,</code>&quot;
produces a boxed vector pointing to the operands.
A common use of 
&quot;<code>,</code>&quot;
is to pass multiple arguments to a function.
For example the logarithm function <code>log</code> takes an optional second argument
specifying <var>base</var>, as in:

<PRE>
% [nap "log(32, 2)"]
5
</PRE>

<P>
The operator &quot;<code>,</code>&quot; is also used in <em>cross-product indexing</em>,
as discussed in the section 
<a href="indexing.html">NAP Indexing</a>.

<P>
The left-hand operand of 
&quot;<code>,</code>&quot;
generates one boxed vector and the right-hand operand generates another.
These two boxed vectors are concatenated to form the result, which is also a boxed vector.
If the data-type of an operand is not boxed then it generates a single-element boxed
vector pointing to it.
If an operand is a boxed vector then it generates a copy of itself.
If an operand is a boxed scalar then it is treated as a boxed vector with a single element.
If an operand is absent (NULL) then it generates a single-element (whose value is 0,
the missing-value) boxed vector.

<h3>
<a name=AP>Arithmetic Progression Operators
&quot;<code>..</code>&quot;
and
&quot;<code>...</code>&quot;
</h3>

<P>
The operator
&quot;<code>..</code>&quot;
generates an arithmetic progression.
If both operands are simple numeric scalars 
then the step size is +1 or &minus;1,
the left-hand operand specifies the first value and
the right-hand operand specifies the final value.
For example:

<PRE>
% [nap "3 .. 6"]
3 4 5 6
% [nap "6 .. 3"]
6 5 4 3
% [nap "1.8 .. -1.2"]
1.8 0.8 -0.2 -1.2
</PRE>

If the difference between the operands is not an integral multiple of the 
step size then the final step is smaller than the preceding steps.
This is shown by:

<PRE>
% [nap "2.3 .. 5.9"]
2.3 3.3 4.3 5.3 5.9
</PRE>

<P>
The right-hand operand can be a boxed two-element vector pointing to the final value and the step size.
Such a boxed operand is usually generated using the operator
&quot;<code>...</code>&quot;,
as in:

<PRE>
% [nap "3 .. 9 ... 2"]
3 5 7 9
% [nap "0 .. -1.6 ... -0.5"]
0 -0.5 -1 -1.5 -1.6
</PRE>

<P>
The left-hand operand can be a boxed two-element vector pointing to the number of elements
and the first value.
Such a boxed operand is also usually generated using the operator
&quot;<code>...</code>&quot;,
as in:

<PRE>
% [nap "5 ... 1 .. 7"]
1 2.5 4 5.5 7
</PRE>

It is not legal for both operands to be boxed.
It is legal to specify a non-integral number of elements, as in:

<PRE>
% [nap "3.5 ... 2 .. 12"]
2 6 10 12
</PRE>

Note that 3.5 elements means 2.5 steps.
There are two full steps of 4, followed by a half step of 2.
When the left-hand operand is boxed the step size is calculated using
(<var>final</var>&nbsp;&minus;&nbsp;<var>first</var>)/(<var>n</var>&nbsp;&minus;&nbsp;1),
where <var>n</var> is the number of elements.

<P>
The data-type of the result depends on the data-types of
<var>first</var>, <var>final</var> and <var>step</var>.
For example:

<PRE>
% [nap "1 .. 7.0 ... 2"] all
::NAP::262-262  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 4      Name: (NULL)    Coordinate-variable: (NULL)
Value:
1 3 5 7
</PRE>

<h3><a name=Concatenation>
Concatenation Operators &quot;<code>//</code>&quot; and &quot;<code>///</code>&quot;</h3>

<P>
The following example illustrates the difference between 
&quot;<code>//</code>&quot; and &quot;<code>///</code>&quot; with vector operands:

<PRE>
% [nap "{5 2} // {9 8}"]
5 2 9 8
% [nap "{5 2} /// {9 8}"]
5 2
9 8
</PRE>

<P>
The following example illustrates the difference between 
&quot;<code>//</code>&quot; and &quot;<code>///</code>&quot; with matrix operands:

<PRE>
% [nap "{{6 2 1}{0 9 4}} // {{7 2 7}{3 3 8}}"] all
::NAP::29-29  i32  MissingValue: -2147483648  References: 0  Unit: (NULL)
Dimension 0   Size: 4      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
6 2 1
0 9 4
7 2 7
3 3 8
% [nap "{{6 2 1}{0 9 4}} /// {{7 2 7}{3 3 8}}"] all
::NAP::35-35  i32  MissingValue: -2147483648  References: 0  Unit: (NULL)
Dimension 0   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 2   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
6 2 1
0 9 4

7 2 7
3 3 8
</PRE>

<P>
Note that &quot;<code>//</code>&quot; concatenates along the most significant existing
dimension, whereas &quot;<code>///</code>&quot; concatenates along a new dimension.
This new dimension is of size 2 and is more significant that the existing dimensions.

<P>
The above examples had operands with identical shapes and data-types.
It is obviously desirable to allow the operands of &quot;<code>//</code>&quot; 
to have different sized leading (most significant) dimensions.
NAP does allow this, as shown by:

<PRE>
% [nap "'Hello' // ' world.'"]
Hello world.
% [nap "{{6 2 1}{0 9 4}} // {{7 2 7}}"]
6 2 1
0 9 4
7 2 7
</PRE>

<P>
In fact, both operators allow any combination of shapes.
Operands of &quot;<code>///</code>&quot; are reshaped to the same shape.
Operands of &quot;<code>//</code>&quot; are reshaped so all dimensions except
the leading one have the same size.
The following examples illustrate this reshaping process (with data-type conversion when required):

<PRE>
% [nap "{{6 2 1}{0 9 4}} // {7 2 7}"]
6 2 1
0 9 4
7 2 7
% [nap "{{6 2 1}{0 9 4}} // 3.0"] all
::NAP::142-142  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
6 2 1
0 9 4
3 3 3
% [nap "{{6 2 1}{0 9 4}} /// 3.0"] all
::NAP::148-148  f64  MissingValue: NaN  References: 0  Unit: (NULL)
Dimension 0   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 1   Size: 2      Name: (NULL)    Coordinate-variable: (NULL)
Dimension 2   Size: 3      Name: (NULL)    Coordinate-variable: (NULL)
Value:
6 2 1
0 9 4

3 3 3
3 3 3
</PRE>

<h3><a name=Inverse_Indexing>
Inverse Indexing Operators &quot;<code>@</code>&quot;, &quot;<code>@@</code>&quot;
and &quot;<code>@@@</code>&quot;</h3>

<P>
These three operators all take an optional vector left-hand operand.
(The &quot;<code>@</code>&quot; operator also allows the left-hand operand to have a rank
greater than 1.)
The result is a subscript of this vector.
The left-hand operand defaults to the coordinate-variable of the dimension (only relevant to 
<a href="indexing.html#indirect_indexing">indirect indexing</a>).

<P>
The right-hand operand is attached to the result using its
<a href="nao.html"><em>link slot</em></a>.
This enables the right-hand operand
to be automatically used as a coordinate variable if the result is directly
used as an index.
Note that the results of operators/functions do not normally retain any links in their
operands/arguments, so this only applies to <em>direct</em> use.
(The right-hand operand would not be an appropriate coordinate variable if there were further
arithmetic prior to indexing.)

<h4><a name=Interpolated_Subscript>Interpolated Subscript &quot;<code>@</code>&quot;</h4>

The result of
<var>v</var><code>@</code><var>b</var>
is the smallest (possibly fractional)
<code>f32</code> subscript <var>s</var> such that
<var>v</var><code>(</code><var>s</var><code>)==</code><var>b</var>.
For example:

<PRE>
% [nap "{1.5 3.4 3.6 4} @ 3.5"]
1.5
% [nap "{1.5 3.4 3.6 4} @ 3.7"]
2.25
</PRE>

<p>
Note that 3.5 is halfway between 3.4 (subscript 1) and 3.6 (subscript 2), so the first
result is 1.5.
Similarly, 3.7 is quarterway between 3.6 (subscript 2) and 4 (subscript 3), so the second
result is 2.25.

<p>
Combining these two examples into one:

<PRE>
% [nap "{1.5 3.4 3.6 4} @ {3.5 3.7}"]
1.5 2.25
</PRE>

<p>
We can check this result by using it as an index:

<PRE>
% [nap "{1.5 3.4 3.6 4}({1.5 2.25})"]
3.5 3.7
</PRE>

<p>
The following example has multiple exact matches.
In this case the result is defined as the mean of the matching subscripts.

<PRE>
% [nap "{1.3 6.5 6.5 7.1} @ 6.5"]
1.5
</PRE>

<p>
The following example shows how extrapolation is used to define the result
when the right-hand operand is outside the range of the left-hand operand:

<PRE>
% [nap "{-1 0 2} @ {-2 5}"]
-1 3.5
</PRE>

<p>
Such extrapolation can be prevented by adding end points with missing or infinite values, as in:

<PRE>
% [nap "{_ -1 0 2 _} @ {-2 -1 2 5}"]
_ 1 3 _
% [nap "{-1i -1 0 2 1i} @ {-2 -1 2 5}"]
1 1 3 3
</PRE>

<p>
The effect of other missing values is shown by:

<PRE>
% [nap "{_ 2 4 _ 6 8 _} @ (1 .. 9)"] value
_ 1 1.5 2 _ 4 4.5 5 _
</PRE>

<p>
If the left-hand operand is not monotonic (sorted) then the result is defined by the first match, as in:

<PRE>
% [nap "{2 4 5 3} @ (1 .. 6)"]
-0.5 0 0.5 1 2 _
</PRE>

<p>
The left-hand operand can have a rank greater than 1.
In this case the search takes place over the most significant dimension (0) of the left-hand operand.
The following example seaches down each column for the value <code>0.7</code>.

<PRE>
% nap "mat = {
    {0.3 0.1 0.9}
    {0.5 0.5 0.8}
    {0.6 0.1 0.6}
    {0.8 0.0   _}
}"
::NAP::157-157
% [nap "mat @ 0.7"]
2.5 _ 1.5
</PRE>

<p>
Thus this combines the effect of the following three commands.

<PRE>
% [nap "{0.3 0.5 0.6 0.8} @ 0.7"]
2.5
% [nap "{0.1 0.5 0.1 0.0} @ 0.7"]
_
% [nap "{0.9 0.8 0.6 _} @ 0.7"]
1.5
</PRE>

<p>
The right-hand operand can have any rank, but trailing dimensions (excluding dimension 0
of the left-hand operand) must match.
The following example has a right-hand operand with the same number (3) of columns as
<code>mat</code>.

<PRE>
% [nap "mat @ {{0.7 0.7 0.7}{0.4 0.5 0.8}}"]
2.5   _ 1.5
0.5 1.0 1.0
</PRE>

<p>
The following 3D array contains ocean temperature data for 4 depths, 2 latitudes and 3 longitudes.
Note that some (shallower) points have missing values at the deepest level.
For each (latitude, longitude) point, we want to find the depth (subscript)
corresponding to a temperature of 10 degrees.
The missing value in the result corresponds to an oceanic column whose minimum temperature is 12.

<PRE>
% nap "temperature = {
    {{11 12 13}{11 11 12}}
    {{ 9  9 13}{11  8 10}}
    {{ 8 10 12}{ 9  8 10}}
    {{ 6  2  _}{ 5  _  _}}
}"
% [nap "temperature @ 10"]
0.500000 0.666667        _
1.500000 0.333333 1.000000
</PRE>

<h4><a name=Subscript_of_Closest>Subscript of Closest &quot;<code>@@</code>&quot;</h4>

<P>
The result of
<var>v</var><code>@@</code><var>b</var>
is the <code>i32</code> subscript <var>s</var> for which 
<code>abs(</code><var>v</var><code>(</code><var>s</var><code>)-</code><var>b</var><code>)</code>
is least.
For example:

<PRE>
% [nap "{1.5 3.4 0 2.4 -1 0} @@ {2 -99}"]
3 4
</PRE>

Element 3 has the value 2.4, which is the closest to 2.
Element 4 has the value -1, which is the closest to -99.

<P>
The following example shows how the right-hand operand becomes the coordinate variable
if the result is used directly as an index, but not if there is further arithmetic.

<PRE>
% nap "coarse = {4 8 7}"
::NAP::14-14
% nap "time = {2 3 5}"
::NAP::16-16
% $coarse set coo time
% [nap "fine = coarse(time@@(2.4 .. 4.6 ... 0.2))"] value
4 8 8 8 8 8 8 8 8 7 7 7
% [$fine coo] value; # Display coordinate variable
2.4 2.6 2.8 3 3.2 3.4 3.6 3.8 4 4.2 4.4 4.6
% [nap "fine = coarse(time@@(2.4 .. 4.6 ... 0.2)+1)"] value; # Do further arithmetic
8 7 7 7 7 7 7 7 7 4 4 4
% [$fine coo] value; # Display coordinate variable
3 5 5 5 5 5 5 5 5 2 2 2
</PRE>

<h4><a name=Subscript_of_Match>Subscript of Match &quot;<code>@@@</code>&quot;</h4>

<P>
The result of
<var>v</var><code>@@@</code><var>b</var>
is the smallest <code>i32</code> subscript <var>s</var> for which
<var>v</var><code>(</code><var>s</var><code>)==</code><var>b</var>.
For example:

<PRE>
% [nap "{3 2 9 2 0 3} @@@ {0 3 2}"]
4 0 1
</PRE>

<P>
Element 4 is the only 0,
element 0 is the first 3 and
element 1 is the first 2.

<P>
The following example shows that this operator can be used with character data:

<PRE>
% [nap 'hello world' @@@ 'wol']
6 4 2
</PRE>

<h3><a name=Tally>Tally Unary Operator &quot;<code>#</code>&quot;</h3>

<P>
Unary &quot;<code>#</code>&quot; produces a frequency table.
It tallies the number of 0s, 1s, 2s, &hellip;,
as in the following:

<PRE>
% [nap "#{2 5 4 5 2 -3 0 2}"]
1 0 3 0 1 2
</PRE>

<p>
There is one zero, no ones, three twos, no threes, one four and two fives.
Note that the negative value (<code>-3</code>) is ignored.

<p>
If the operand has more than 1 dimension then the result has the same shape, except
that the size of the first dimension is changed to
<var>m</var>+1,
where 
<var>m</var> is the maximum value.
Each element of the result is a frequency tallied over the first dimension.
For example:

<PRE>
% [nap "{{2 5 4 5}{2 -3 0 2}}"]
 2  5  4  5
 2 -3  0  2
% [nap "#{{2 5 4 5}{2 -3 0 2}}"]
0 0 1 0
0 0 0 0
2 0 0 1
0 0 0 0
0 0 1 0
0 1 0 1
</PRE>

<p>
If the operand is boxed and points to <var>n</var> arrays (which each have the same
number of elements) then the result is the
<var>n</var>-dimensional array of joint frequencies.
For example:

<PRE>
% [nap "#({2 1 1 0 1},{1 1 3 2 1})"]
0 0 1 0
0 2 0 1
0 1 0 0
</PRE>

<p>
The boxed operand defines the five pairs (2,1), (1,1), (1,3), (0,2) and (1,1).
The above result gives the frequencies of these pairs.

<h3><a name=Replicate>Replicate Binary Operator &quot;<code>#</code>&quot;</h3>

<P>
<code>#</code> can appear within array constants, as in:

<PRE>
% [nap "{7 3#8 0}"]
7 8 8 8 0
</PRE>

<P>
The <code>#</code> operator has a related meaning, as shown by:

<PRE>
% [nap "3#8"]
8 8 8
% [nap "{4 1 0 2} # {7 12 9 8}"] value
7 7 7 7 12 8 8
</PRE>

<P>
Each element of the left-hand operand defines the number of replications of the corresponding
element of the right-hand operand.
The operands can be vectors or scalars.
The result is a vector.

<p>
Note that one can use this operator to select from a vector those elements which
satisfy some condition.
The following example selects the even elements:

<PRE>
% nap "x = {9 1 0 2 3 -8 0}"
::NAP::286-286
% [nap "(x % 2 == 0) # x"]
0 2 -8 0
</PRE>

<p>
This works because the left-hand operand is:

<PRE>
% [nap "(x % 2 == 0)"] value
0 0 1 1 0 1 1
</PRE>

<P>
If the right-hand operand <var>b</var> is multidimensional then the left-hand
operand must be a boxed vector pointing to a vector corresponding to each dimension of 
<var>b</var>.
For example:

<PRE>
% nap "mat = reshape(1 .. 12, {3 4})"
::NAP::316-316
% $mat
 1  2  3  4
 5  6  7  8
 9 10 11 12
% [nap "({2 0 1},{3 2 0 1}) # mat"]
 1  1  1  2  2  4
 1  1  1  2  2  4
 9  9  9 10 10 12
</PRE>

<p>
This is equivalent to using the following cross-product index:

<PRE>
% [nap "mat({0 0 2},{0 0 0 1 1 3})"]
 1  1  1  2  2  4
 1  1  1  2  2  4
 9  9  9 10 10 12
</PRE>

<h3><a name=Remainder>Remainder Operator &quot;<code>%</code>&quot;</h3>

The value of the remainder 
<var>r</var> = <var>a</var> <code>%</code> <var>b</var>
is defined for all real 
<var>a</var> and <var>b</var>
so that:
<br>
if <var>b</var> &gt; 0 then 0 &le; <var>r</var> &lt; <var>b</var><br>
if <var>b</var> = 0 then <var>r</var> = 0<br>
if <var>b</var> &lt; 0 then <var>b</var> &lt; <var>r</var> &le; 0<br>
if <var>a</var> &ge; 0 and b = &infin; then <var>r</var> = <var>a</var><br>
if <var>a</var> &le; 0 and b = &minus;&infin; then <var>r</var> = <var>a</var><br>
if <var>a</var> &lt; 0 and b = &infin; then <var>r</var> = &infin;<br>
if <var>a</var> &gt; 0 and b = &minus;&infin; then <var>r</var> = &minus;&infin;.
<br>
Thus:

<PRE>
% [nap "0.7 % {0.3 0 -0.3}"]
0.1 0 -0.2
% [nap "{7 0 -7} % 1if32"]
7 0 Inf
% [nap "{7 0 -7} % -1if32"]
-Inf 0 -7
</PRE>

<P>
<TABLE width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="737b9c">
  <TR>
    <TD align="center"><FONT color="#ffffff" size=-2><SPAN class="titlebar">
        <b>Author:</b> <a href="http://sourceforge.net/users/dav480/">Harvey Davies</a>
        &nbsp; &nbsp; &nbsp;
        &copy; 2002, CSIRO Australia.
        &nbsp; &nbsp; &nbsp;
        <a href="http://www.csiro.au/legalnotices/disclaimer.html">Legal Notice and Disclaimer</a>
        <br>

        <b>CVS Version Details:</b> $Id: op.html,v 1.14 2005/07/14 08:16:09 dav480 Exp $
        </SPAN></FONT>
    </TD>
  </TR>
</TABLE>

</body>
</html>
